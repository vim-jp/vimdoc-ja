*change.txt*    For Vim バージョン 9.1.  Last change: 2025 Jul 15


		  VIMリファレンスマニュアル    by Bram Moolenaar


このファイルでは、テキストを削除したり変更するコマンドの説明をする。この文章の
中では、「テキストを変更する」とは、一つのコマンドでテキストを削除し、別のテキ
ストに置き換えることを意味する。これらのコマンドは全てアンドゥできる。非Exコマ
ンドはコマンド "." で繰り返すことができる。

1. テキストの削除		|deleting|
2. 削除と挿入			|delete-insert|
3. 単純な変更			|simple-change|		*changing*
4. 複雑な変更			|complex-change|
   4.1 フィルタコマンド		   |filter|
   4.2 置換			   |:substitute|
   4.3 検索と置換		   |search-replace|
   4.4 タブの変換		   |change-tabs|
5. テキストのコピーと移動	|copy-move|
6. テキストの整形		|formatting|
7. テキストのソート             |sorting|
8. テキストの重複除去		|deduplicating|

テキストの挿入に関しては |insert.txt| を参照。

==============================================================================
1. テキストの削除					*deleting* *E470*

["x]<Del>	または					*<Del>* *x* *dl*
["x]x			カーソル下から後の [count] 文字を [レジスタ x に入れ]
			削除する (行単位ではない|linewise|)。"dl" と同じであ
                        る。<Del> キーには [count] が使えない。代わりに、
                        [count] の最後の文字を削除する {訳注: 123<Del>と押すと
                        3が消え12になる}。<Del> キーが思ったように動作しない
			ときは、|:fixdel| を参照。<EOL> の削除 (行の連結) につ
			いては、'whichwrap' を参照。

							*X* *dh*
["x]X			カーソルから前の [count] 文字を [レジスタ x に入れ] 削
			除する (行単位ではない|linewise|)。"dh" と同じである。
                        'whichwrap' も参照。

							*d*
["x]d{motion}		{motion} でカーソルが動く範囲のテキストを [レジスタ x
			に入れ] 削除する。例外については以下を参照。

							*dd*
["x]dd			[count] 行を [レジスタ x に入れ] 削除する (行単位
			|linewise|)。

							*D*
["x]D			カーソル下から行の最後までの文字と、[count]-1 行を、
			[レジスタ x に入れ] 削除する。"d$" と同義
			(行単位ではない|linewise|)。
			'cpoptions' にフラグ '#' が入っているとカウントは無視
			される。

{Visual}["x]x	または					*v_x* *v_d* *v_<Del>*
{Visual}["x]d	または
{Visual}["x]<Del>	ビジュアル選択されたテキストを [レジスタ x に入れ] 削
			除する({Visual} については |Visual-mode| を参照)。

{Visual}["x]CTRL-H   または				*v_CTRL-H* *v_<BS>*
{Visual}["x]<BS>	選択モード内で: ビジュアル選択されたテキストを [レジス
			タ x に入れ] 削除する。

{Visual}["x]X	または					*v_X* *v_D* *v_b_D*
{Visual}["x]D		ビジュアル選択された行を [レジスタ x に入れ] 削除する
			({Visual} については |Visual-mode| を参照)。矩形ビジュ
			アルモードでは、"D" はビジュアル選択されたテキストと行
			末までの全てのテキストを削除する。

					*:d* *:de* *:del* *:delete* *:dl* *:dp*
:[range]d[elete] [x]	[range] 行 (既定値: 現在行) を [レジスタ x に入れ] 削
			除する。
			Note これらの変な短縮入力:
			   :dl		delete と list
			   :dell	同上
			   :delel	同上
			   :deletl	同上
			   :deletel	同上
			   :dp		delete と print
			   :dep		同上
			   :delp	同上
			   :delep	同上
			   :deletp	同上
			   :deletep	同上

:[range]d[elete] [x] {count}
			[range] 行目 (既定: 現在行 |cmdline-ranges|) から
			{count} 行を [レジスタ x に入れ] 削除する。

これらのコマンドはテキストを削除する。これらは (`:d` を除いて) コマンド `.` で
繰り返したり、アンドゥできる。テキストのブロックを削除するには、ビジュアルモー
ドを使う。レジスタの説明については、|registers| を参照。
							*d-special*
コマンド "d{motion}" に関する例外: 移動が行単位でなく、移動の開始点と終了点が
同じ行になく、移動の開始点の前に空白しかなく終了点の後に空行以外がない場合に
は、削除は行単位となる。このときユーザーは空白のみの行が残ると期待するかもしれ
ないが、共に削除される。強制的にモーションを文字単位にするために |o_v| オペレー
タを使用するか、この特性を無効にするために 'cpoptions' から "z" フラグを削除す
る (|cpo-z| を参照)。

オプション 'cpoptions' がフラグ 'E' を含んでいるときは、テキストの空の範囲を削
除しようとすると (例えば、1列目での "d0")、エラーになる。

							*J*
J			[count] 行を連結する (最低は 2 行)。インデントを削除
			し、空白を最大 2 個まで挿入する (以下を参照)。バッファ
			の最終行では失敗する。
			大きすぎる [count] は、有効な行数まで減少される。

							*v_J*
{Visual}J		ビジュアル選択された行を連結する (最低は 2 行)。インデ
			ントを削除し、空白を最大 2 個まで挿入する (以下を参照)

							*gJ*
gJ			[count] 行を連結する (最低は 2 行)。空白の挿入や削除を
			行わない。

							*v_gJ*
{Visual}gJ		ビジュアル選択された行を連結する (最低は 2 行)。空白の
			挿入や削除を行わない。

							*:j* *:join*
:[range]j[oin][!] [flags]
                        [range] 行を連結する。"J" と同様だが、[!] と共に使うと
			空白の挿入や削除を行わない。[range] の開始点と終了点が
			同じときは、このコマンドは何もしない。既定の動作では、
			現在行を次行と連結する。
                        [flags]については|ex-flags|を参照。

:[range]j[oin][!] {count} [flags]
			[range] 行目 (既定では現在行 |cmdline-ranges|) からの
			{count} 行を連結する。"J" と同様だが、[!] と共に使うと
			空白の挿入や削除を行わない。
                        [flags]については|ex-flags|を参照。

これらのコマンドは、行の間の <EOL> を削除する。この結果、複数行が1行に連結され
る。これらのコマンド (`:j` 以外) は、繰り返しやアンドゥができる。

これらのコマンド ("gJ" 以外) は <EOL> の場所に空白を1個挿入する。ただし行末に
空白が付いていたり、次の行が ')' で始まるときは挿入しない。これらのコマンド
("gJ" 以外) は次行の先頭あたりにある空白を全て削除する。オプション
'joinspaces' がオンのときは、これらのコマンドは '.', '!', '?' の後に2個の空白
を挿入する (しかし 'cpoptions' がフラグ 'j' を含んでいるときは、2個の空白は
'.' の後にしか挿入しない)。
'formatoptions' のフラグ 'M' と 'B' は、マルチバイト文字の前後に空白を挿入する
ときの動作を変更する |fo-table|。

|'[| マークは連結前の最初の行の末尾に設定される。|']| マークは連結後の行の末尾
に設定される。


==============================================================================
2. 削除と挿入					*delete-insert* *replacing*

							*R*
R			置換モードに入る。打ち込んだ文字がカーソル下の既存の文
			字をどんどん置き換えていく。入力されたテキストを
			[count]-1 回繰り返す。詳細は |Replace-mode| を参照。

							*gR*
gR			仮想置換モードに入る。打ち込んだ文字が画面上の既存の文
			字をどんどん置き換えていく。そのため <Tab> は数文字を
			一回で置き換えることができる。入力されたテキストを
			[count]-1 回繰り返す。詳細は |Virtual-Replace-mode| を
			参照。

							*c*
["x]c{motion}		{motion} のテキストを [レジスタ x に入れ] 削除し、挿入
			を始める。'cpoptions' がフラグ 'E' を含むときは、削除
			すべきテキストがないと (例えば、"cTx" でカーソルが 'x'
			の直後にあるとき)、エラーが発生し挿入モードは始まらな
			い (これはVi互換である)。
			'cpoptions' がフラグ 'E' を含まないときは、コマンド
			"c" は削除すべきテキストがなくても、必ず挿入モードを始
			める。

							*cc*
["x]cc			[count] 行を [レジスタ x に入れ] 削除し、挿入を始める
			(行単位|linewise|)。'autoindent' がオンのとき、最初の
			行のインデントを保持する。

							*C*
["x]C			カーソル位置から行の終わりまでと、[count]-1 行を [レジ
			スタ x に入れ] 削除し、挿入を始める。"c$" と同義である
			(行単位でない|linewise|)。

							*s*
["x]s			[count] 文字を [レジスタ x に入れ] 削除し、挿入を始め
			る (s は Substitute --置換 を意味する)。"cl" と同義で
			ある (行単位でない|linewise|)。

							*S*
["x]S			[count] 行を [レジスタ x に入れ] 削除し、挿入を始める。
			"cc" と同義である (行単位|linewise|)。

{Visual}["x]c	または					*v_c* *v_s*
{Visual}["x]s		ビジュアル選択されたテキストを [レジスタ x に入れ] 削
			除し、挿入を始める ({Visual} については |Visual-mode|
			を参照)。

							*v_r*
{Visual}r{char}	        ビジュアル選択されたテキストを全て {char} に置き換える。
			CTRL-C は文字通り挿入される。

							*v_C*
{Visual}["x]C		ビジュアル選択された行を [レジスタ x に入れ] 削除し、
			挿入を始める。矩形ビジュアルモードでは少し動作が違う
			|v_b_C|。
							*v_S*
{Visual}["x]S		ビジュアル選択された行を [レジスタ x に入れ] 削除し、
			挿入を始める ({Visual} については |Visual-mode| を参
			照)。
							*v_R*
{Visual}["x]R		現在のところ {Visual}["x]S と同じである。次のバージョ
			ンでは動作が変わるかもしれない。

Note:
- 挿入モード、置換モードは <Esc> で終了できる。
- これらのモードでの他の特殊文字については、「テキストの挿入と置換」の章
  |mode-ins-repl| を参照。
- [count] の効果は、Vimが挿入モードや置換モードを抜けた後で発生する。
- 'cpoptions' がフラグ '$' を含んでいて、変更が1行以内である場合、Vimは削除さ
  れるテキストを表示しつづけ、最後に削除された文字の位置に '$' を置く。

レジスタに関する説明は |registers| を参照。

置換モードは挿入モードと似ているが、文字を打ち込むたびに一文字ずつ削除される点
が違う。行の最後に達すると、Vimはそれ以降は (挿入モードと同様に) 文字を追加す
る。置換モードでは、バックスペースキーは (もしあれば) 以前のテキストを復元する
(「テキストの挿入と置換」の章 |mode-ins-repl| を参照すること)。

						*cw* *cW*
特別な場合: "cw" と "cW" は、カーソルが単語の上にあるとき、単語のあとにつづく
空白を含めず、単語の末尾までを変更する("ce" と "cE" と同じ働きをする)。これは
Vimが "cw" を単語の変更(change-word)として解釈し、また「単語」にはあとに続く空
白は含まれないからである。 {Vi: あとに空白が続く空白上での "cw" は、最初の空白
のみを変更する。これは多分バグである。"dw" は全ての空白を削除するからだ。とに
かく、Vi風に動作させるときには 'cpoptions' にフラグ 'w' を含めること}

"cw" の変更範囲に単語の後の空白も含めたいときは、次のマップを使うこと。 >
	:map cw dwi
あるいは "caw" を使用する (|aw| および |cpo-z| も参照)。

							*:c* *:ch* *:change*
:{range}c[hange][!]	テキストを行単位で別のテキストと置き換える。
			"." のみを含む行を打ち込むことで置換を終了する。
			{range} なしの場合、現在行のみを変更する。
                        [!]をつけると、このコマンドを実行するときだけ
                        'autoindent' をトグルする。
			このコマンドは変数名ととても混同しやすいため、|Vim9|
			script ではサポートされない。

==============================================================================
3. 単純な変更						*simple-change*

							*r*
r{char}			カーソル下の文字を {char} に置き換える。
			{char} が <CR> か <NL> のとき、文字は改行に置き換わる。
			文字を本当の <CR> に置き換えるには、CTRL-V <CR> を使う。
			CTRL-V <NL> は文字を <Nul> に置き換える。

			{char} が CTRL-E または CTRL-Y のとき、ちょうど
			|i_CTRL-E| と |i_CTRL-Y| と同じように、下の行または上
			の行の文字が使われる。回数も指定することができるため、
			`10r<C-E>` は下の行から 10 文字をコピーすることになる。

			[count] を指定すると、[count] 文字が [count] 個の
			{char} に置き換わる。しかし {char} が <CR> か <NL> の
			場合、挿入される <CR> はただ1個である。"5r<CR>" は5文
			字を1個の改行に置き換える。
			{char} が <CR> か <NL> のとき、Vimは自動インデントを行
			う。これは置き換えるべき文字を削除した後 "i<CR><Esc>"
			を実行したような動作になる。
			{char} はダイグラフでもよい |digraph-arg|。
			|:lmap| のマッピングは {char} に適用される。挿入モード
			では、コマンド CTRL-^ を使ってマッピングを切り替えられ
			る |i_CTRL-^|。オプション 'encoding' がUnicodeの一種の
			ときに composing character を使うことについては
			|utf-8-char-arg| を参照。

							*gr*
gr{char}		カーソル下の仮想文字を {char} に置き換える。このコマン
			ドはファイル上の文字単位ではなく、画面上の文字幅単位で
			置き換える。詳細は |gR| と |Virtual-Replace-mode| を参
			照。|r| と同様、回数を指定できる。
			{char} の入力方法は |r| と同様である。しかし、ほとんど
			の CTRL-キー などの挿入モードにおいて特別な意味を持つ
			文字は使用できない。

							*digraph-arg*
|r| や |t| 等のノーマルモードコマンドの引数は、1個の文字である。オプション
'cpoptions' がフラグ 'D' を含まないとき、この文字はダイグラフ |digraphs| と同
様に入力できる。まず CTRL-K を打ち込み、次にダイグラフの2文字を入力する。
{Vimが |+digraphs| 機能付きでコンパイルされたときのみ有効}

							*case*
以下のコマンドは、アルファベットの大文字／小文字を切り替える。現在有効なロケー
ル |locale| が使われる。|:language| を参照。環境変数 LC_CTYPE の値に影響される。

							*~*
~			オプション 'tildeop' がオフのとき: カーソル下の文字の
			大文字／小文字を切り替え、カーソルを右に移動させる。
			[count] が指定されたときは、[count] 文字に作用する。

~{motion}		オプション 'tildeop' がオンのとき: {motion} のテキスト
			の大文字／小文字を切り替える。

							*g~*
g~{motion}		{motion} のテキストの大文字／小文字を切り替える。

g~g~							*g~g~* *g~~*
g~~			現在行の大文字／小文字を切り替える。

							*v_~*
{Visual}~		ビジュアル選択されたテキストの大文字／小文字を切り替え
			る({Visual} については |Visual-mode| を参照)。

							*v_U*
{Visual}U		ビジュアル選択されたテキストを大文字にする ({Visual}
			については |Visual-mode| を参照)。

							*gU* *uppercase*
gU{motion}		{motion} のテキストを大文字にする。
			例: >
				:map! <C-F> <Esc>gUiw`]a
<			これは挿入モードで機能する。カーソルの前の単語を大文字
			にするときに CTRL-F を打ち込めばよい。単語は小文字で入
			力し、後から大文字にする方が楽だ。


gUgU							*gUgU* *gUU*
gUU			現在行を大文字にする。

							*v_u*
{Visual}u		ビジュアル選択されたテキストを小文字にする ({Visual}
			については |Visual-mode| を参照)。

							*gu* *lowercase*
gu{motion}		{motion} のテキストを小文字にする。

gugu							*gugu* *guu*
guu			現在行を小文字にする。

							*g?* *rot13*
g?{motion}		{motion} のテキストをRot13エンコードする。

							*v_g?*
{Visual}g?		ビジュアル選択されたテキストをRot13エンコードする
			({Visual}については |Visual-mode| を参照)。

g?g?							*g?g?* *g??*
g??			現在行をRot13エンコードする。

各単語の最初の文字を大文字にする: >
	:s/\v<(.)(\w*)/\u\1\L\2/g

加算と減算 ~
							*CTRL-A*
CTRL-A			カーソルの下または後の数字またはアルファベットに
			[count] を加える。

							*v_CTRL-A*
{Visual}CTRL-A		ビジュアル選択されたテキスト中の数字またはアルファベッ
			トに [count] を加える。

							*v_g_CTRL-A*
{Visual}g CTRL-A	ビジュアル選択されたテキスト中の数字またはアルファベッ
			トに [count] を加える。複数行がビジュアル選択されてい
			る場合、各行は付加された [count] ごとに増やされる (そ
			のため効果的に [count] ごとに増加する配列を作ることが
			できる)。
			例えば、このような数字のリストがあるとする:
				1. ~
				1. ~
				1. ~
				1. ~
			2番目の "1." に移動し3行をビジュアル選択してから
			g CTRL-A を押すと、このようになる:
				1. ~
				2. ~
				3. ~
				4. ~

							*CTRL-X*
CTRL-X			カーソルの下または後の数字またはアルファベットから
			[count] を減じる。

							*v_CTRL-X*
{Visual}CTRL-X		ビジュアル選択されたテキスト中の数字またはアルファベッ
			トから [count] を減じる。

			MS-Windows では、ビジュアルモードでのテキストの切り取
			りにマップされる |dos-standard-mappings|。このマッピン
			グを無効にしたいなら、次のようにする: >
				silent! vunmap <C-X>
<
							*v_g_CTRL-X*
{Visual}g CTRL-X	ビジュアル選択されたテキスト中の数字またはアルファベッ
			トから [count] を減じる。複数行がビジュアル選択されて
			いる場合、各値は付加された [count] ごとに減らされる
			(そのため効果的に [count] ごとに減少する配列を作ること
			ができる)。

CTRL-A と CTRL-X が適用できるのは:
- 符号付き及び符号なし10進数
- 符号なし2進数、8進数および16進数
- アルファベット文字

これは 'nrformats' オプションに依存している:
- 'nrformats' に "bin" が含まれる時、Vim は '0b' または '0B' で始まる数値を2進
  数として扱う。
- 'nrformats' が "octal" を含むときは、Vimは '0' で始まり、'8' や '9' を含まな
  い数字を8進数として取り扱う。他の数は10進数とみなされ、マイナス符号が付いて
  もよい。カーソルが数の上にあれば、コマンドはその数に適用される。そうでなけれ
  ば、カーソルの右の数に適用される。
- 'nrformats' が "hex" を含むときは、Vimは '0x' か '0X' で始まる数を16進数とし
  て取り扱う。その数の最も右の文字が大文字であるか小文字であるかによって、変更
  結果の16進数が大文字か小文字かが決定する。対象となった数にアルファベットが含
  まれない場合、Vimは前回の決定を使う。
- 'nrformats' が "alpha" を含むときは、Vimはカーソル下または後のアルファベット
  を変更する。これはアルファベットのインデックスつきのリストを作るときに便利で
  ある。

10進数では先頭の負の符号は増加/減少に対して考慮される。しかし2進数、8進数およ
び16進数では考慮されない。符号を無視するには CTRL-A または CTRL-X を使う前に数
字をビジュアル選択する。

ゼロから始まる数 (全ての8進数、16進数を含む) に対して、Vimはできる限りその数の
文字数を保とうとする。"0077" 上で CTRL-A を使うと "0100" となり、"0x100" 上で
CTRL-X を使うと "0x0ff" となる。
1つだけ例外がある: ゼロで始まるが8進数でないとき('8' や '9' を含んでいるとき)、
'nrformats' が "octal" を含んでいるならば、結果が8進数とみなされないように、前
方のゼロは削除される。

Note 'nrformats' が "octal" を含んでいるとき、0で始まる10進数は、8進数と区別
しづらいため、意図しない結果になる可能性があることに注意。

Note 同様に、'nrformats' に "bin" と "hex" の両方が含まれている場合、先頭が
'0x' または '0X' の2進数は、'0b' が有効な16進数であるため、2進数ではなく16進数
として解釈されることがあることに注意。"0x0b11" 上で CTRL-A を使うと、"0x0b100"
ではなく、"0x0b12" となる。
'nrformats' が "bin" を含み、"hex" を含まない場合、"0x0b11" の "0b11" 上で
CTRL-A を使うと "0x0b100" となる。

カーソル下の数値が大きすぎて 32 ビットまたは 64 ビット (Vim のビルド方法による)
に収まらない場合、表現可能な最も近い数値に丸められ、加算/減算はスキップされる。
例えば、64 ビット対応で 18446744073709551616 に CTRL-X を使用すると
18446744073709551615 になる。18446744073709551618 のような大きな数字の場合も同
様である。

コマンド CTRL-A はマクロ内でたいへん便利である。例: 番号付きリストを作るには、
次の方法を使う。

1. リストの最初の項目を作る。番号から始まるようにすること。
2. qa	     - レジスタ 'a' への記録を始める
3. Y	     - 項目をコピーする
4. p	     - 項目のコピーを最初の項目の後に貼り付ける
5. CTRL-A    - 番号を増やす
6. q	     - 記録をストップする
7. <count>@a - コピー、貼り付け、番号増加を <count> 回繰り返す


行を左右にずらす					*shift-left-right*

							*<*
<{motion}		{motion} の行を 'shiftwidth' 1個分左にずらす。

			'vartabstop' 機能が有効になっていて、'shiftwidth' オプ
			ションが 0 に設定されている場合、インデントの量は行の
			最初の非空白文字で計算される。
							*<<*
<<			[count] 行を 'shiftwidth' 1個分左にずらす。

							*v_<*
{Visual}[count]<	ビジュアル選択された行を、'shiftwidth' の [count] 個分
			左にずらす ({Visual} については |Visual-mode| を参照)。

							*>*
 >{motion}		{motion} の行を 'shiftwidth' 1個分右にずらす。

			'vartabstop' 機能が有効になっていて、'shiftwidth' オプ
			ションが 0 に設定されている場合、インデントの量は行の
			最初の非空白文字で計算される。
							*>>*
 >>			[count] 行を 'shiftwidth' 1個分右にずらす。

							*v_>*
{Visual}[count]>	ビジュアル選択された行を、'shiftwidth' の [count] 個分
			右にずらす ({Visual} については |Visual-mode| を参照)。

							*:<*
:[range]<		[range] の行を、'shiftwidth' 1個分左にずらす。
			'shiftwidth' の複数個分ずらすには、'<' を繰り返す。

:[range]< {count}	[range] (既定は現在行 |cmdline-ranges|) から始まる
			{count} 行を 'shiftwidth' 1個分左にずらす。
			'shiftwidth' の複数個分ずらすには、'<' を繰り返す。

:[range]le[ft] [indent]	[range] の行を左揃えする。行のインデントは [indent]
			(既定値は 0) に設定される。

							*:>*
:[range]> [flags]	[range] の行を、'shiftwidth' 1個分右にずらす。
			'shiftwidth' の複数個分ずらすには、'>' を繰り返す。
                        [flags]については|ex-flags|を参照。

:[range]> {count} [flags]
                        [range] (既定は現在の行 |cmdline-ranges|) から始まる
			{count} 行を、'shiftwidth' 1個分右にずらす。
			'shiftwidth' の複数個分ずらすには、'>' を繰り返す。
                        [flags]については|ex-flags|を参照。

コマンド ">" と "<" は、プログラムに含まれるインデントを変更するのに便利であ
る。オプション 'shiftwidth' には、これらのコマンドが挿入、削除する空白の幅を設
定する。'shiftwidth' は既定では 8 だが、例えば 3 に設定して、インデントをもっ
と少なくすることもできる。左方向へのシフトは、インデントがなくなったときに終了
する。右方向へのシフトは、空行には適用されない。

'shiftround' がオンのとき、インデントは 'shiftwidth' の倍数に丸められる。

'smartindent' がオンのとき、あるいは 'cindent' がオンで 'cinkeys' が値 0 の
'#' を含むとき、右方向へのシフトは '#' で始まる行に適用されない (これらの行は、
行の最初に位置すべきCプリプロセッサー指令であると考えられる)。これは 'cino' オ
プションで変更することができる、|cino-#| を参照。

'expandtab' がオフ (既定値) のとき、Vimはインデントにできる限り多くの <Tab> を
使う。">><<" によって、空白のみで構成されたインデントを、<Tab> (と必要ならばい
くつかの空白) で構成されたインデントに置換できる。'expandtab' がオンのときは、
Vimは空白のみを使う。">><<" によって、インデント内の <Tab> を空白に置換できる
(あるいは `:retab!` を使う)。

行を 'shiftwidth' の複数個分ずらすには、ビジュアルモードかコマンド `:` を使う。
例: >
	Vjj4>		3行をインデント4個分右に移動
	:<<<		現在の行をインデント3個分左に移動
	:>> 5		5行をインデント2個分右へ移動
	:5>>		5行目をインデント2個分右に移動

==============================================================================
4. 複雑な変更						*complex-change*

4.1 フィルタコマンド					*filter*

フィルタとは、テキストを標準入力から受け取り、何らかの変更を加え、標準出力に送
るプログラムのことである。以下のコマンドにより、テキストの一部をフィルタにかけ
ることができる。フィルタの例としては、行をアルファベット順にソートする "sort"、
Cのプログラムを整形する "indent" (ただし、フィルタ機能を持ったバージョンが必
要。全てのバージョンでできるわけではない) などがある。オプション 'shell' は、
Vimがフィルタコマンドを実行するときに使うシェルを指定する ('shelltype' も参
照)。フィルタコマンドはコマンド "." で繰り返せる。Vimは `:!` の後の ('"' で始
まる) コメントを認識しない。

							*!*
!{motion}{filter}	{motion} のテキストを外部プログラム {filter} でフィル
			タ処理する。

							*!!*
!!{filter}		[count] 行を外部プログラム {filter} でフィルタ処理する。

							*v_!*
{Visual}!{filter}	ビジュアル選択された行を外部プログラム {filter} でフィ
			ルタ処理する。({Visual} については |Visual-mode| を参
			照)。

:{range}![!]{filter} [!][arg]				*:range!*
			外部コマンドの実行については、|:!| を参照

			{range} 行を外部プログラム {filter} でフィルタ処理する。
			{filter} の後ろには '!' を付けてもよい。これは最後に実
			行されたコマンドに置き換えられる。さらに [arg] を付け
			ると、それがコマンドに付け加えられる。Vimはフィルタコ
			マンドの出力を一時ファイルに保存し、そのファイルをバッ
			ファに読み込む |tempfile|。フィルタの出力を一時ファイ
			ルにリダイレクトするときはオプション 'shellredir' が使
			われる。Unixでは 'shellredir' がオフのとき、可能ならば
			パイプが使われる。
			'cpoptions' に 'R' フラグが含まれるとき、フィルタ処理
			された行のマークは削除される。|:keepmarks| コマンドを
			使うと削除されない。例: >
				:keepmarks '<,'>!sort
<			フィルタ処理のあと行数が少なくなっていた場合、すでにな
			い行を指しているマークは削除される。

							*=*
={motion}		{motion} の行を、オプション 'equalprg' で指定された外
			部プログラムでフィルタ処理する。'equalprg' が空のとき
			(これが既定) は、組み込みの整形機能の |C-indenting| と
			'lisp' を使う。しかし 'indentexpr' が空でないときは、
			それが使われる |indent-expression|。Vim が内部フォー
			マット機能なしでコンパイルされているときは、最後の手段
			として "indent" プログラムが使われる。

							*==*
==			[count] 行を ={motion} と同様にフィルタ処理する。

							*v_=*
{Visual}=		ビジュアル選択されたテキストを ={motion} と同様にフィ
			ルタ処理する。


						*tempfile* *setuid*
フィルタリング、diff の生成、tempname() などを行うときには、一時ファイルが作成
される。Unix ではこのファイルはプライベートな (自分だけがアクセスできる) ディ
レクトリに置かれる。セキュリティ上の問題 (symlink attack や他の人があなたのファ
イルを読むなど) を避けるためである。Vim が終了するとき、そのディレクトリと中に
あるファイルは自動的に削除される (Unix のみ。他のシステムでは自分で片づける必
要がある)。Vim に setuid ビットが立っているとこれが問題を引き起こすことがある。
一時ファイルは setuid されたユーザーが所有するのに対し、フィルタコマンドは元の
ユーザーとして動作するためである。
一時ファイルのディレクトリはこれらから機能する最初のディレクトリに作成される:
	Unix:    $TMPDIR, /tmp, current-dir, $HOME.
	Windows: $TMP, $TEMP, c:\TMP, c:\TEMP
MS-Windows ではシステム関数 GetTempFileName() が使われる。
他のシステムではライブラリ関数 tmpnam() が使われる。



4.2 置換						*:substitute*
							*:s* *:su*
:[range]s[ubstitute]/{pattern}/{string}/[flags] [count]
			[range] の各行で {pattern} のマッチを {string} に置き
			換える。
			{pattern}については|pattern|を参照すること。
			{string} は普通の文字列でもよいし、特別な指定方法を使っ
			てもよい。|sub-replace-special| を参照。
			[range] と [count] が指定されないと、現在行内でのみ置
			換を行う。[count] が指定されると、[range] の最終行から
			数えて [count] 行で置換を行う。[range] が指定されない
			と、現在行から開始する。
							*E939* *E1510*
			[count] は正の数でなければならない (最大 2147483647)。
			|cmdline-ranges| も参照。

			[flag] については |:s_flags| を参照。
			デリミタは / である必要はない。|pattern-delimiter| を
			参照。

:[range]s[ubstitute] [flags] [count]
:[range]&[&][flags] [count]					*:&*
			最後の置換を同じパターンかつ同じ置換文字列で、フラグを
			つけずに繰り返す。フラグを追加することもできる
			(|:s_flags|を参照)。
			Note `:substitute` の後では '&' および '#' フラグは使
			用できず、パターン区切りとして認識されることに注意。
			`:substitute` とフラグ 'c', 'g', 'i', 'I', 'r' の間の
			空白は必要不可欠ではない。しかしスクリプト内では、混乱
			しないように空白を入れておくのはよい考えである。
			`:substitute` を繰り返す2もしくは3文字のコマンド群も参
			照のこと。|:substitute-repeat| で説明されている。

:[range]~[&][flags] [count]					*:~*
			最後の置換を同じ置換文字列で、最後の検索パターン {訳注:
			"/" で使ったもの} に対して繰り返す。`:&r` に似ている。
			フラグについては |:s_flags| を参照。

								*&*
&			`:s` と同義 (最後の置換を繰り返す)。 Note 同じフラグが
			使われるわけではないので注意。実際の動作は違うかもしれ
			ない。フラグも同じにするには `:&&` を使うこと。

								*g&*
g&			`:%s//~/&` と同義 (全ての行に対し、最後の検索パターン
			で、同じフラグで最後の置換を繰り返す)。
			例えば、`:s/pattern/repl/flags` と置換を実行し、次に
			`/search` と検索を実行すると、`g&` は
			`:%s/search/repl/flags` を実行する。
			覚え方: 「グローバル (global --全体的な) 置換」

						*:snomagic* *:sno*
:[range]sno[magic] ...	`:substitute` と同じだが、常に 'nomagic' を使う。

						*:smagic* *:sm*
:[range]sm[agic] ...	`:substitute` と同じだが、常に 'magic' を使う。

							*:s_flags*
置換コマンドで使えるフラグ:

							*:&&*
[&]	先頭に指定しなければならない。前回の置換コマンドと同じフラグを使う。
	例: >
		:&&
		:s/this/that/&
<	Note コマンド `:s` と `:&` では、前回と同じフラグは使われない。

[c]	置換前に毎回確認する。マッチしている文字列を (ハイライトグループ
	|hl-IncSearch| で) 強調表示する。確認を求められたら、ユーザーは以下の
	ように応答する。					*:s_c*
	    'y'	    そのマッチを置換する ("yes")
	    'l'	    そのマッチを置換し、置換を終了する ("last")
	    'n'	    そのマッチを置換せず、次に移る ("no")
	    <Esc>   置換を終了する
	    'a'	    そのマッチと、以降の全てのマッチを置換する
	    'q'	    置換を終了する
	    CTRL-E  画面を上にスクロールする
	    CTRL-Y  画面を下にスクロールする
	オプション 'edcompatible' がオンのとき、Vimはフラグ [c] を記憶し、それ
	が指定される度にオン／オフを切り替えるが、新しい検索パターンが使われる
	とリセットする。

							*:s_e*
[e]	検索パターンが何もマッチしなかったとき、エラーメッセージを表示しない。
	特にマッピング内ではエラーが発生しなかったかのように続行される。これは
	「パターンは見つかりませんでした」のエラーによるマッピングの中断を防ぐ
	のに使える。しかし以下のエラーの発生は抑制されない。
		「正規表現は文字で区切ることができません」
		「\ の後は / か ? か & でなければなりません」
		「正規表現置換がまだ実行されていません」
		「余分な文字が後ろにあります」
		「(割込まれました)」

							*:s_g*
[g]	行中の全てのマッチを置換する。このフラグなしだと、各行の1個目のマッチ
	のみが置換される。オプション 'edcompatible' がオンのとき、Vimはこのフ
	ラグを記憶し、指定される度にオン／オフを切り替えるが、新しい検索パター
	ンが使われるとリセットする。'gdefault' がオンのときは、このフラグはオ
	ンが既定値になり、フラグ [g] を指定したときにはオフになる。

							*:s_i*
[i]	パターンの大文字／小文字の区別をしない。オプション 'ignorecase' と
	'smartcase' は使われない。

							*:s_I*
[I]	パターンの大文字／小文字を区別する。オプション 'ignorecase' と
	'smartcase' は使われない。

							*:s_n*
[n]	マッチの個数を表示し、実際には置換を行わない。フラグ [c] は無視される。
	'report' が 0 のときと同じようにマッチが表示される。
	何個あるか調べるときに便利。|count-items|
	\= |sub-replace-expression| が使われたときは、式はそれぞれのマッチに対
	してサンドボックス (|sandbox|) で実行される。

[p]	最後に置換を行った行を表示する。 *:s_p*

[#]	[p] と同様。行番号をつける。 *:s_#*

[l]	[p] と同様だが、|:list| のように表示する。 *:s_l*

							*:s_r*
[r]	引数のない `:&` か `:s` との連携でのみ有効。`:&r` は `:~` と同様に動作
	する。検索パターンが空のとき、最後の置換コマンドや `:global` でのパター
	ンではなく、最後の検索パターンを使用する。最後に検索パターンを使用した
	コマンドが置換や `:global` だったときは、何もしない。最後のコマンドが
	"/" のような検索コマンドだったときは、そのコマンドの検索パターンを使う。
	引数付きの `:s` では、すでにそう動作するようになっていた。 >
		:s/blue/red/
		/green
		:s//red/  または  :~  または  :&r
<	最後のコマンドは "green" を "red" に置き換える。 >
		:s/blue/red/
		/green
		:&
<	最後のコマンドは "blue" を "red" に置き換える。

NOTE パターンに 'magic' が適用されるかどうかを変更するフラグはないことに注意。
代わりに違うコマンド {訳注: |:snomagic|} または |/\v| などを使う。これは、パター
ン解釈を飛ばすことでのみフラグを認識できるが、その一方でパターン解釈を飛ばす
には 'magic' の適用状態が知られている必要があるためである。 Catch 22! {訳注:
どうにもならないという意味}

置換コマンドで {pattern} が空のときは、最後に使われた置換コマンドまたはコマン
ド `:global` のパターンが使われる。それが無い場合は、直前の検索パターンがあれ
ばそれが使われる。フラグ [r] を指定すると、最後の置換、`:global`、または検索コ
マンドのパターンが使われる。

{string}を省略した場合は、空文字列を指定したのと同じ結果になる。すなわち、マッ
チしたパターンが削除される。{pattern}の後のセパレータも省略することができる。
例: >
	:%s/TESTING
これは、全行から "TESTING" を削除する例である。ただし、1つの行に2個以上あって
も1個しか削除されない。
								*E1270*
旧来のスクリプトでは、Viとの互換性のため、これら2つの例外が許される:
"\/{string}/" と "\?{string}?" は "//{string}/r" と同様の効果。
"\&{string}&" は "//{string}/" と同様の効果。
				*pattern-delimiter* *E146* *E1241* *E1242*
'/' でパターンと置換文字列を囲む代わりに、他の1バイト文字を使うことができる。
これは検索パターンや置換文字列に '/' を含む場合に有益である。例 >
	:s+/+//+

英数字でないものや、 '\', '"', '|' 以外の多くの文字が使える。Vim9 script では
'#' はコメントの開始を識別するものなので使用しないこと。

パターンの定義については |pattern| を参照。矩形ビジュアルモードで、置換をその
領域内だけで行いたい場合は、パターンに |/\%V| を含める。これを使わない場合は、
置換は常に行全体に対して行われる。

					*sub-replace-special* *:s\=*
{string} が "\=" で始まるときは、それは式として評価される。
|sub-replace-expression| を参照のこと。複雑な置換や特殊な文字を使うことができ
る。

置換は再帰内で4段階までに制限されている。 *E1290*

そうでなければ、{string} の中のこれらの文字は特別な意味を持つ:
								*:s%*
'cpoptions' に '/' が含まれている場合、{string} が "%" に等しいならば前の置換
コマンドの {string} が使われる。|cpo-/| 参照

 magic	nomagic	  作用    ~
  &	  \&	  マッチしたパターン全体に置き換わる		     *s/\&*
 \&	   &	  '&' に置き換わる
      \0	  マッチしたパターン全体に置き換わる		   *\0* *s/\0*
      \1	  1番目の () 内のマッチしたパターンに置き換わる      *s/\1*
      \2	  2番目の () 内のマッチしたパターンに置き換わる      *s/\2*
      ..	  ..						     *s/\3*
      \9	  9番目の () 内のマッチしたパターンに置き換わる      *s/\9*
  ~	  \~	  前回の置換の {string} に置き換わる		     *s~*
 \~	   ~	  '~' に置き換わる				     *s/\~*
      \u	  次の文字が大文字になる			     *s/\u*
      \U	  後に続く文字が (\E まで) 大文字になる		     *s/\U*
      \l	  次の文字が小文字になる			     *s/\l*
      \L	  後に続く文字が (\E まで) 小文字になる		     *s/\L*
      \e	  \u, \U, \l, \L の終わり ( NOTE: <Esc> の意味ではない！)
								     *s/\e*
      \E	  \u, \U, \l, \L の終わり			     *s/\E*
      <CR>	  ここで行を2つに分ける (<CR> は CTRL-V <Enter> と入力する)
								     *s<CR>*
      \r	  同上						     *s/\r*
      \<CR>	  キャリッジリターン (CTRL-M) の挿入 (<CR> は CTRL-V <Enter>
		  と入力する)					     *s/\<CR>*
      \n	  <NL> (ファイル内では <NUL>) の挿入 (改行を「起こさない」)
								     *s/\n*
      \b	  <BS> の挿入					     *s/\b*
      \t	  <Tab> の挿入					     *s/\t*
      \\	  '\' の挿入					     *s/\\*
      \x	  ('x' は上で説明されていない文字) 将来の拡張用に予約済み

特別な意味は |substitute()| の 第三引数 {sub} でも使えるがいくつか例外がある:
  - % は 'cpoptions' に関係なくパーセント文字を挿入する。
  - 'magic' に関係なく magic は常にオンである。
  - ~ はチルダをそのまま挿入する。
  - <CR> と \r はキャリッジリターン (CTRL-M) を挿入する。
  - \<CR> は特別な意味を持たない。単に \x の一種として扱われる。

例: >
  :s/a\|b/xxx\0xxx/g		 "a b"      を "xxxaxxx xxxbxxx" に置換
  :s/\([abc]\)\([efg]\)/\2\1/g	 "af fa bg" を "fa fa gb"        に置換
  :s/abcde/abc^Mde/		 "abcde"    を "abc", "de" (2行) に置換
  :s/$/^V^M/			 "abcde"    を "abcde^M"         に置換
  :s/\w\+/\u\0/g		 "bla bla"  を "Bla Bla"         に置換
  :s/\w\+/\L\u\0/g		 "BLA bla"  を "Bla Bla"         に置換

Note: "\L\u" を使うと単語の最初の文字をキャピタライズできる。これは Vi や古い
Vim とは互換性がない。それらの古い環境では "\u" は "\L" をキャンセルする。
"\U\l" も同様。

NOTE: 以前のバージョンでは CTRL-V が特別に扱われていた。これはVi互換ではないの
で変更された。代わりに '\' を使うこと。

コマンド      テキスト	置換結果 ~
:s/aa/a^Ma/	aa	a<line-break>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<line-break>a

(ここで ^M を使うには CTRL-V <CR> と打ち込むこと)

"\1", "\2" などの番号付けは、パターン内でどの "\(" が最初に来るかによって決ま
る (左から右の順)。括弧でくくられたグループが複数回マッチするときは、最後のも
のが "\1", "\2" 等に使われる。例: >
	:s/\(\(a[a-d] \)*\)/\2/      "aa ab x" を "ab x" に置換
"\2" は、"\(a[a-d] \)" を参照する。このパターンはまず "aa " にマッチし、次に
"ab " にマッチする。

\([ab]\)\|\([cd]\) のように括弧を '|' と連携して使っているとき、1番目か2番目の
どちらかの括弧内のパターンにはマッチしない、すなわち、\1 か \2 のどちらかは空
になる。例: >
	:s/\([ab]\)\|\([cd]\)/\1x/g   "a b c d" を "ax bx x x" に置換
<

		*:sc* *:sce* *:scg* *:sci* *:scI* *:scl* *:scp* *:sg* *:sgc*
		*:sge* *:sgi* *:sgI* *:sgl* *:sgn* *:sgp* *:sgr* *:sI* *:si*
		*:sic* *:sIc* *:sie* *:sIe* *:sIg* *:sIl* *:sin* *:sIn* *:sIp*
		*:sip* *:sIr* *:sir* *:sr* *:src* *:srg* *:sri* *:srI* *:srl*
		*:srn* *:srp* *:substitute-repeat*
2文字もしくは3文字の :substitute コマンド ~

これらのコマンドは前回の `:substitute` コマンドを与えられたフラグを使って繰り
返す。最初の文字は常に "s" であり、1個か2個のフラグ文字が続く。例えば `:sce`
は `:s///ce` のように動作する。この表は可能な組み合わせの一覧である。別のコマ
ンドの短縮形となるものは使用できない。

     :substitute コマンド一覧
     |      c    e    g    i    I    n    p    l    r
     | c  :sc  :sce :scg :sci :scI :scn :scp :scl
     | e
     | g  :sgc :sge :sg  :sgi :sgI :sgn :sgp :sgl :sgr
     | i  :sic :sie      :si  :siI :sin :sip      :sir
     | I  :sIc :sIe :sIg :sIi :sI  :sIn :sIp :sIl :sIr
     | n
     | p
     | l
     | r  :src      :srg :sri :srI :srn :srp :srl :sr

例外:
     :scr  は  `:scriptnames`
     :se   は  `:set`
     :sig  は  `:sign`
     :sil  は  `:silent`
     :sn   は  `:snext`
     :sp   は  `:split`
     :sl   は  `:sleep`
     :sre  は  `:srewind`


式で置換する					*sub-replace-expression*
						*sub-replace-\=* *s/\=*

置換文字列が "\=" で始まるとき、それ以降の文字列は式として解釈される。これは再
帰的に機能しない。

"<CR>" 以外の文字の特別な意味 |sub-replace-special| は無効になる。<NL> 文字は
改行として使われるのでダブルクォート文字列 "\n" で改行を入れることができる。
実際の <NL> 文字 (ファイルにおける NUL 文字) を挿入するにはバックスラッシュを
前置する。

"\=" 表記は |substitute()| 関数の第三引数 {sub} でも使うことができる。その場
合、|sub-replace-special| で説明されている文字は特別な意味を持たなくなる。特
に、<CR> と <NL> は改行として解釈されるのではなく、そのままキャリッジリターン
とニューラインとして解釈される。

結果が|List|のときはその要素が改行を区切りとして連結される。よって要素がそれぞ
れ行となる。ただし要素が改行を含んでいる場合は除く。

|submatch()| 関数を使用して一致するテキストを取得できる。マッチしたテキストの
全体は "submatch(0)" で参照できる。1番目の () 内でマッチしたテキストは
"submatch(1)" で参照できる。以降の () 内でマッチしたテキストも同様に参照でき
る。

注意: 正規表現の区切り文字が expression 内に現れてはいけない！区切りには "@"
や ":" を使うよう検討すること。Expression の結果に区切り文字が現れても問題はな
い。

例: >
	:s@\n@\="\r" .. expand("$HOME") .. "\r"@
こうすると置換を行った行の下に、環境変数 $HOME の値を含む新しい行が挿入される。
>
	s/E/\="\<Char-0x20ac>"/g
これは文字 'E' をユーロ記号で置換する。詳しくは |<Char->| を参照。


4.3 検索と置換					*search-replace*

						*:pro* *:promptfind*
:promptf[ind] [string]
			検索ダイアログを表示する。 [string] が与えられると、そ
			れが初期検索文字列になる。
			{VimのWin32版、Motif版、GTKのGUI版のみ}

						*:promptr* *:promptrepl*
:promptr[epl] [string]
			検索／置換ダイアログを表示する。 [string] が与えられる
			と、それが初期検索文字列になる。
			{VimのWin32版、Motif版、GTKのGUI版のみ}


4.4 タブの変換                                          *change-tabs*
							*:ret* *:retab* *:retab!*
:[range]ret[ab][!] [-indentonly] [{new-tabstop}]
			{new-tabstop} を使用し、<Tab> を含むすべての空白文字の
			連続を新しい空白文字の文字列に置き換える。
			{new-tabstop} を指定しないか 0 を指定した場合、Vim は
			現在の 'tabstop' の値を使用する。
			'tabstop' の現在の値は、既存のタブの幅を計算する際に常
			に使用される。
			! を付けると、Vim は通常の空白のみの文字列も適切な箇所
			でタブに置き換える。
			'expandtab' をオンにすると、Vim はすべてのタブを適切な
			数の空白に置き換える。
			このコマンドは 'tabstop' を {new-tabstop} に設定する。
			ファイル全体に対して実行した場合 (デフォルト)、目に見
			える変化はない。

			[-indentonly] が指定された場合、先頭の空白のみが対象と
			なる。それ以外の連続する空白は変更されない。

			Warning: このコマンドはCプログラム中の文字列内部にある
			<Tab> 文字も修正する。これを避けるためには、プログラム
			内では "\t" を使うとよい (そうでなくても、これはよい習
			慣である)。
			`:retab!` も空白の連続を <Tab> 文字に変えてしまい、
			printf() の出力をめちゃくちゃにするかもしれない。
			|+vartabs| 機能が有効な場合、 単一の tabstop の代わり
			にコンマで分けられたタブ幅のリストが使用されるだろう。
			リストのそれぞれの値は 1 つの tabstop の幅を意味する
			が、最後の値だけは後続するすべての tabstop に適用され
			る。

							*retab-example*
タブストップが 8 で保存され、タブストップが 4 で編集されたファイルを編集するた
めに autocommand と ":retab" を使う例。警告: 文字列内の空白は変わってしまうこ
とがある！オプション 'softtabstop' も参照。 >

	:auto BufReadPost	*.xx	retab! 4
	:auto BufWritePre	*.xx	retab! 8
	:auto BufWritePost	*.xx	retab! 4
	:auto BufNewFile	*.xx	set ts=4

==============================================================================
5. テキストのコピーと移動				*copy-move*

							*quote*
"{register}		続く操作 (削除、コピー、貼り付け) に {register} を使う。
			削除、コピーでは大文字を使うことでレジスタに追記できる。
			レジスタ "."、"%"、"#"、":" は貼り付けにのみ利用できる。

							*:reg* *:registers*
:reg[isters]		全ての名前付きレジスタおよび番号付きレジスタのタイプと
			内容を表示する。レジスタが |:redir| の書き込み先になっ
			ている場合はそのレジスタは表示されない。
			タイプは次のいずれか:
			"c"	|characterwise| のテキスト
			"l"	|linewise| のテキスト
			"b"	|blockwise-visual| のテキスト

:reg[isters] {arg}	{arg} に指定された名前付きレジスタおよび番号付きレジス
			タを表示する。例: >
				:reg 1a
<			レジスタ '1' と 'a' が表示される。{arg} の中では空白を
			用いてよい。

							*:di* *:dis* *:display*
:di[splay] [arg]	:registers と同じ。

							*y* *yank*
["x]y{motion}		{motion} のテキストを [レジスタ x に] コピーする。
			コピーされるテキストがないとき (例えば 1 桁目で "y0"
			を行う)、オプション 'cpoptions' がフラグ 'E' を含んで
			いるならエラーになる。

							*yy*
["x]yy			[count] 行を [レジスタ x に] コピーする (行単位
			|linewise|)。

							*Y*
["x]Y			[count] 行を [レジスタ x に] コピーする ("yy" と同義、
			行単位|linewise|)。"Y" でカーソル位置から行の終わりま
			でコピーしたいときは (この方が論理的と言えるが、Vi互換
			ではない) ":map Y y$" を使う。

							*zy*
["x]zy{motion}		{motion} のテキストを [レジスタ x に] コピーする。`y`
			との唯一の差はテキストの選択がブロックの時にある、
			|v_zy| を参照。

							*v_y*
{Visual}["x]y		ビジュアル選択されたテキストを [レジスタ x に] コピー
			する
			({Visual} については |Visual-mode| を参照)。

							*v_Y*
{Visual}["x]Y		ビジュアル選択された行を [レジスタ x に] コピーする
			({Visual} については |Visual-mode| を参照)。

							*v_zy*
{Visual}["x]zy		ビジュアル選択されたテキストを [レジスタ x に] コピー
			する。選択したブロックの各行の末尾の空白はコピーされな
			い。`zp` との組み合せが特に便利である。({Visual} につ
			いては |Visual-mode| を参照)。

							*:y* *:yank* *E850*
:[range]y[ank] [x]	[range] の行を [レジスタ x に] コピーする。"* レジスタ
			と "+ レジスタへのコピーは |+clipboard| 機能が有効な場
			合のみ可能。

:[range]y[ank] [x] {count}
			[range] の最後の行 (省略時は現在行 |cmdline-ranges|)
			から数えて {count} 行を [レジスタ x に] コピーする。

						*p* *put* *E353* *E1240*
["x]p			カーソルの後に、テキストを [count]回 [レジスタ x から]
			貼り付ける。

							*P*
["x]P			カーソルの前に、テキストを [count]回 [レジスタ x から]
			貼り付ける。

							*<MiddleMouse>*
["x]<MiddleMouse>	カーソルの前に、テキストを [count]回 [レジスタ x から]
			貼り付ける。レジスタ指定がない場合は "* が使われる。
			カーソルは挿入したテキストの末尾に置かれる。
			マウスは 'mouse' が 'n' か 'a' を含むときのみ使える。
			もしあなたがスクロールホイールを持っていて意図せずにテ
			キストを貼り付けてしまうのなら、次のマッピングでマウス
			の真ん中のボタンを無効化できる。 >
				:map <MiddleMouse> <Nop>
				:imap <MiddleMouse> <Nop>
<			複数クリックも無効にしたいなら |double-click| も参照のこ
			と。

							*gp*
["x]gp			"p" と似ているが、カーソルは挿入したテキストの直後に置
			かれる。

							*gP*
["x]gP			"P" と似ているが、カーソルは挿入したテキストの直後に置
			かれる。

							*:pu* *:put*
:[line]pu[t] [x]	[line] 行目 (省略時は現在行) の後にテキストを [レジス
			タ x から] コピーする。このコマンドは常に行単位
			|linewise| の動作をするので、コピーされたブロックを新
			しい行として挿入するときに使える。
			レジスタが指定されていないときのレジスタは 'cb' オプ
			ションに依存する。'cb' が "unnamedplus" を含むときは
			+ レジスタ |quoteplus| からペーストする。そうではなく、
			'cb' が "unnamed" を含むときは * レジスタ |quotestar|
			からペーストする。そうでなければ、無名レジスタ
			|quote_quote| からペーストする。
			レジスタには '=' に続けて式を指定することもできる。コ
			マンドの末尾までが式として評価される。文字 '|' と '"'
			がコマンドの末尾として解釈されないようにするには、それ
			らをエスケープする {訳注: 前に '\' を置く} 必要がある。
			例: >
				:put ='path' .. \",/test\"
<			'=' の後に式がないときは前回の式が使われる。それはコマ
			ンド ":dis =" で見ることができる。

:[line]pu[t]! [x]	[line] 行目 (省略時は現在行) の前にテキストを [レジス
			タ x から] コピーする。

							*:ip* *:iput*
:[line]ip[ut] [x]	|:put| と似ているが、現在行に合わせてインデントを調整
			する

:[line]ip[ut]! [x]	|:put|! と似ているが、現在行に合わせてインデントを調整
			する

["x]]p		    または				*]p* *]<MiddleMouse>*
["x]]<MiddleMouse>	"p" と似ているが、現在行に合わせてインデントが調整され
			る。マウスは、'mouse' が 'n' か 'a' を含むときだけ使え
			る。

["x][P		    または				*[P*
["x]]P		    または				*]P*
["x][p		    または				*[p* *[<MiddleMouse>*
["x][<MiddleMouse>	"P" と似ているが、現在行に合わせてインデントが調整され
			る。マウスは、'mouse' が 'n' か 'a' を含むときだけ使え
			る。

["x]zp		    または				*zp* *zP*
["x]zP			"p" と "P" に似ているが、ブロックのペースト時に末尾の
			空白は追加しない。そして挿入されるテキストは矩形にはな
			らない。|v_zy| との組み合せが特に便利である。

これらのコマンドを使って、ある場所から別の場所へテキストをコピーできる。まずコ
ピー、削除または変更コマンドを使って、テキストをレジスタに蓄える。そしてレジス
タの内容を、貼り付けコマンドで文章中に挿入する。これらのコマンドで、あるファイ
ルから別のファイルへテキストを移動させることもできる。Vim はバッファを切り替え
ても、全てのレジスタの内容を保っているからである (コマンド CTRL-^ は、2個のバッ
ファを素早く切り替えられる)。

				*linewise-register* *characterwise-register*
貼り付けコマンド (":put" 以外) は、"." で繰り返したり、アンドゥできる。テキス
トをレジスタに蓄えるのに使われたコマンドが行単位|linewise|のものだったら、テキ
ストはカーソルのある行の次の行 ("p" のとき) や前の行 ("P" のとき) に貼り付けら
れる。そうでなければ、テキストはカーソルの後 ("p" のとき) や前 ("P" のとき) に
挿入される。コマンド ":put" を使ったときは、テキストは常に次の行へ挿入される。
"xp" というコマンド列で、カーソル上の文字と次の文字との入れ替えができる。現在
行と次の行との入れ替えには、コマンド列 "ddp" を使う。(カーソルが単語の前の空白
の上にあるとき) 次の単語とその次の単語との入れ替えには、コマンド列 "deep" を使
う。貼り付けコマンドを使った後には、コマンド |']| か |`]| で挿入された行の終わ
りに移動でき、コマンド |'[| か |`[| で挿入された行の最初に移動できる。

						*put-Visual-mode* *v_p* *v_P*
ビジュアルモードで |p| や |P| 等の貼り付けコマンドを使ったとき、Vimは選択され
たテキストをレジスタの中身で置き換えようとする。これがうまく動作するかどうか
は、選択領域の種類とレジスタ内のテキストの種類による。矩形選択では、ブロックの
サイズと、選択領域の角が既存の文字上にあるかどうかにもよる。(実装上の詳細:実際
の動作は、まずレジスタの中身を選択領域の後に貼り付け、その後で選択領域を削除す
るようになっている)
|p| だとそれまで選択されていたテキストが無名レジスタに保存される(そして場合に
よっては選択テキストおよび/またはクリップボードも)。これは選択テキストを別の場
所にプットするのに便利である。しかし、同じ変更を繰り返せない。
|P| を使用すると、無名レジスタは変更されず(そして選択テキストもクリップボード
も)、同じ変更を繰り返すことができる。しかし削除されたテキストは使えない。それ
が必要な場合は、別のレジスタで |p| を使用することができる。例えば、コピーする
テキストをヤンクし、置き換えるテキストをビジュアル選択して "0p を使用する。こ
れは何度でも好きなだけ繰り返すことができ、無名レジスタは毎回変更される。

							*blockwise-put*
レジスタに1行(文字単位)のテキストが含まれている場合、矩形ビジュアル選択を使用
してそのレジスタを置くと、選択した各行にそのテキストが繰り返し貼り付けられ、矩
形選択された領域がレジスタテキストの複数のコピーで置き換えられる。例えば:
	- 単語 "TEXT" を `yw` によってレジスタにコピーする
	- 矩形ビジュアル選択で、このテキストの "v" を選択する:
	    aaavvaaa
	    bbbvvbbb
	    cccvvccc
	- `p` を押す、結果は:
	    aaaTEXTaaa
	    bbbTEXTbbb
	    cccTEXTccc

							*blockwise-register*
矩形ビジュアルモードで、レジスタにテキストを蓄えるコマンドを使うと、テキストの
ブロックはカーソルの前 ("P" のとき) または後 ("p" のとき) から、現在行と引き続
く行にわたって、挿入される。テキストのブロック全体は同じ列から始まるように挿入
される。そのため挿入されたテキストはコピーや削除されたときと同じ形を保っている。
Vimは、このようにするために <Tab> を空白で置き換えることがある。しかし、テキ
ストのブロックの幅が <Tab> の幅の整数倍でなく、さらに挿入されたブロックの後の
テキストが <Tab> を含むとき、列揃えがおかしくなることがある。

|zP|/|zp|を使用して、末尾にスペースを追加せずにブロック単位でヤンクされたレジ
スタを貼り付ける。

Note 文字単位のコピーコマンドの後、コピーされたテキストの中でバッファの先頭に
一番近い文字の上にカーソルが置かれることに注意。つまり "yl" ではカーソルは動か
ないが、"yh" ではカーソルは1文字左に動く。
理論的説明:	Viでは、後方移動を伴ったコマンド "y" ではコピーされたテキスト
		の先頭にカーソルを移動させないことがあった。これは再表示が省か
		れたためである。Vimでは Posix に定められた通り、常に先頭の文字
		にカーソルを移動させる。
行単位のコピーコマンドではカーソルは選択の最初の行に置かれるが、カラムは変更さ
れない。なのでその位置はコピーされた最初の文字の上ではないかもしれない。

レジスタには 10 種類ある:			*registers* *{register}* *E354*
1. 無名レジスタ ""
2. 10個の番号付きレジスタ "0 から "9
3. 小削除用レジスタ "-
4. 26個の名前付きレジスタ "a から "z または "A から "Z
5. 3個の読み取り専用レジスタ ": と ". と "%
6. 代替バッファ用レジスタ "#
7. expression 用レジスタ "=
8. 選択領域用レジスタ "* と "+ と "~ 
9. 消去専用レジスタ "_
10. 最終検索パターン用レジスタ "/

1. 無名レジスタ ""				*quote_quote* *quotequote*
このレジスタには、コマンド "d", "c", "s", "x" 等で削除されたテキストや、"y" 等
のコピーコマンドでコピーされたテキストが蓄えられる。特定のレジスタが指定されて
いてもいなくても関係ない (例えば "xdd でもこれが使われる)。つまり無名レジスタ
は最後に使われたレジスタを指していると考えられる。よって、大文字レジスタを使っ
て名前つきレジスタにテキストを追加したときも、無名レジスタの中身は、その名前つ
きレジスタと同じになる。
例外はレジスタ '_' である。"_dd は、削除されたテキストをどのレジスタにも蓄え
ない。
無名レジスタの中身は、レジスタを指定しない貼り付けコマンド (p や P) で使うこと
ができる。加えて、このレジスタは '"' という名前で使うことができる。これは、使
うときには二重引用符 '"' を 2 個打ち込むということである。レジスタ "" に対する
書き込みはレジスタ "0 にも書き込むことになる。
{Vi ではレジスタの内容はファイルを変更するときに失われ、'"' もない}

2. 番号付きレジスタ "0 から "9		*quote_number* *quote0* *quote1*
					*quote2* *quote3* *quote4* *quote9*
これらのレジスタには、コピーや削除コマンドによってテキストが蓄えられる。
   番号付きレジスタの 0 には、一番最近にコピーしたテキストが蓄えられるが、コ
ピーの際に ["x] として別のレジスタ名を指定したときは、これには蓄えられない。
   番号付きレジスタ 1 には、一番最近に削除したり変更したテキストが蓄えられる
(コマンドが別のレジスタを指定している場合でも) が、コマンドに別のレジスタ名を
指定したり、削除や変更したテキストが1行以下だったりしたときは、これには蓄えら
れない (そのときは小削除用レジスタが使われる)。例外は、以下の移動コマンドと削
除コマンドを組み合わせたときである。|%|, |(|, |)|, |`|, |/|, |?|, |n|, |N|,
|{|, |}|。
このときは必ずレジスタ "1 が使われる (これはVi互換の動作である)。削除や変更し
たテキストが1行以下だったときは、レジスタ "- も使われる。Note これらの文字は
マップされるかもしれない。例: |%| は matchit プラグインによってマップされてい
る。
   削除や変更が行われるたびに、レジスタ 1 の内容はレジスタ 2 に、レジスタ 2 の
内容はレジスタ 3 に、という風にずれていく。レジスタ 9 の内容は失われる。
{Vi: レジスタ 0 はない}

3. 小削除用レジスタ "-					*quote_-* *quote-*
このレジスタには、範囲が1行以下の削除コマンドで削除されたテキストが蓄えられる。
ただし、コマンドに ["x] で別のレジスタ名を指定したときはこれには蓄えられない。

4. 名前付きレジスタ "a から "z または "A から "Z	*quote_alpha* *quotea*
これらのレジスタが使われるのは、ユーザーに指定されたときのみである。コピーや削
除の際にこれらのレジスタを小文字で指定すると、コピーや削除されたテキストが蓄え
られ、元から入っていたテキストは消える。大文字で指定すると、元から入っていた内
容の後ろに新しいテキストを付け加える。'cpoptions' にフラグ '>' が入っていると、
新しいテキストの前に改行が挿入される。

5. 読みとり専用レジスタ ": と ". と "%
読みとり専用レジスタには '%' と ':' と '.' がある。コマンド "p", "P", ":put"
および CTRL-R でのみ使うことができる。
						*quote_.* *quote.* *E29*
	".	最後に挿入されたテキストが蓄えられる (挿入モードのコマンド
		CTRL-A や CTRL-@ で挿入されるものと同じテキストである)。 Note:
		これはコマンドライン上での CTRL-R では使えないことに注意。動作
		が少し異なり、テキストを貼り付けるというより挿入するような動作
		をする (挿入されるテキストに 'textwidth' 等のオプションが影響
		する)。
							*quote_%* *quote%*
	"%	カレントファイルの名前が蓄えられる。
						*quote_:* *quote:* *E30*
	":	一番最近に実行されたコマンドラインの内容が蓄えられる。例: 前回
		のコマンドラインによるコマンドを実行するには、"@:" が使える。
		コマンドラインがこのレジスタに蓄えられるのは、コマンドライン内
		にコマンドが最低でも1文字打ち込まれたときである。そのため、コ
		マンドが完全にキーマッピングから実行されたときには、この内容に
		変化はない。
		{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効}

							*quote_#* *quote#*
6. 代替ファイルレジスタ "#
カレントウィンドウの代替ファイルの名前を含む。これは |CTRL-^| コマンドがどのよ
うに働くかを変更する。
このレジスタは書き込み可能で、主にプラグインがこのレジスタを変更した後で元に戻
すためである。バッファ番号を許容する: >
    let altbuf = bufnr(@#)
    ...
    let @# = altbuf
バッファ番号が越えるあるいはそのバッファが存在しない場合はエラー |E86| を返す。
また存在するバッファ名でのマッチングを許容する: >
    let @# = 'buffer_name'
与えられた名前にマッチしたバッファが1つより多い場合はエラー |E93| を、与えられ
た名前にマッチするバッファがない場合は |E94| を返す。

7. Expression レジスタ "=			*quote_=* *quote=* *@=*
これは、本当はテキストを蓄えるレジスタではないが、レジスタを使うコマンドで式を
評価するために使える。この expression レジスタは読み取り/書き込み可能である。

" または CTRL-R の後に '=' を打ち込むと、カーソルはコマンド行に移動し、あらゆ
る式を入力することができる (|expression| を参照)。コマンドラインから入力できる
普通の編集用コマンドは、式用の特別履歴も含め、全て使用可能である。<CR> を打ち
込んでコマンドライン入力を終了させると、式の結果が計算される。<Esc>を打ち込ん
で終了させると、式は破棄される。式が入力されないときは、(コマンド "/" と同様)
前回の式が使われる。

式を評価した結果は文字列でなければならない。評価した結果が数値なら、文字列に変
換される。"p" と ":put" コマンドの場合、結果が浮動小数点数なら文字列に変換され
る。リストの場合、各要素が文字列に変換され、それぞれが 1 行として挿入される。
辞書は文字列へ変換される。Funcref はエラーメッセージが出る (string() を使って
変換する)。

レジスタ "= が "p" で使われると、文字列は <NL> 文字 {訳注: New Line -- 改行}
の所で分割される。文字列が <NL> で終わっていたら、これは行単位のレジスタと見な
される。

8. 選択範囲レジスタ "* と "+ と "~ 
これらのレジスタは、GUIで、選択されたテキストを蓄えたり取り出すために使われる。
|quotestar| と |quoteplus| を参照。クリップボードが利用できないときは、無名レ
ジスタが代わりに使われる。Unixでは|+xterm_clipboard|が有効になっているときだけ
クリップボードを利用できる。

Note "* と "+ に区別があるのは X11 システムのみであることに注意。違いについて
は |x11-selection| を参照。MS-Windowsでは "* と "+ は実際には同義で、クリップ
ボード |gui-clipboard| を使用する。

						*quote_~* *quote~* *<Drop>*
この読み込み専用の "~ レジスタは最後にドラッグアンドドロップされたテキストを提
供する。何かがVimにドロップされたとき、"~ レジスタがそれで埋められ、<Drop>仮想
キーが通知される。このキーをリマップして使うことができる。デフォルトでは(全て
のモードにおいて) "~ レジスタの内容をカーソルの位置に挿入する。
{|+dnd|付きでコンパイルされたときのみ有効。現在はGTK GUIでのみ使える。}

Note: "~ レジスタはプレーンテキストをVimにドロップしたときのみ使われる。URIの
リストは内部で扱われる。

9. 消去専用レジスタ "_					*quote_*
このレジスタを指定してテキストを削除しても、{訳注: レジスタには} 何も起こらな
い。そのため、普通のレジスタに影響を与えずに削除が行える。このレジスタから貼り
付けようとしても、何も出てこない。

10. 最終検索パターン用レジスタ	"/			*quote_/* *quote/*
最後に使われた検索パターンが蓄えられる。これはコマンド "n" やオプション
'hlsearch' による強調表示に使われる。
このレジスタは `:let` で変更できるので、'hlsearch' による強調表示を、実際に検
索を行わずに別のマッチに適用することができる。このレジスタを使ってコピーしたり
削除することはできない。
Note 関数から抜けると、この値は関数に入る前の値に復元される。
|function-search-undo|

							*@/*
レジスタには、コマンド `:let` で書き込むことができる |:let-@|。例: >
	:let @/ = "the"

レジスタを指定せずに貼り付けコマンドを使うと、最後に書き込みが行われたレジスタ
が使われる (その内容は無名レジスタと同じである)。混乱したときは、コマンド
`:dis` を使うとレジスタの内容が分かる (このコマンドは、全てのレジスタの内容を
表示する。無名レジスタは '"' と示される)。

以下の3個のコマンドは、必ず行全体に対して働く。

:[range]co[py] {address}				*:co* *:copy*
			[range] 行を、{address} 行目の下にコピーする。

							*:t*
:t			":copy" と同義。
			このコマンドは変数名ととても混同しやすいため、|Vim9|
			script ではサポートされない。

:[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			[range] 行を、{address} 行目の下に移動する。
			[range] 内のすべてのテキストプロパティはクリアされる。
			|text-prop-cleared| を参照。

==============================================================================
6. テキストの整形					*formatting*

:[range]ce[nter] [width]				*:ce* *:center*
			[range] の行を、幅 [width] (既定値は 'textwidth'、
			'textwidth' が 0 のときは 80) に基づいて中央揃えする。

:[range]ri[ght] [width]					*:ri* *:right*
			[range] の行を、幅 [width] (既定値は 'textwidth'、
			'textwidth' が 0 のときは 80) に基づいて右揃えする。

							*:le* *:left*
:[range]le[ft] [indent]
			[range] の行を左揃えする。行中のインデントを [indent]
			(既定値 0) に設定する。

							*gq*
gq{motion}		{motion} の行を整形する。整形は3種類の方法のうちどれか
                        で行われる。
                        1. 'formatexpr' が空でなければそのexpressionが評価さ
                           れる。これはバッファごとに異なってもよい。
                        2. 'formatprg' が空でなければ外部プログラムが使われる。
                        3. それ以外の場合は内部整形ルーチンが使われる。

                        3番目の場合は、オプション 'textwidth' が整形された各行
                        の長さを制御する (後述)。'textwidth' が 0 なら、整形さ
                        れた行の長さは画面の幅となる (ただし、最大で79)。
			'formatoptions' は、整形の仕方を制御する |fo-table|。
                        カーソルは最後に整形された行の最初の非空白文字の上に置
                        かれる。
			NOTE: 以前はコマンド "Q" でこの機能を行っていた。やは
			り整形に "Q" を使いたいならば、次のマッピングを使うこ
			と。 >
				:nnoremap Q gq

gqgq							*gqgq* *gqq*
gqq			現在行を整形する。カウントを指定するとその行数だけ整形
			される。

							*v_gq*
{Visual}gq		ビジュアル選択されたテキストを整形する。({Visual}につ
			いては|Visual-mode| を参照)。

							*gw*
gw{motion}		{motion}で動いた範囲の行を整形する。|gq|に似ているが
			カーソルは元の位置に戻る。'formatprg' と 'formatexpr'
			は使われない。

gwgw							*gwgw* *gww*
gww			"gw" と同様にして現在行を整形する。

							*v_gw*
{Visual}gw		選択されたテキストを "gw" と同様にして整形する。
                        ({Visual}については|Visual-mode|を参照)。

例: 現在の段落を整形するには、次のようにする。			*gqap*  >
	gqap

コマンド "gq" は、移動コマンドによってカーソルが動くはずの位置にカーソルを移動
させる。このため、"." で整形を繰り返すことができる。これは、"gqj" (現在行と次
行を整形) と、"gq}" (段落の最後までを整形) で有用である。 NOTE: 'formatprg' が
設定されているときは、"gq" を実行すると (フィルタコマンド使用時と同様に) カー
ソルは整形された最初の行に移動する。

カーソルのある位置の段落をフォーマットし、その位置からさらに編集を再開するには
こうする。 >
	gwap
いつも段落をフォーマットしておきたいなら 'formatoptions' に 'a' フラグを追加す
ればよい。|auto-format| も参照のこと。

オプション 'autoindent' がオンのとき、Vimは最初の行のインデントを続く行に対し
て適用する。

テキストの整形処理は空の行には変更を加えない (しかし、空白のみで構成された行に
は変更を行う！)。

オプション 'joinspaces' は、行が連結されるときに使われる。

オプション 'formatexpr' でテキストの整形に使うexpressionを設定したり、
'formatprg' で外部プログラムの名前を設定することができる。
外部プログラムによる整形処理には、'textwidth' や他のオプションは何の影響も与え
ない。

                                                        *format-formatexpr*
'formatexpr' オプションには、バッファの再整形を行う Vim script 関数を設定する
ことができる。整形はファイルの種類に強く依存するので、これは通常 |ftplugin| で
発生するべきである。対応するスクリプトは実際に必要とされるときにだけ読み込ま
れ、かつそのスクリプト名は <filetype>format.vim とされるべきなので、|autoload|
スクリプトを使用することは理にかなっている。

例えば、Vim と共に配布され $VIMRUNTIME/ftplugin ディレクトリに配置されている
XML ファイルタイププラグインは、オプション 'formatexpr' を以下のように設定する:
>
   setlocal formatexpr=xmlformat#Format()

これは、xmlformat#Format() を定義している対応したスクリプトがファイル
`$VIMRUNTIME/autoload/xmlformat.vim` で見つかることを意味している。

以下は、選択されたテキストから末尾の空白を取り除くスクリプトの例である。これを
autoload ディレクトリに置くこと。例、~/.vim/autoload/format.vim:
>vim
  func! format#Format()
    " 明示的な gq コマンドの場合だけ再整形する
    if mode() != 'n'
      " Vim の内部再整形に立ち戻る
      return 1
    endif
    let lines = getline(v:lnum, v:lnum + v:count - 1)
    call map(lines, {key, val -> substitute(val, '\s\+$', '', 'g')})
    call setline('.', lines)

    " 内部の整形は実行させない
    return 0
  endfunc

その後以下のように整形を有効にすることができる: >
  setlocal formatexpr=format#Format()

Note: この関数は、挿入モードから呼ばれた場合に明示的に非ゼロを返す (基本的に
'textwidth' の制限を超えてテキストが挿入されることを意味する)。これは Vim に内
部の整形機能に立ち戻って再整形させることになる。

しかしながら、テキストを再整形するために |gq| コマンドが使用された場合、その関
数は選択された行を受け取り、それらの行から末尾の空白を取り除き、そして所定の位
置にそのテキストを配置しなおす。もし 1 つの行を複数行に分割しようとしている場
合、何か上書きしてしまわないよう注意すること。

挿入もしくは置換モードからのテキストの再整形を可能にしたい場合、関数が再帰的に
呼び出されることがあるため注意しなければならない。これをデバッグするためには、
'debug' オプションを設定することが役に立つ。

							*right-justify*
テキストを右揃えするコマンドは、Vimには存在しない。"par" 等の外部コマンド (例:
`:.,}!par` で段落の最後までを整形する) を実行したり、'formatprg' に "par" を指
定することで、これを行うことができる。

							*format-comments*
コメント整形の概要がユーザーマニュアルの |30.6| にある。

Vimは特殊な方法で自動的にコメントを挿入・整形できる。Vimは行の最初の特定の文字
列 (空白を無視する) によって、コメントを認識できる。コメントには3種類が使える。

- 各行の最初で繰り返されるコメント文字列。例えば、"#" で始まるシェルスクリプト
  のコメントなど。
- 最初の行にのみ現れ、続きの行には現れないコメント文字列。例えば、このリストに
  おけるダッシュ '-'。
- 最初の文字列、最後の文字列、そしてその間の行の3つの部分から成るコメント。開
  始部分、中間部分、終了部分に使われる文字列は異なる。例えば、C言語形式のコメ
  ント。 >
	/*
	 * これは C のコメント
	 */

オプション 'comments' は要素のコンマ区切りのリストである。各要素はコメント文字
列の種類を定義している。要素は次のように構成される。
	{flags}:{string}

{string} は普通のテキストで、これがなければならない。

{flags}:
  n	入れ子になったコメント。混在した要素の入れ子も有効である。'comments'
	が "n:),n:>" であれば、"> ) >" で始まる行はコメント。

  b	{string} の後に余白 (<Space>、<Tab> または <EOL>) が必要。

  f	最初の行のみがコメント文字列を持つ。次の行にはコメントを繰り返さない
	が、インデントは保持する(例、bullet-list)。

  s	3部コメントの開始部分。

  m	3部コメントの中間部分。

  e	3部コメントの終了部分。

  l	左揃え。's' か 'e' と共に指定された場合、それぞれ最初または最後の部分
	の一番左の文字が、真ん中の一番左の文字に対して揃えられる。この動作は
	デフォルトであるが、省略もできる。詳しくは後述。

  r	右揃え。一番左でなく一番右であること以外、l と同じ。詳しくは後述。

  O	コマンド "O" ではこのコメントを考慮しない。

  x	3部コメントで、中間部分のコメントがすでに自動で挿入されているとき、新
	しい行の最初のアクションとして、終了部分のコメント文字列の最後の文字
	を打ち込むだけで、コメントを終了させる。詳細は以下を参照。

  {digits}
	's' か 'e' と共に指定された場合: 自動的に挿入された、中間または最後
	のコメントの最初の部分に対し、{digits} 分のオフセットを加える。この
	オフセットは左端を基準とする。詳しくは後述。

  -{digits}
	{digits} に似ているが、インデントを減らす。開始部分と終了部分に減らす
	べきインデントが存在しているときのみ機能する。

コメント文字列にフラグ 'f', 's', 'm', 'e' のいずれも指定しないとき、Vimはコメ
ント文字列を行の最初に繰り返すと仮定する。{flags} 欄は空になる。

{string} の前や後にある余白は、{string} の一部とされる。コメント文字列に必要で
ない限り、余白を前や後に付けないこと。

あるコメント開始文字列が他のコメントの一部であるときは、共通部分の後で特定の部
分を指定すること。例えば、"-" と "->" の両方を含みたいときは、次のようにする。 >
	:set comments=f:->,f:-

3部コメントには常に開始部分、中間部分、終了部分を指定しなければならない。そし
て、他の要素を間に入れてはならない。C言語での3部コメントの例は次の通り。 >
	sr:/*,mb:*,ex:*/
"*ptr" がコメントとして認識されないように、中間部分の文字列がフラグ 'b' を含ん
でいる。3部コメントでは、Vimは開始部分と中間部分の文字列の後のテキスト内に、最
後の文字列が含まれていないかを調べる。終了部分の文字列が見つかると、コメントは
次の行には続かない。3部コメントには、Vimが中間の行を認識できるようにするため
に、中間部分の文字列を指定しなければならない。

上記の3部コメントの定義における、フラグ "x" の使用について注意しておく。Cコメ
ントでリターンを打てば、Vimは新しい行に対して " * " のようなコメントの中間部分
の開始文字列を挿入する。このコメントを閉じるには、新しい行において何も打ち込む
前に "/" と打ち込めばよい。これは中間のコメント指示を最後のコメント指示に置き
換え、" */" とする。指定された桁揃えは適用される。その前にバックスペースを打ち
込む必要はない。

中間部分がマッチしたとき、終了部分もマッチしていてそちらの方が長い場合は、終了
部分が使われる。これによって C スタイルコメントが中間部分の末尾にスペースを付
けなくても機能するようになる。

桁揃えフラグを使ってコメントを目立たせる例を示す。'comments' が次のようになっ
ている場合: >
	:set comments=sr:/***,m:**,ex-2:******/
<
                                   /*** ~
                                     **<--"r" フラグによって右揃えされている ~
                                     ** ~
 "-2" フラグによってスペース         ** ~
 2 個分のオフセットがついている  --->** ~
                                   ******/ ~
これを入力する際、コメントの開始行を入力し、リターンを 4 回押す。そして "/" を
押せばコメントが終了する。

3部コメントについて、より細かいことをいくつか説明する。桁揃えフラグとオフセッ
トフラグが考慮される箇所は、次の3箇所ある。コメント開始行のあとの新規行を開く
とき、コメント終了行の前の新規行を開くとき、自動的にコメントを終了させるときで
ある。終了部分の桁揃えフラグは、上の行を参照する。これによって、"s" と "e" に
同じ桁揃えフラグを指定したとき、開始部分と終了部分のインデント量が同じになる。
コメントの部分ごとに1個だけの桁揃えが使われるようになっている。しかし、オフセッ
トの数は "r" と "l" フラグより優先する。

'cindent' をオンにしていると、多くの場合、桁揃えフラグより優先される。
|gq| や |=| を使って再インデントするときも、桁揃えフラグは適用されない。同じ挙
動を定義するには、それらのコマンドのオプションを使う。一つの考えとしては、
'cindent' に文脈に応じてコメントをインデントさせるオプションを追加することで
あるが、3部コメントの桁揃えを模倣することはほとんどできない。しかし
'indentexpr' は3部コメントをもっとうまく扱える可能性を持つ。

他の例: >
   "b:*"	"*" の後に非ブランク文字が付いていなければ、"*" で始まる行を
		含む。これはポインタの値への参照 "*str" が、コメントとして認識
		されるのを防ぐ。
   "n:>"	">", ">>", ">>>" などで始まる行を含む。
   "fb:-"	"- " で始まるリストを整形する。

既定では "b:#" が含まれている。これは "#include" で始まる行がコメントとならな
いことを意味する。しかし、"# define" で始まる行はコメントとなる。これは妥協的
解決である。

							*fo-table*
テキストの整形方法はオプション 'formatoptions' で調整できる。 'formatoptions'
は以下のフラグを含む文字列である。既定値は "tcq" である。読みやすくするために、
フラグをコンマで区切ってもよい。

フラグ	 'formatoptions' に指定されたときの作用    ~
               							*fo-t*
t	'textwidth' を使ってテキストを自動折返しする
							*fo-c*
c	'textwidth' を使ってコメントを自動折返して、現在のコメント開始文字列を
	自動挿入する。
							*fo-r*
r	挿入モードで <Enter> を打ち込んだ後に、現在のコメント開始文字列を自動
	挿入する。
							*fo-o*
o	ノーマルモードで 'o', 'O' を打ち込んだ後に、現在のコメント開始文字列を
	自動的に挿入する。特定の場所でコメントが不要な場合は、CTRL-U を使用し
	て素早く削除する。|i_CTRL-U|
							*fo-/*
/	'o' が含まれている場合: 文の後の // コメントがある場合にコメント開始文
	字列を挿入せず、// から行が始まる場合のみ挿入する。
							*fo-q*
q	"gq" でコメントを整形する。
	NOTE 整形は空行やコメント開始文字列のみの行は変更しないことに注意。新
	しい段落はそのような行の次、またはコメント開始文字列が変わった所から始
	まる。
							*fo-w*
w	行末に空白が付いているとき、段落が次行に続いていると認識する。行末が空
	白以外の行で段落が終わるとする。
							*fo-a*
a	段落を自動整形する。テキストが挿入されたり削除されるたび、段落は再整形
	される。|auto-format| を参照。
	'c' フラグも設定されているときはコメント挿入時のみ機能する。
							*fo-n*
n	テキストの整形時、番号付きリストを認識する。これは実際には
        'formatlistpat' を使う。それゆえ、どんな種類のリストでも処理できる。
        数字の後のテキストのインデントが次の行に使われる。数字の後に '.', ':',
	')', ']' や '}' が付いてもよい。オプション 'autoindent' がオンでなけれ
	ばならないことに注意。"2" と一緒には機能しない。例: >
		1. 一つ目の項目
		   折り返し
		2. 二つ目の項目
<							*fo-2*
2	テキストを整形するとき、段落の最初の行ではなく2番目の行のインデントを
	使ってそれ以降の行を整形する。これは最初の行のインデントが他の行と異な
	るような段落をサポートする。'autoindent' もオンである必要がある。例: >
			ここはある段落の一行目
		ここは上の行と同じ段落の二行目
		ここは三行目。
<	これはコメントの中でも機能する (コメント文字がないかのように)。
							*fo-v*
v	挿入モードでVi互換の自動折返しを使う: 挿入モードに入って以来入力された
	空白でのみ折返しが行われる。( NOTE: これは100%のVi互換ではない。Viには
	このあたりに「予期できない機能」、というかバグがあった。Viは実際のテキ
	ストの列の代わりに画面上の列を使用する。)
							*fo-b*
b	'v' と同様だが、折返し余白の中または前で、空白を入力したときのみ自動折
	返しをする。挿入開始時に 'textwidth' より行が長かったり、'textwidth'
	に達するまで空白を入力しなかったときは、Vimは自動折返しをしない。
							*fo-l*
l	挿入モードでは長い行は折り返されない: 挿入開始時に行が 'textwidth' よ
	り長い場合、Vimは自動で整形を行わない。
							*fo-m*
m	文字コードが 255 より後のマルチバイト文字の間でも改行する。これは文字
	全てがそれだけで単語であるような、アジア言語のテキストで便利である。
							*fo-M*
M	行の連結時に、マルチバイト文字の前後に空白を挿入しない。こちらの方がフ
	ラグ 'B' より優先する。
							*fo-B*
B	行の連結時に、マルチバイト文字同士の間に空白を挿入しない。こちらよりフ
	ラグ 'M' の方が優先する。
							*fo-1*
1	1文字の単語の後では改行しない。代わりにその前で改行される (可能ならば)。
							*fo-]*
]	'textwidth' を厳密に尊重する。このフラグを設定すると、禁則処理 {訳注:
	ぶら下り}で許可されない限り、行の長さを 'textwidth' を超えないようにす
	る。主に CJK 用で、'encoding' が "utf-8" の場合のみ機能する。
							*fo-j*
j	可能ならば、行を連結する際にコメントリーダーを削除する。例えば、以下の
	行を連結する場合:
		int i;   // the index ~
		         // in the list ~
	以下のようになる:
		int i;   // the index in the list ~
							*fo-p*
p	ピリオドに続く単一の空白で改行しない。これは、2つの空白で区切られた文
	章を含む散文用に 'joinspaces' と |cpo-J| を補完するためのものである。
	例えば、'textwidth' を28に設定すると: >
		Surely you're joking, Mr. Feynman!
<	以下のようになる: >
		Surely you're joking,
		Mr. Feynman!
<	以下のようにはならない: >
		Surely you're joking, Mr.
		Feynman!


't' と 'c' でVimが自動折返しを行うタイミングを指定できる。
フラグ	作用	~
""	自動整形しない ("gq" で手動の整形処理を行う)
"t"	テキストを自動整形するが、コメントにはしない
"c"	コメントを自動整形するが、テキストにはしない (C言語コードに適している)
"tc"	テキストとコメントを自動整形する

NOTE 'textwidth' が 0 のとき、Vimはいかなる自動整形も行わないので注意
('comments' によるコメント開始文字列の挿入はする)。例外はフラグ 'a' が入ってい
る場合である。|auto-format|

NOTE 'paste' がオンのとき、Vimは全ての整形処理を行わないので注意。

NOTE Vimに自動折返しをさせなくても、'textwidth' は非 0 であってよいことに注意。
'textwidth' は "gq" による整形処理でも便利だからである。

'comments' が "/*" と ("*" と) "*/" を含んでいるときは、Vim組み込みの機能によ
りこれらのタイプのコメントをもう少し巧く扱うことができる。
('formatoptions' に 'r' か 'o' が含まれているとき) "/*" または "*/" の前か後で
新しい行を始めると、行の正しい開始位置が自動的に与えられる。同じことが整形処理
と自動折返しでも行われる。"/*" や "*" で始まり、かつ "*/" を含む行の後で行を始
めるときは、コメント開始文字列が挿入されず、新しい行のインデントはコメントの最
初の行に合わせられる。
例:
    /* ~
     * 典型的なコメント。 ~
     */ ~
    この行のインデントは、上のコメントの先頭行と同じになる。

これら全ては、特に異なるファイルタイプに対する異なる設定に対応する際、新しい
autocommand と連携して、クールに振舞うはずである。

いくつかの例:
  C言語コード用 (コメントの整形のみ): >
	:set fo=croq
< メール／ネットニューズ用 (全て整形、コマンド "o" でコメントを始めない): >
	:set fo=tcrq
<

自動整形					*auto-format* *autoformat*

オプション 'formatoptions' にフラグ 'a' が含まれると、テキストを挿入したり削除
したときに自動整形が行われる。これはテキストの段落分けを編集するときにうまく働
く。以下では使い方についてのヒントをいくつか。

- 段落を適切に定義する必要がある。もっとも単純なものは、空行が区切りになる場合
  である。区切りとなる空行がないときは、フラグ 'w' を使い、段落の最終行以外の
  行末に空白を付けるようにしてみること。

- 'formatoptions' をファイルタイプ |filetype| に基づいて設定することができる。
  またはモードライン |modeline| で特定のファイルに対して設定することもできる。

- 'formatoptions' を "aw2tcq" に設定し、テキストのインデントを次のようにするこ
  ともできる。

	    bla bla foobar bla 
	bla foobar bla foobar bla
	    bla bla foobar bla 
	bla foobar bla bla foobar

- コメントだけを自動整形するには 'c' フラグを追加する。ソースコードの編集向き。

- 行の長さを望みどおりにするには 'textwidth' を設定する。これが0ならば79になる。
  画面の幅が79桁より小さい場合は画面幅になる。

次にいくつかの警告:

- テキストの部分部分が段落内で適切に分割されていないとき、そのテキスト内で変更
  を行うと、有無をいわさず整形が始まってしまう。次のようにしてみること。 >

	:set fo-=a

- フラグ 'w' (行末の空白で段落が終わっていないことを判断する) を使っているとき
  に |dd| で段落の最終行を削除すると、その段落が次の段落とつながってしまう。

- 変更されたテキストは、アンドゥのために記憶される。整形も変更の一種である。そ
  のため、整形を行う度にテキストがアンドゥ用に記憶される。すると大量のメモリを
  消費するかもしれない。

- 長い段落や、複雑なインデントの段落を整形するのには、時間がかかることがある。

==============================================================================
7. テキストのソート					*sorting*

Vimはソート関数とソートコマンドを備えている。ソート関数については |sort()|、
|uniq()| を参照。
|:uniq| も参照。

							*:sor* *:sort*
:[range]sor[t][!] [b][f][i][l][n][o][r][u][x] [/{pattern}/]
			[range]の行をソートする。範囲が指定されない場合は全行
			をソートする。

			[!]をつけると順序が逆になる。

			[i]をつけると大文字・小文字を区別しない。
							*:sort-l*
			[l]をつけると現在のロケールの照合順序を使用してソート
			する。
			実装の詳細: 文字列の比較に strcoll() を使用する。ロケー
			ル照合順をチェックしたり設定するには |:language| を参
			照すること。例: >
				:language collate en_US.UTF-8
				:%sort l
<			|v:collate| でも現在のロケールを確認することができる。
			ロケール利用のソートでは通常大文字小文字を区別しない。
			これはMacでは正常に動作しない。

			[n][f][x][o][b] オプションはどれかひとつのみ指定できる。

			[n]をつけると行の({pattern}のマッチの後ろまたは内側
			の)最初の10進数の数字でソートする。
			数字が '-' で始まる場合、マイナスとみなされる。

			[f] をつけると行の小数点数でソートする。
			小数点数の値は ({pattern} によるマッチの後ろまたは内側
			の) テキストを str2float() に渡すようにして決定される。
			このオプションは Vim が小数点数サポートを有効にしてコ
			ンパイルされたときのみ使える。

			[x]をつけると行の({pattern}のマッチの後ろまたは内側の)
			最初の16進数の数字でソートする。"0x" と "0X" は無視さ
			れる。
			数字が '-' で始まる場合、マイナスとみなされる。

			[o]をつけると行の({pattern}のマッチの後ろまたは内側の)
			最初の8進数の数字でソートする。

			[b] をつけると({pattern}によるマッチの後ろまたは内側の)
			行の最初の2進数でソートする。
							*:sort-u* *:sort-uniq*
			[u]をつけると (u は unique=「一意の」という意味に基づ
			く) 連続する同一行の最初の行だけを残す。([i]がつくと大
			文字・小文字を無視する) このフラグがつかない場合、連続
			する同一行はそのままの順序で残される。
			Note: 先頭と末尾の空白が原因で異なる行にみなされるかも
			しれない。
			単にユニークにしたいだけの場合は、|:uniq| を使用する。

			/pattern/が指定され、フラグ[r]がない場合は{pattern}に
			マッチするテキストはスキップされる。これによって、その
			マッチの後に来るテキストでソートできる。
			スラッシュの代わりにどんなnon-letterでも使うことができ
			る。
			パターンには 'ignorecase' は適用されるが、'smartcase'
			は利用されない。
			例えば、コンマで区切られた2番目のフィールドでソートす
			るには: >
				:sort /[^,]*,/
<			画面上の10桁目でソートするには(そのためタブとスペース
			は同一視される): >
				:sort /.*\%10v/
<			行中の最初の数字でソートするには: >
				:sort /.\{-}\ze\d/
<			(解説: ".\{-}" は任意のテキストにマッチする。"\ze"
			はそのマッチの終わりをセットし、"\d" は数字にマッチ
			する。)
			[r]がつくと、前述のように{pattern}をスキップするのでな
			く、{pattern}にマッチする部分でソートする。
			例えば、各行の最初の3文字だけでソートするには: >
				:sort /\a\a\a/ r

<			{pattern}が使われると{pattern}を含まない行は現在の順序
			のままになる。逆順でソートすると、それらはソートされた
			行の後で逆順になる。逆順でなければ、ソートされた行の前
			でもとの順序のまま置かれる。

			{pattern} が空である場合(例: // が指定されたとき)、
			最後に使われた検索パターンが使われる。よって、まず検
			索コマンドでパターンを確かめてみることができる。

Note: `:global` といっしょに `:sort` を使ってもマッチする行をソートすることに
はならない。これはまったく無意味である。

`:sort` は l フラグが使われていない限り現在のロケールを使わない。
ソートは「安定」ソートである。

ソートは中断することができる。しかし中断するのが遅いと行が重複してしまうかもし
れない。これも使っているシステムのライブラリ関数による。

==============================================================================
8. テキストの重複除去				*deduplicating* *unique*

Vim には重複排除関数と重複排除コマンドがある。重複排除関数は |uniq()| で確認で
きる。
|:sort-uniq| も参照。

							*:uni* *:uniq*
:[range]uni[q][!] [i][l][r][u] [/{pattern}/]
			[range] 内で隣接する重複行を削除する。範囲を指定しない
			場合は、すべての行が処理される。

			[i] を指定すると、行を比較するときに大文字と小文字を区
			別しない。

			[l] を指定すると、現在の照合ロケールに基づいて比較が行
			われる。詳細は |:sort-l| を参照。

			[r] を指定すると、行全体ではなく /{pattern}/ にマッチ
			するテキストに対して比較が行われる。

			[u] を指定すると、繰り返されない行 (つまり、同じ行が直
			後に続かない行) のみを保持する。

			[!] を指定すると、直後に重複行がある行のみを保持する。

			[!] と [u] の両方が指定された場合、[u] は無視され [!]
			が適用される。

			/{pattern}/ が指定され、[r] が指定されていない場合、
			{pattern} にマッチするテキストはスキップされ、マッチの
			後ろの部分で比較が行われる。
			'ignorecase' はパターンに適用されるが、'smartcase' は
			使用されない。
			スラッシュの代わりに、任意の非文字を使用できる。

			例えば、2 番目のコンマ区切りフィールドに基づいて隣接す
			る重複行を削除する場合: >
				:uniq /[^,]*,/
<			または、最初の 5 文字を無視してユニークな行のみを保持
			する場合: >
				:uniq u /.\{5}/
<			{pattern} が空の場合 (例えば、// が使用されている場
			合)、最後の検索パターンが使用される。

			Note 先頭と末尾の空白により、行が異なるものとして扱わ
			れる場合があることに注意。
			位置に関係なくすべての重複を削除するには、|:sort-u| ま
			たは外部ツールを使用すること。

 vim:tw=78:ts=8:noet:ft=help:norl:
