*channel.txt*      For Vim バージョン 8.0.  Last change: 2016 Dec 01


		  VIMリファレンスマニュアル    by Bram Moolenaar


		      プロセス間通信				*channel*

Vimは別のプロセスと通信するのにチャンネルを用います。
チャンネルはソケットまたはパイプを用います。		*socket-interface*
ジョブはプロセスを開始し、プロセスと通信するために使用できます。
Netbeansインターフェイスもチャンネルを使っています。|netbeans|

1. 概要					|job-channel-overview|
2. チャンネルデモ			|channel-demo|
3. チャンネルを開く			|channel-open|
4. JSON、JSチャンネルを使う		|channel-use|
5. チャンネルコマンド			|channel-commands|
6. RAW、NLチャンネルをつかう		|channel-raw|
7. その他のチャンネル機能		|channel-more|
8. チャンネルでジョブを開始する		|job-start|
9. チャンネルなしでジョブを開始する	|job-start-nochannel|
10. ジョブオプション			|job-options|
11. ジョブを制御する			|job-control|

{Vi にはこれらの機能はありません}
{Vim が |+channel| 機能付きでコンパイルされたときのみ有効}
	`has('channel')` でこれを確認できる
{Vim が |+job| 機能付きでコンパイルされたときのみ有効}
	`has('job')` でこれを確認できる

==============================================================================
1. 概要							*job-channel-overview*

主に4種類のジョブがあります:
1. いくつかの Vim インスタンスを扱うデーモン。Vim はソケットで接続します。
2. 1つの Vim インスタンスを1つのジョブが非同期に処理する。ソケットまたはパイプ
   を使用します。
3. 短時間、非同期で仕事をするジョブ。ソケットまたはパイプを使用します。
4. フィルタを同期して実行する。パイプを使用します。

ソケットを使用する場合 |job-start|、|job-start-nochannel|、および
|channel-open| 参照。2と3の場合は、パイプを使用する1つ以上のジョブです
(|job-start| 参照)。
4の場合、":{range}!cmd" コマンドを使用します(|filter| 参照)。

ソケットとパイプ上でこれらのプロトコルを利用できます:
RAW	何も知られていない、Vim はメッセージの終わりを知らせない。
NL	すべてのメッセージは NL (改行)文字で終わります。
JSON	JSON エンコーディング |json_encode()|
JS	JavaScript スタイルの JSON 風のエンコーディング |js_encode()|

共通の組み合わせ:
- NL モードでパイプを介して接続されたジョブを使用します。例えば、スタイルチェッ
  カーを実行し、エラーと警告を受け取ります。
- デーモンを使用して、JSON モードでソケットに接続します。例えば、データベース
  内の相互参照を参照します。

==============================================================================
2. チャンネルデモ			*channel-demo* *demoserver.py*

デモにはPythonが必要です。デモプログラムは次の場所にあります。
$VIMRUNTIME/tools/demoserver.py
それをあるターミナルで実行しましょう。そのターミナルをT1と呼びます。

次に別のターミナルでVimを実行します。そして以下のコマンドでサーバーに接続しま
す: >
	let channel = ch_open('localhost:8765')

T1の中に次のように表示されます:
	=== socket opened === ~

ついにサーバーにメッセージを送信できます: >
	echo ch_evalexpr(channel, 'hello!')

このメッセージはT1で受信され、Vimには応答が送り返されます。
T1ではVimが送った生のメッセージを確認できます:
	[1,"hello!"] ~
そしてレスポンスはこうなります:
	[1,"got it"] ~
この数値はメッセージを送るたびに増加していきます。

サーバーはVimにコマンドを送信できます。T1に於いて、次のように正確に(引用符を含
めて文字通りに)タイプしてください:
	["ex","echo 'hi there'"] ~
するとそのメッセージがVimに表示されます。カーソルを1単語先に移動することができ
ます:
	["normal","w"] ~

非同期通信を取り扱うためにはコールバック(以下ハンドラー)が必要です: >
	func MyHandler(channel, msg)
	  echo "from the handler: " . a:msg
	endfunc
	call ch_sendexpr(channel, 'hello!', {'callback': "MyHandler"})
Vim は応答を待つことはありません。これで、サーバーは応答を後で送信し、
MyHandler が呼び出されます。

sendを呼ぶたびに毎回コールバックを指定する代わりに、チャンネルを開く際に指定す
ることもできます: >
	call ch_close(channel)
	let channel = ch_open('localhost:8765', {'callback': "MyHandler"})
	call ch_sendexpr(channel, 'hello!')

チャンネルを試してみると、何が起こっているのかを知ることができます。あなたは
Vim にログファイルに行を書くよう指示することができます: >
	call ch_logfile('channellog', 'w')
|ch_logfile()| 参照.

==============================================================================
3. チャンネルを開く					*channel-open*

チャンネルを開くには次のようにします: >
    let channel = ch_open({address} [, {options}])
    if ch_status(channel) == "open"
      " use the channel

|ch_status()| を使用して、チャンネルを開くことができたかどうかを確認します。

{address} は "ホスト名:ポート番号" の形式です。例:"localhost:8765"

{options} はオプションのエントリを持つ辞書です:		*channel-open-options*

"mode" でモード(通信フォーマット)を指定します:		*channel-mode*
	"json" - JSONを使う(詳しくは下記を参照。もっとも使いやすい方法。既定)
	"js"   - JS(JavaScript) エンコーディングを使用し、JSON よりも効率的。
	"nl"   - NL 文字で終わるメッセージを使う
	"raw"  - rawメッセージを使う
						*channel-callback* *E921*
"callback"	メッセージ受信時に他のハンドラーで扱われない時に呼ばれます。
		これはチャンネルのハンドルと、受信したメッセージの2つの引数を
		取ります。例: >
	func Handle(channel, msg)
	  echo '受信した: ' . a:msg
	endfunc
	let channel = ch_open("localhost:8765", {"callback": "Handle"})
<
		"mode" が "json", "js" の時には、"msg" 引数は受信したメッセー
		ジの本文で、Vimの型に変換されています。
		"mode" が "nl" の時には、"msg" 引数は NL を除く1つのメッセージ
		です。
		"mode" が "raw" の時には、"msg" 引数はメッセージ全体を格納し
		た文字列です。

		すべてのコールバック: |function()| を使用して、引数および/また
		は辞書にバインドします。または、"dict.function" という形式を使
		用して辞書をバインドします。

		コールバックは、通常、Vim がユーザーが文字を入力するのを待って
		いるとき、「安全な」瞬間にのみ呼び出されます。Vim はマルチス
		レッドを使用しません。

							*close_cb*
"close_cb"	|ch_close()| を呼び出す以外に、チャンネルが閉じられたときに呼
		び出される関数。このように定義する必要があります: >
	func MyCloseHandler(channel)
<		Vim は close_cb を呼び出す前にデータを処理するコールバックを呼
		び出します。したがって、この関数が呼び出されると、それ以上の
		データはコールバックに渡されません。
							*channel-drop*
"drop"		メッセージをいつドロップするかを指定します:
		    "auto"	メッセージを処理するコールバックがない場合。
				"close_cb" もこのために考慮されます。
		    "never"	すべてのメッセージが保存されます。
							*waittime*
"waittime"	接続がミリ秒単位で待機する時間。負の数は永遠に待ちます。

		デフォルトはゼロで、待機しません。これは、ローカルサーバーがす
		でに実行されている場合に便利です。Unix Vim では実際には1msのタ
		イムアウトが使われます。多くのシステムではそれが必要なためで
		す。リモートサーバーには大きな値を使用してください。例: 少なく
		とも10msec。
							*channel-timeout*
"timeout"	ブロッキング時にリクエストを待つ時間(例: |ch_evalexpr()| を使用
		するとき。ミリ秒単位。デフォルトは2000(2秒)です。

"mode" が "json" か "js" の時には "callback" はオプションです。これを省略した
場合、メッセージを1つ受信するにはメッセージを1つ送信する必要があります。

チャンネルオプションを開いた後に変更するには、|ch_setoptions()| を使用します。
引数は |ch_open()| に渡されるものと似ていますが、"waittime" は与えられません。
これはチャンネルを開く場合にのみ適用されるためです。

例えば、ハンドラーは後から追加したり、変更したりできます: >
    call ch_setoptions(channel, {'callback': callback})
"callback" が空の場合 (一度も指定しないか、空文字列を指定した場合) ハンドラー
は削除されます。

コールバックが呼び出された後、Vim は画面を更新し、カーソルをそれが属する場所に
戻します。コールバックは `:redraw` を行う必要はありません。

タイムアウトは次のように変更できます: >
    call ch_setoptions(channel, {'timeout': msec})
<
							  *channel-close* *E906*
チャンネルを使い終わったら、以下のように切断してください: >
    call ch_close(channel)
ソケットが使用されていると、両方向のソケットが閉じられます。パイプが使用されて
いると(stdin/stdout/stderr)、それらはすべて閉じられます。これはあなたが望むもの
ではないかもしれません! |job_stop()| でジョブを停止する方が良いかもしれません。
すべての先読みは破棄され、コールバックは呼び出されなくなります。

チャンネルは3つの段階で閉じられることに注意してください:
  - I/O が終了し、ログメッセージ: "Closing channel" が表示されます。呼び出すた
    めの読み込みまたはコールバックのキューに入れられたメッセージがまだ残ってい
    る可能性があります。
  - 先読みがクリアされ、ログメッセージ: "Clearing channel" が表示されます。変
    数によっては引き続きチャンネルを参照することがあります。
  - チャンネルが解放され、ログメッセージ： "Freeing channel" が表示されます。

チャンネルを開くことができない場合、エラーメッセージが表示されます。MS-Windows
と Unix には違いがあります: Unix では、ポートが存在しないとき、|ch_open()| は
すぐに失敗します。MS-Windows では "waittime" が適用されます。
*E898* *E901* *E902*

チャンネルを読み書きする際にエラーが発生した場合、チャンネルは閉じられます。
*E630* *E631*

==============================================================================
4. JSON、JSチャンネルを使う					*channel-use*

"mode" が JSON の場合は、以下のようにメッセージを同期的に送信できます: >
    let response = ch_evalexpr(channel, {expr})
これは通信相手から応答があるまで待ち合わせます。

mode が JS の場合は、メッセージが JavaScript エンコーディングを使用する点を除
いて、これは同じです。その違いについては、|js_encode()|参照。

応答を処理せずにメッセージを送信する、またはチャンネルコールバックに応答を処理
させるには: >
    call ch_sendexpr(channel, {expr})

メッセージを送信し、応答を特別な関数で非同期的に処理する場合には、このようにし
ます: >
    call ch_sendexpr(channel, {expr}, {'callback': Handler})

Vim は、メッセージIDを使用して要求との応答を照合します。応答が受信されると、
コールバックが呼び出されます。同じIDを持つさらなる応答は無視されます。あなたの
サーバーが複数の応答を返信する場合、IDゼロで送信する必要があります。それらは
チャンネルコールバックに渡されます。

{expr} は JSON に変換され、配列で包まれます。{expr} として文字列 "hello" を送
信した場合に、通信相手が受け取るメッセージの例は次のようになります:
	[12,"hello"] ~

送信されるJSONのフォーマットはこのようになっています:
    [{number},{expr}]

{number} には毎回異なる値が入ります。これは応答があるならば、必ず使われます:

    [{number},{response}]

このようにして、受信したメッセージがどの送信メッセージに対応するかを知ることが
でき、正しいハンドラーを呼び出すことができます。これによって応答メッセージの到
着順序を気にしなくても良くなります。

改行文字が JSON テキストを終了しています。これは、読み込まれたテキストを区切る
ために使用できます。例えばPythonでは:
	splitidx = read_text.find('\n')
	message = read_text[:splitidx]
	rest = read_text[splitidx + 1:]

送信側はかならず有効なJSONをVimへ送らなければなりません。VimはJSONとして解釈す
ることで、受信メッセージの終端をチェックします。終端を受信することが、
メッセージを受理する唯一の方法です。A newline after the message is optional.

サーバープロセスがVimからのメッセージを受信すること無く、メッセージを送信する
には、数値に 0 を使う必要があります。
    [0,{response}]

するとチャンネルのハンドラーが {response} をVimの方に変換したものを受け取るで
しょう。チャンネルにハンドラーが関連付けられていない場合には、メッセージは破棄
されます。

JSON または JS チャンネルで |ch_sendraw()| および |ch_evalraw()| を使用するこ
ともできます。その場合呼び出し元は、正しくエンコードとデコードを行う完全な責任
があります。

==============================================================================
5. チャンネルコマンド					*channel-commands*

JSON チャンネルを使用すると、サーバープロセス側はVimへコマンドを送信できます。
そのコマンドはチャンネルのハンドラーを介さずに、Vimの内部で実行されます。

実行可能なコマンドは以下のとおりです:		*E903* *E904* *E905*
    ["redraw", {forced}]
    ["ex",     {Ex コマンド}]
    ["normal", {ノーマルモードコマンド}]
    ["eval",   {式}, {数値}]
    ["expr",   {式}]
    ["call",   {関数名}, {引数リスト}, {数値}]
    ["call",   {関数名}, {引数リスト}]

これらを使うときは、これらのコマンドが何をするかに十分気をつけてください!
ユーザーが何をしているかによっては容易に干渉してしまいます。トラブルを避けるに
は |mode()| を使い、エディタが期待した状態にあるかチェックしてください。例え
ば、コマンド実行ではなくテキストとして入力させたい文字列を送るには、以下のよう
にします:
    ["ex","if mode() == 'i' | call feedkeys('ClassName') | endif"] ~

これらのコマンドのエラーは、表示が乱れないようにするため、通常は報告されませ
ん。表示したい場合は、'verbose' オプションを3以上に設定してください。


コマンド "redraw" ~

他のコマンドは画面を更新しないので、カーソルを動かさずに一連のコマンドを送るこ
とができます。変更されたテキストを表示し、それが属する場所にカーソルを表示する
には、"redraw" コマンドで終了する必要があります。

引数は通常は空の文字列です:
	["redraw", ""] ~
最初に画面をクリアするには "force" を渡してください:
	["redraw", "force"] ~


コマンド "ex" ~

"ex" コマンドは Ex コマンドを実行します。完了やエラーの応答はありませ
ん。|autoload| スクリプトの中の関数を使えます:
	["ex","call myscript#MyFunc(arg)"]


"call |feedkeys()|" を使用してキーシーケンスを挿入することもできます。

エラーが発生すると、チャンネルログにメッセージが書き込まれ、存在する場合は
v:errmsg にエラーが設定されます。


コマンド "normal" ~

"normal" コマンドは ":normal!" のように実行され、コマンドはマップされません。
カーソルの下の折畳を開く例:
	["normal" "zO"]


コマンド "expr" (応答あり) ~

"expr" コマンドは、式の結果を得るために使うことができます。たとえば、現在のバッ
ファ内の行数を取得するには、次のようにします:
	["expr","line('$')", -2] ~

式の結果を返します:
	[-2, "last line"] ~
形式は次のとおりです:
	[{number}, {result}]

{number} は、リクエストに指定したのと同じものです。Vim が送信するメッセージと
の混乱を避けるには、負の数を使用します。リクエストとレスポンスを一致させるに
は、リクエストごとに異なる番号を使用します。

{result} は評価の結果であり、JSON エンコードされています。評価が失敗したり、結
果を JSON でエンコードできない場合は、文字列 "ERROR" となります。


コマンド "expr" (応答なし) ~

このコマンドは上記の "expr" に近いのですが、応答を返信しません。
例:
	["expr","setline('$', ['one', 'two', 'three'])"] ~
リクエストに第3引数はありません。


コマンド "call" ~

これは "expr" に似ていますが、式全体を文字列として渡す代わりに、関数の名前と引
数のリストを渡します。これは、引数の文字列への変換を避け、エスケープして連結し
ます。例:
	["call", "line", ["$"], -2] ~

応答が送信されない場合は、第4引数を省いてください:
	["call", "setline", ["$", ["one", "two", "three"]]] ~

==============================================================================
6. RAW、NL チャンネルを使う					*channel-raw*

モードがRAWかNLの場合には、以下のようにしてメッセージを送信します: >
    let response = ch_evalraw(channel, {string})

{string} はそのまま送信されます。受信した応答メッセージは直ちにチャンネルから
読み込み可能になります。この時、Vimにはメッセージの終了をどう判断するかがわか
りませんから、あなた自身が面倒を見る必要があります。タイムアウトは、最初のバイ
トを読み取るために適用され、その後は何も待つことはありません。

mode が "nl" の場合、同様の方法でメッセージを送信できます。あなたは各メッセー
ジの後に NL に入れなければなりません。したがって、一度に NL で終わる複数のメッ
セージを送信することもできます。応答は最初の NL までのテキストとなります。これ
は空のレスポンスの NL だけでもかまいません。チャンネルタイムアウトの前に NL が
読み取られなかった場合、空の文字列が返されます。


応答を必要としないメッセージを送信するには以下のようにします: >
    call ch_sendraw(channel, {string})
プロセス{訳注:サーバーのこと}はレスポンスを返し、チャンネルのハンドラーに渡さ
れます。

メッセージを送信し、レスポンスを特定の関数で非同期的に取り扱うには以下のように
します: >
    call ch_sendraw(channel, {string}, {'callback': 'MyHandler'})

この {string} はJSONにもできます。その場合、|json_encode()| でそれを作成し
|json_decode()| で受信したJSONメッセージを取り扱います。

生のチャンネルで |ch_evalexpr()| または |ch_sendexpr()| を使用することはできま
せん。

Vim の文字列に NUL バイトを含めることはできません。NUL バイトを送受信するには、
バッファから読み書きしてください。|in_io-buffer| と |out_io-buffer| 参照。

==============================================================================
7. その他のチャンネル機能				*channel-more*

チャンネルのステータスを取得するには、ch_status(channel)を使用します。ありうる
結果は次のとおりです:
	"fail"		チャンネルを開くことができませんでした。
	"open"		チャンネルを使用することができます。
	"buffered"	チャンネルは閉じられましたが読み込むデータがあります。
	"closed"	チャンネルが閉じられました。

チャンネルに関連付けられたジョブを取得するには: ch_getjob(channel)

チャンネルから1つのメッセージを読むには: >
	let output = ch_read(channel)
これは、チャンネルのタイムアウトを使用します。タイムアウトなしで読むには、利用
可能なメッセージを取得するだけです: >
	let output = ch_read(channel, {'timeout': 0})
メッセージが利用できなかった場合、結果は JSON またはJSモードのチャンネルでは
v:none、RAW または NL チャンネルでは空の文字列です。|ch_canread()| を使用して、
何かがあるかどうかを調べることができます。

コールバックメッセージがない場合、メッセージは破棄されます。これを回避するに
は、チャンネルにコールバックを追加します。

使用可能なRAWチャンネルからすべての出力を読み込むには: >
	let output = ch_readraw(channel)
エラー出力を読むには: >
	let output = ch_readraw(channel, {"part": "err"})

ch_read() と ch_readraw() はチャンネルタイムアウトを使用します。その時間内に何
も読み込めない場合、空の文字列が返されます。別のタイムアウトをミリ秒で指定する
には、"timeout" オプションを使用します:
	{"timeout": 123} ~
エラー出力から読み込むには、"part" オプションを使用します:
	{"part": "err"} ~
特定の ID を持つメッセージを JS または JSON チャンネルで読み取るには:
	{"id": 99} ~
ID が指定されていないか、または ID が-1の場合、最初のメッセージが返されます。
これは、このメッセージを待っているコールバックをすべて無効にします。

RAW チャンネルの場合、Vim はメッセージの終わりを知らないので、利用可能なものを
返します。
NL チャンネルの場合、これは1つのメッセージを返します。
JS または JSON チャンネルの場合、これは1つのデコードされたメッセージを返しま
す。
これには、任意のシーケンス番号が含まれます。

==============================================================================
8. チャンネルでジョブを開始する				*job-start* *job*


ジョブを開始し、stdin/stdout/stderr のチャンネルを開くには: >
    let job = job_start(command, {options})

チャンネルを得るには: >
    let channel = job_getchannel(job)

チャンネルは NL モードを使用します。別のモードが必要な場合は、{options} でこれ
を指定することをお勧めします。後でモードを変更すると、一部のテキストがすでに受
信され、正しく解析されていない可能性があります。

コマンドが処理したい出力行を生成する場合は、stdout のハンドラを指定します: >
    let job = job_start(command, {"out_cb": "MyHandler"})
この関数は、チャンネルとメッセージで呼び出されます。あなたはこれをこのように定
義します: >
    func MyHandler(channel, msg)

ハンドラがなければ、|ch_read()| または |ch_readraw()| で出力を読み取る必要があ
ります。クローズコールバックでこれを行うことができます。|read-in-close-cb| 参
照。

出力を読み取る前にジョブが終了すると、出力が失われる可能性があることに注意して
ください。これはシステムによって異なります(Unix 上では、パイプの書き込み終了を
閉じると EOF が得られます)。これを避けるには、ジョブが終了する前にそれをしばら
くスリープさせること。

"out_cb" に定義されたハンドラは stderr を受け取りません。もし個別に扱いたい場
合は、"err_cb" ハンドラを追加します: >
    let job = job_start(command, {"out_cb": "MyHandler",
	    \			  "err_cb": "ErrHandler"})

1つのハンドラで stderr と stdout の両方を処理する場合は、"callback" オプション
を使用します: >
    let job = job_start(command, {"callback": "MyHandler"}) 

ch_evalraw() でコマンドにメッセージを送ることができます。チャンネルが JSON ま
たは JS モードの場合、ch_evalexpr() を使用できます。

使用できるオプションがいくつかあります。|job-options| 参照。
例えば、ジョブを開始し、その出力をバッファ "dummy" に書き込むには: >
	let logjob = job_start("tail -f /tmp/log",
			     \ {'out_io': 'buffer', 'out_name': 'dummy'})
	sbuf dummy


バッファからのジョブ入力 ~
							*in_io-buffer*
バッファから読み取るジョブを実行するには: >
	let job = job_start({command},
	    \ {'in_io': 'buffer', 'in_name': 'mybuffer'})
<
							*E915* *E918*
バッファは、|bufnr()| と同様の名前で見つけられます。バッファは、job_start()
が呼び出されたときに存在し、ロードされていなければなりません。

デフォルトでは、これはバッファ全体を読み込みます。これは "in_top" と "in_bot"
オプションで変更できます。

特殊モードは、in_top が0に設定され、in_bot が設定されていない場合です。バッファ
に行が追加されるたびに、最後の1行がジョブ stdin に送信されます。これにより、
最後の行を編集し、Enter を押したときに送信することができます。
							*channel-close-in*
特殊モードを使用しないときは、最後の行が書き込まれた後にパイプまたはソケットが
閉じられます。これは、入力が終了した読み取り終了を知らせます。|ch_close_in()|
を使用すると、より早く終了することもできます。

テキストの NUL バイトはジョブに渡されます(内部では Vim はこれらを NL バイトと
して格納します)。


クローズコールバックでジョブ出力を読み込む ~
							*read-in-close-cb*
ジョブに時間がかかり、中間結果が必要ない場合は、クローズコールバックを追加して
そこの出力を読み取ることができます: >

	func! CloseHandler(channel)
	  while ch_status(a:channel, {'part': 'out'}) == 'buffered'
	    echomsg ch_read(a:channel)
	  endwhile
	endfunc
	let job = job_start(command, {'close_cb': 'CloseHandler'})

あなたは "echomsg" よりも役に立つ何かをしたいでしょう。

==============================================================================
9. チャンネルなしでジョブを開始する			*job-start-nochannel*

チャンネルを作成せずに別のプロセスを開始するには: >
    let job = job_start(command,
	\ {"in_io": "null", "out_io": "null", "err_io": "null"})

これはバックグラウンドで {command} を開始し、Vim はそれが完了するのを待ちませ
ん。

Vim が stdin、stdout、stderr のいずれも接続されていないと判断すると、チャンネ
ルは作成されません。コマンドが停止するのを避けるために、リダイレクションをコマ
ンドに含めることがよくあります。

使用できるオプションがいくつかあります。|job-options| 参照。

							*job-start-if-needed*
アドレスへの接続が動作しない時にのみジョブを開始するには、次のような操作を行い
ます: >
	let channel = ch_open(address, {"waittime": 0})
	if ch_status(channel) == "fail"
	  let job = job_start(command)
	  let channel = ch_open(address, {"waittime": 1000})
	endif

ch_open() の待ち時間は、ポートを利用可能にするためにジョブに1秒を与えることに
注意してください。

==============================================================================
10. ジョブオプション					*job-options*

job_start() の {options} 引数は辞書です。すべての入力はオプションです。
job_setoptions(job, {options}) を使用して、ジョブの開始後にいくつかのオプショ
ンを使用できます。ch_setoptions(channel, {options}) を使用して、ジョブに関連す
るチャンネルで多くのオプションを使用できます。|job_setoptions()| および
|ch_setoptions()| 参照。

						*in_mode* *out_mode* *err_mode*
"in_mode"		stdin 用のモード、パイプを使用している場合にのみ。
"out_mode"		stdout 用のモード、パイプを使用している場合にのみ。
"err_mode"		stderr 用のモード、パイプを使用している場合にのみ。
			値については、|channel-mode| 参照。

			Note: "mode" を設定すると、パーツ固有のモードが上書き
			されます。したがって、最初に "mode" を、後でパーツ固
			有のモードを設定します。

			Note: ファイルやバッファに書き込むときやバッファから読
			み込むときは、NL モードがデフォルトで使用されます。

						*job-callback*
"callback": handler	チャンネルの任意の部分で何かを読むためのコールバック。
						*job-out_cb* *out_cb*
"out_cb": handler	stdout で読み込むべきものがあるときのコールバック。チャ
			ンネルがパイプを使用している場合のみ。"out_cb" が設定
			されていない場合は、チャンネルコールバックが使用されま
			す。2つの引数はチャンネルとメッセージです。

						*job-err_cb* *err_cb*
"err_cb": handler	stderr で読み込むべきものがあるときのコールバック。チャ
			ンネルがパイプを使用している場合のみ。"err_cb" が設定
			されていない場合は、チャンネルコールバックが使用されま
			す。2つの引数はチャンネルとメッセージです。
						*job-close_cb*
"close_cb": handler	チャンネルが閉じられるときのコールバック。
			|ch_open()| の "close_cb" と同じです。|close_cb| 参照。
						*job-exit_cb*
"drop"			メッセージをいつドロップするかを指定します。
			|ch_open()| の "drop" と同様(|channel-drop| 参照)。
			"auto" の場合、exit_cb は考慮されません。

"exit_cb": handler	ジョブが終了したときのコールバック。引数はジョブと終
			了ステータスです。
			Vim は、終了したジョブに対して最大10回/秒をチェックし
			ます。チェックは、|job_status()| を呼び出すことによっ
			てトリガーすることもでき、exit_cb ハンドラを呼び出すこ
			とができます。
			データがバッファリングされ、プロセスが終了した後もコー
			ルバックが呼び出されることに注意してください。
							*job-timeout*
"timeout"		ブロッキング時にリクエストを待つ時間(例: ch_evalexpr()
			を使用するとき。ミリ秒単位。デフォルトは2000(2秒)です。
						*out_timeout* *err_timeout*
"out_timeout"		stdout のタイムアウト。パイプ使用時のみ。
"err_timeout"		stderr のタイムアウト。パイプ使用時のみ。
			Note: "timeout" を設定すると、パーツ固有のモードが上書
			きされます。したがって、最初に "timeout" を設定し、後
			でパーツ固有のモードを設定します。

						*job-stoponexit*
"stoponexit": {signal}	Vim が終了すると {signal} をジョブに送ります。可能な値
			については、|job_stop()| 参照。
"stoponexit": ""	Vim が終了してもジョブを停止しません。
			デフォルトは "term" です。

						*job-term*
"term":"open"		ターミナルを起動し、ジョブ stdin/stdout/stderr を接続
			します。
			NOTE: まだ実装されていません!

"channel": {channel}	新しいチャンネルを作成する代わりに、既存のチャンネルを
			使用します。新しいジョブに使用されるチャンネルの部分
			は、以前使用された部分から切り離されます。チャンネル
			が別のジョブで引き続き使用されていた場合、I/O エラーが
			発生する可能性があります。
			既存のコールバックやその他の設定が残っています。

				*job-in_io* *in_top* *in_bot* *in_name* *in_buf*
"in_io": "null"		stdin を切断する(/dev/null から読み込む)
"in_io": "pipe"		標準入力がチャンネルに接続されている(デフォルト)
"in_io": "file"		stdin はファイルから読み込む
"in_io": "buffer"	stdin はバッファから読み込む
"in_top": number	"buffer" を使用する場合: 送信する最初の行(デフォルト:1)
"in_bot": number	"buffer" を使用する場合: 送信する最後の行(デフォルト:
			最後)
"in_name": "/path/file"	読み込むファイルまたはバッファの名前
"in_buf": number	読み込むバッファの番号

				*job-out_io* *out_name* *out_buf*
"out_io": "null"	stdout を切断する(/dev/nullに行く)
"out_io": "pipe"	stdout がチャンネルに接続されている(デフォルト)
"out_io": "file"	stdout がファイルに書き込む
"out_io": "buffer"	stdout はバッファに追加する(下記参照)
"out_name": "/path/file" 書き込むファイルまたはバッファの名前
"out_buf": number	書き込むバッファの番号
"out_modifiable": 0	バッファに書き込むときに、'modifiable' はオフになる
			(下記参照)
"out_msg": 0		新しいバッファに書き込むとき、最初の行は "Reading from
			channel output..." に設定される

				*job-err_io* *err_name* *err_buf*
"err_io": "out"		stderr のメッセージは stdout に行く
"err_io": "null"	stderr を切断する(/dev/nullに行く)
"err_io": "pipe"	stderr がチャンネルに接続されている(デフォルト)
"err_io": "file"	stderr はファイルに書き込む
"err_io": "buffer"	stderr はバッファに追加する(下記参照)
"err_name": "/path/file" 書き込むファイルまたはバッファの名前
"err_buf": number	書き込むバッファの番号
"err_modifiable": 0	バッファに書き込むときに、'modifiable' はオフになる
			(下記参照)
"err_msg": 0		新しいバッファに書き込むとき、最初の行は "Reading from
			channel error..." に設定される

"block_write": number	テストのためにのみ: stdin への他のすべての書き込みをブ
			ロックするふりをする


バッファへの書き込み ~
							*out_io-buffer*
out_io または err_io モードが "buffer" で、コールバックがある場合、コールバッ
クを呼び出す前にテキストがバッファに追加されます。

入力と出力の両方にバッファが使用されている場合、最後の行はチャンネル入力に書き
込まれたものなので、出力行は最後の行の上に置かれます。それ以外の場合は最後の行
の下に行が追加されます。

"buffer" を指定して JS または JSON モードを使用すると、デコード+エンコーディン
グ後に、ゼロまたは負の ID を持つメッセージのみがバッファに追加されます。正の数
を持つメッセージはコールバックによって処理され、コマンドは通常通り処理されま
す。

"out_name" または "err_name" のバッファ名は、現在のディレクトリの名前を拡張し
た後も、既存のバッファの完全名と比較されます。たとえば、":edit somename" でバッ
ファが作成され、バッファ名が "somename" の場合、そのバッファが使用されます。

一致するバッファがない場合、新しいバッファが作成されます。新しいバッファを常に
作成するには、空の名前を使用します。|ch_getbufnr()| を使用してバッファ番号を
取得できます。

新しいバッファの場合、'buftype' は "nofile" に設定され、'bufhidden' は "hide"
に設定されます。他の設定が必要な場合は、まずバッファを作成し、バッファ番号を渡
します。
					*out_modifiable* *err_modifiable*
"out_modifiable" と "err_modifiable" オプションは、 'modifiable' オプションを
オフにするか、 'modifiable' になっているバッファに書き込むために使用できます。
つまり、行がバッファに追加されますが、ユーザーはバッファを簡単に変更できませ
ん。
					*out_msg* *err_msg*
"out_msg" オプションは、新しいバッファが最初の行を "Reading from channel
output..." に設定するかどうかを指定するために使用できます。デフォルトではメッ
セージを追加します。"err_msg" はチャンネルエラーでも同じです。

'modifiable' オプションをオフにしたり、'modifiable' オフなバッファを書き込んだ
りすることができます。つまり、行がバッファに追加されますが、ユーザーはバッファ
を簡単に変更できません。

既存のバッファに 'modifiable' が指定されておらず、"out_modifiable" または
"err_modifiable" オプションがゼロでない場合、エラーが発生し、バッファに書き込
まれません。

書き込まれたバッファがウィンドウに表示され、カーソルが最後の行の最初の列にある
場合、カーソルは新しく追加された行に移動され、ウィンドウは必要に応じてカーソル
を表示するために上にスクロールされます。

追加されたすべての行に対して、取り消しが同期されます。NUL バイトは受け入れら
れます(内部では Vim はこれらを NL バイトとして格納します)。


ファイルへの書き込み ~
							*E920*
ファイルはアクセス許可600(ユーザーに対しては読み書き可能、他のユーザーはアクセ
ス不可)で作成されます。これを変更するには、|setfperm()| を使用してください。

ファイルがすでに存在する場合は切り捨てられます。

==============================================================================
11. ジョブを制御する					*job-control*

ジョブの状態を取得するには: >
	echo job_status(job)

ジョブの実行を停止するには: >
	job_stop(job)

これはジョブを終了させる通常の方法です。Unix では、ジョブに SIGTERM を送信し
ます。他の方法でジョブを停止したり、任意の信号を送信したりすることもできます。
例えば、ジョブを強制的に停止させるには、 "kill it": >
	job_stop(job, "kill")

他のオプションについては、|job_stop()| 参照。


 vim:tw=78:ts=8:ft=help:norl:
