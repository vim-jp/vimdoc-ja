*fold.txt*      For Vim バージョン 9.1.  Last change: 2024 Dec 17


		VIMリファレンスマニュアル    by Bram Moolenaar


折り畳み(Folding)					*Folding* *folding* *folds*

ユーザーマニュアルの28章に折り畳みについての紹介がされている。|usr_28.txt|

1. 折り畳み方法		|fold-methods|
2. 折り畳みコマンド	|fold-commands|
3. 折り畳みオプション	|fold-options|
4. 折り畳みの振舞	|fold-behavior|

{|+folding| 機能無しでコンパイルした場合には利用できない}

==============================================================================
1. 折り畳み方法					*fold-methods*

折り畳みを行う方法は 'foldmethod' オプションで設定できる。

'foldmethod' を "manual" 以外の値に設定すると、存在している折り畳みは全て削除
され新たな折り畳みが作成される。"manual" に切換えた時には既存の折り畳みは削除
されない。これを利用すればまず自動的に折り畳みを定義し、それから手動で変更する
ことが可能である。

折り畳み方法は6つの中から選択できる:
	manual		手動で折り畳みを定義する
	indent		インデントの数を折り畳みのレベル(深さ)とする
	expr		折り畳みを定義する式を指定する
	syntax		構文強調により折り畳みを定義する
	diff		変更されていないテキストを折り畳み対象とする
	marker		テキスト中の印で折り畳みを定義する


☆手動						*fold-manual*

折り畳み領域を定義するためにコマンドを手動で利用する。これはテキスト中の折り畳
みを行う箇所をスクリプトにより解析するのに使うこともできる。

折り畳みのレベルは折り畳みの入れ子の深さとなる。ある行範囲の折り畳みレベルを増
やすには、折り畳みがある同じ範囲に対して再び折り畳みを設定する。

手動折り畳みはファイルを放棄すると失われる。折り畳みを保存するには|:mkview|コ
マンドを使用する。後に復元するには|:loadview|を使用する。


☆インデント					*fold-indent*

折り畳みは各行のインデントにより自動的に定義される。

折り畳みレベルは各行のインデント量を、'shiftwidth' で割る(端数切捨て)ことで計
算される。同じかより高い折り畳みレベルを持った一続きの範囲は1つの折り畳みを形
成し、より高いレベルを持った範囲はその中で入れ子の折り畳みとなる。

折り畳みの入れ子は 'foldnestmax' によって制限される。

ある行ではインデントを無視して直ぐ上か下の行のうち、低いほうの折り畳みレベルが
使用される。無視されるのは完全な空行か、空白文字だけからなる行、および
'foldignore' の文字で始まる行である。'foldignore' の文字の前に空白文字があって
も無視される。Cではプリプロセッサー行を無視するために "#" を使用する。

他の方法で無視する行を定義するには、"expr" の方法を使用する。'foldexpr' の中
で、ある行のインデントを取得するのに、関数|indent()|を使うことができる。


☆式							*fold-expr*

折り畳みは "indent" 方式のように、折り畳みレベルによって自動的に定義される。
'foldexpr' オプションの値は、各行についてこの折り畳みレベルを計算するためにス
クリプトとして実行される。例:
タブで始まる一連の行範囲を1つの折り畳みにまとめる: >
	:set foldexpr=getline(v:lnum)[0]==\"\\t\"
空行で仕切られた「段落」を折り畳みとする: >
    :set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
同じ事(「段落」を折り畳みに)をする別の表現: >
    :set foldexpr=getline(v:lnum-1)=~'^\\s*$'&&getline(v:lnum)=~'\\S'?'>1':1

Note バックスラッシュ (日本では \ 記号) が ":set" の流儀で、通常とは異なるキャ
ラクタ (空白文字、バックスラッシュ、ダブルクォート、その他、詳細は
|option-backslash| 参照) をエスケープしていることに注意。

最も効果的なのはコンパイル済み関数を引数なしで呼ぶ: >
	:set foldexpr=MyFoldLevel()
関数は v:lnum を使用しなくてはいけない。|expr-option-function| を参照。

式が評価される際の前提条件は以下の通り:

- その行について現在のバッファとウィンドウが常に存在している。
- 変数 "v:lnum" には評価対象となる行番号が設定されている。

foldexpr の結果によって、以下のように折り畳みレベルが決定される:
  値			意味 ~
  0			対象行は折り畳みに含まれない
  1, 2, ..		対象行はこのレベルの折り畳みに含まれる
  -1			折り畳みレベルを未定義とし、対象行の直前か直後の行のう
			ち低い方を、対象行のレベルとする。
  "="			直前の行と同じレベルを使用する
  "a1", "a2", ..	直前の行のレベルを+1, +2して、結果を現在の行に適用す
			る。
  "s1", "s2", ..	直前の行のレベルを-1, -2して、結果を現在の行に適用す
			る。
  "<1", "<2", ..	指定したレベルの折り畳みを対象行で終了する
  ">1", ">2", ..	指定したレベルの折り畳みを対象行から開始する

結果の値 "="、"s" および "a" はより高価である。|fold-expr-slow| を参照。

折り畳みは直前の行の折り畳みレベルより高い(低い)行から開始(終了)されるので、折
り畳みの開始 (終了)マーク ">1" ("<1") は明示的に指定する必要は無い。

式に副作用があってはならない。バッファ内のテキストや、カーソルの位置や、検索パ
ターン、オプションその他。どれひとつ変更してはならない。
ただし、注意深く行えば、変更してもそれを復元しておけばよい。

式にエラーがあるか、結果が認識できない時には、何のエラーメッセージも表示せずに
折り畳みレベルは0に設定される。'debug' オプションに "msg" を設定すれば、エラー
メッセージが表示されるようになるので、デバッグに利用できる。

'foldexpr' の式が s: か |<SID>| で始まる場合、スクリプトID(|local-function|)
に置き換えられる。例: >
		set foldexpr=s:MyFoldExpr()
		set foldexpr=<SID>SomeFoldExpr()
<
"a1" と "s1" の使用例: C 言語の複数行コメントを折りたたむ場合、"/*" を含む行で
は "a1" を返してその開始位置を、"*/" を含む行では "s1" を返してその終了位置を
示す: >
  if match(thisline, '/\*') >= 0
    return 'a1'
  elseif match(thisline, '\*/') >= 0
    return 's1'
  else
    return '='
  endif
ただし、単一行コメント内、文字列リテラル内などではこれは正しく機能しない。

フォールドレベルを調べるには|foldlevel()|を使うのが便利である。レベルがわから
ないときは-1を返すことに注意すること。フォールドがその行で終わっているときには
行頭のレベルを返す。

折り畳みが適切に更新されない場合がある。その場合は |zx| か |zX| を使って強制的
に更新すること。

☆計算コストの最小化					*fold-expr-slow*

この折り畳み方式は計算コストが高いため、特にすべての行の折り畳みレベルを最初に
計算する必要がある場合、Vim が応答しなくなる可能性がある。
その後、各変更の後に Vim は折り畳みレベルの計算を折り畳みレベルが影響を受けた
行に制限する (他のすべての行の既知の折り畳みレベルを再利用する)。

したがって、折り畳み式は特定の行の計算に必要な依存行の数を最小限に抑えるように
努める必要がある。例えば、独立した折り畳みレベルが見つかるまで前の行の折り畳み
レベルの評価が必要になるため、"="、"a" および "s" の戻り値を避けるようにするこ
と。

これが難しい場合は、次善策として |b:changedtick| でのみ更新されるバッファロー
カル変数 (b:foldlevels) にすべての折り畳みレベルをキャッシュすることが考えられ
る:
>vim
  vim9script
  def MyFoldFunc(): number
    if b:lasttick == b:changedtick
      return b:foldlevels[v:lnum - 1]
    endif
    b:lasttick = b:changedtick
    b:foldlevels = []
    # compute foldlevels ...
    return b:foldlevels[v:lnum - 1]
  enddef
  set foldexpr=s:MyFoldFunc()
<
上記の例では、プリコンパイルされた引数なしの Vim9 script 関数を使用することで、
さらに高速化された (それでも v:lnum を使用する必要がある)。
|expr-option-function| を参照。

☆構文						*fold-syntax*

折り畳みが "fold" 引数を持つ構文要素によって定義される。 |:syn-fold|

折り畳みレベルは入れ子によって定義される。入れ子の深さは 'foldnestmax' によっ
て制限される。

シンタックスの同期の設定に注意すること。これが正しく設定されていないとフォール
ドが間違ったハイライトで表示される。これは特に複数行にマッチするシンタックスで
問題になる。そのようなときには次のような力技がある: >
	:syn sync fromstart


☆差分						*fold-diff*

テキストの変更された箇所とその近辺以外が自動的に折り畳みとして定義される。

この方法は現在のウィンドウに対して 'diff' オプションが設定されている時にだけ正
しく働き、変更点が表示される。そうでない場合バッファ全体が1つの大きな折り畳み
となる。

コンテキスト(の行数)を指定するのに 'diffopt' を使うことができる。これにより変
更点の近辺の折り畳みに含まない行数を指定できる。下の例では8行表示するように設
定している: >
	:set diffopt=filler,context:8
省略した場合には6行が表示される。

'scrollbind' が設定されているとき、Vimは他のウィンドウと見た目が同じになるよう
にフォールドを開いた状態に保とうとする。

☆印						*fold-marker*

テキスト中の印により折り畳みの開始と終了地点を指定する。これにより明確に折り畳
みを設定することができる。また誤った行を含むことなく、折り畳みを削除・設定でき
る。通常 'foldtext' オプションは折り畳みの行に表示されるテキストとして、印の直
前のテキスト設定する。これにより折り畳みに名前を設定することが可能になる。

印には折り畳みレベルを含むことができ、また開始と終了で対になる文字を使うことも
できる。必ずしも終了の印を加える必要はなく、また対がない印が無い場合の問題も避
けられるので、レベルを含んだほうがより簡単である。例: >
	/* グローバル変数 {{{1 */
	int varA, varB;

	/* 関数 {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
<							*{{{* *}}}*
折り畳みは印 "{{{" で開始する。印の後ろの番号は折り畳みレベルを示す。現在の折
り畳みレベルと異なるレベルが印によって与えられた時に何が起こるかは、そのレベル
の差に依存する:
1. 同じ折り畳みレベルの印が与えられた時には、前の折り畳みは終了し同じレベルの
   新たな折り畳みが開始する。
2. 高い折り畳みレベルの印を見つけた時には、入れ子の折り畳みが開始する。
3. 低い折り畳みレベルの印を見つけた時には、指定されたレベル以上の全部の折り畳
   みを終了し、指定されたレベルで新たな折り畳みが開始する。

番号は折り畳みレベルを示す。0を使うことはできない(レベル0の印は無視される)。特
定のレベルの折り畳みを終了させるため "}}}" 数字を付けて使うことができる。その
印の直後の行の折り畳みレベルは示されたレベルよりも1つだけ低くなる。Vimは指定さ
れたレベルにマッチする印を検索はしないことに注意(計算に時間がかかりすぎてしま
うので)。例: >

	{{{1
	ここからレベル1の折り畳み
	{{{3
	ここからレベル3の折り畳み
	}}}3
	ここからレベル2の折り畳み

折り畳みを定義するのに対になる "{{{" と "}}}" を使用することもできる。折り畳み
レベルは "{{{" 1つにつき1ずつ増加し、"}}}" 1つにつき1ずつ減少する。印同士の対
応関係を維持するように気をつけること! 例: >

	{{{
	ここからレベル1の折り畳み
	{{{
	ここからレベル2の折り畳み
	}}}
	ここからレベル1の折り畳み

番号付きの印と番号無しの印を混ぜて使用することもできる。大きな折り畳みには番号
付きの印を使用し、関数中の小さな折り畳みなどには番号無しの印を使うと便利だろ
う。一例を挙げれば、ファイルの "構造体定義" や "ローカル変数" それから "関数定
義" のような部分にはレベル1(番号付き)の折り畳みを使用する。そして一つ一つの定
義や関数実装にはレベル2の折り畳みを使用し、関数内部(例えばあるブロックなど)に
は番号無しの印を使用する。こうしておけば関数の中で折り畳みを分割するような変更
を行う時に、印にレベルを付け直す必要はなくなる。

印は 'foldmarker' オプションにより変更できる。Vimユーザー間でファイルを交換で
きるようにするためには、このオプションのデフォルトである "{{{,}}}" は変更しな
いことが推奨される。ファイルによってそれがどうしても必要な時(例えば別のエディ
タで作成した折り畳みを示す異なる印を含んでいる時や、ファイル内容の制約によりデ
フォルトの印が問題を起こすため、それを使うことができない場合)にだけ変えるよう
に。

							*fold-create-marker*
印による折り畳みを作成するのに "zf" コマンドを使用することができる。Vimがユー
ザーに代わって印を挿入する。Vimは 'foldmarker' で指定された開始の印と終了の印
を追加する。印は行末に追加される。'commentstring' が空でなければそれが使用され
る。これは次のような時には正しく働かない:
- 既に番号付き折り畳みが含まれている。Vimはそれをどのように扱えば良いか知らな
  い。
- 番号付き折り畳みの近くで、それらの印が邪魔になる場合。
- 行がコメントの中で、'commentstring' が空ではなく、かつ入れ子コメントを使用で
  きない場合。例えばC言語: /* {{{ */ を既に存在するコメントを消さずにその中に
  追加するようなこと。コメントの直前か直後に印を設定するか、もしくは手動で印を
  追加する必要がある。
一般的に、既に番号付き折り畳みが存在する場合には、Vimに印を作成させるのは良い
アイデアではない。

							*fold-delete-marker*
印による折り畳みを削除するのに "zd" コマンドを使用することができる。Vimがユー
ザーに代わって印を削除する。Vimは 'foldmarker' で指定された開始の印と終了の印
を検索する。印の周りにある 'commentstring' に適合するテキストは可能な限り削除
される。
これは次のような時には正しく働かない:
- ある行に印が1つ以上含まれていて、そのうち少なくとも1つがレベルを指定している
  場合。折り畳みを削除することで期待される効果どうりになるかどうかはチェックさ
  れることなく、単に初めの折り畳みが1つ削除される。
- 番号付き印で、複数の折り畳みを同時に開始したり終了するために使用されている場
  合。

==============================================================================
2. 折り畳みコマンド					*fold-commands* *E490*

全ての折り畳みコマンドは "z" で始まっている。ヒント: "z" は紙片を折った様子を
横からみた姿に見える。


折り畳みの作成と削除 ~
							*zf* *E350*
zf{motion}  or
{Visual}zf	折り畳みを作成する操作。
		'foldmethod' が "manual" か "marker" の時だけ動作する。
		"manual" の時には新しい折り畳みは閉じられる。
		'foldenable' がセット(有効化)される。
		|fold-create-marker|も参照。

							*zF*
zF		[count]行を折り畳みとして作成する。"zf" と同じように動作する。

:{range}fo[ld]						*:fold* *:fo*
		{range}で示された範囲を折り畳みにする。"zf" と同様に動作する。

							*zd* *E351*
zd		カーソルの位置にある折り畳みを1つ削除する。カーソルが折り畳み
		になっている行にある場合には、その折り畳みが削除される。入れ子
		になった折り畳みは1レベル分が削除される。ビジュアルモードでは
		選択された範囲の全ての折り畳み(partially)の1レベル分が削除され
		る。
		注意: これは期待したよりも余計に折り畳みを削除し易く、また手動
		折り畳みに対してはアンドゥもできないので注意が必要。
		'foldmethod' が "manual" か "marker" の時だけ動作する。
		|fold-delete-marker|も参照。

							*zD*
zD		カーソルの位置の折り畳みを再帰的に削除する。ビジュアルモードで
		は、選択された範囲内の入れ子も含め全ての折り畳み(partially)が
		削除される。
		'foldmethod' が "manual" か "marker" の時だけ動作する。
		|fold-delete-marker|も参照。

							*zE* *E352*
zE		ウィンドウにある全ての折り畳みを削除する。
		'foldmethod' が "manual" か "marker" の時だけ動作する。
		|fold-delete-marker|も参照。


折り畳みを開く・閉じる ~

'foldminlines' よりも少ない行数の折り畳みは常に開いたように表示される。従って
以下のコマンドは小さな折り畳みに関しては異なった働きを持つ。

							*zo*
zo		カーソルの下の折り畳みを一段階開く。カウントが与えられた場合に
		は、複数の深さの折り畳みが開かれる。ビジュアルモードでは、選択
		された範囲にある全ての折り畳みが1レベル開かれる。

							*zO*
zO		カーソルの下の折り畳みを再帰的に全て開く。カーソルのある行を含
		まない折り畳みは変更されない。
		ビジュアルモードでは、選択された範囲の全ての折り畳みが、部分的
		に選択されていただけでも全て完全に開かれる。

							*zc*
zc		カーソルの下の折り畳みを一段階閉じる。カウントが与えられた場合
		には、複数の深さの折り畳みが閉じられる。ビジュアルモードでは、
		選択された範囲にある全ての折り畳みが1レベル閉じられる。
		'foldenable' がセット(有効化)される。

							*zC*
zC		カーソルの下の折り畳みを再帰的に全て閉じる。カーソルのある行を
		含まないフォールドは変更されない。
		ビジュアルモードでは、選択された範囲の全ての折り畳みが、部分的
		に選択されていただけでも全て完全に閉じられる。'foldenable' が
		セット(有効化)される。

							*za*
za		概要: カーソルの下にある折り畳みをトグルする。
		折り畳みが閉じていた場合: それを開く。折り畳みが入れ子になって
		いる時には、"za" を何度も使う必要がある。カウントが与えられた
		場合には、複数の閉じられた折り畳みが開かれる。
		折り畳みが開いていた場合: それを閉じ 'foldenable' をセットす
		る。繰り返し使っても閉じた折り畳みが開くだけだから、これは1レ
		ベル開くだけである。カウントが与えられた場合には、複数の折り畳
		みが閉じられる (これは "za" を複数回繰り返した場合の動作と同じ
		ではない)。

							*zA*
zA		折り畳みが閉じていた場合: 再帰的に開く。
		折り畳みが開いていた場合: 再帰的に閉じ 'foldenable' をセットす
		る。

							*zv*
zv		カーソル行を表示する: カーソルのある行がちょうど表示されるレベ
		ルまで折り畳みを開く。

							*zx*
zx		折り畳みを更新する: 手動で行った折り畳みの開閉操作をアンドゥす
		る:
		'foldlevel' を再適用し、"zv" を行う: カーソル行を表示する。
		折り畳みの計算を強制するのにも使える。これは 'foldexpr' を使っ
		ていてバッファが変更されたにもかかわらず折り畳みが適切に更新さ
		れないような場合に便利である。

							*zX*
zX		手動で行った折り畳みの開閉操作をアンドゥする: 'foldlevel' を再
		適用する。
		折り畳みの計算を強制するのにも使える (|zx| と同様)。

							*zm*
zm		折り畳みをより閉じる: 'foldlevel' を |v:count1| 減少させる。
		'foldlevel' が既に0ならば何も起こらない。
		'foldenable' がセット(有効化)される。

							*zM*
zM		全ての折り畳みを閉じる: 'foldlevel' に0を設定する。
		'foldenable' がセット(有効化)される。

							*zr*
zr		折り畳みをより開く: 'foldlevel' を |v:count1| 増加させる。

							*zR*
zR		全ての折り畳みを開く: 'foldlevel' に最大の折り畳みレベルを設定
		する。

							*:foldo* *:foldopen*
:{range}foldo[pen][!]
		{range}の範囲の折り畳みを開く。[!]が付け加わると全ての折り畳み
		が開かれる。{range}範囲内の全てのテキストを見るのに役立つ。[!]
		が無い時は1レベル分の折り畳みが開かれる。

							*:foldc* *:foldclose*
:{range}foldc[lose][!]
		{range}の範囲の折り畳みを閉じる。[!]が付け加わると全ての折り畳
		みが閉じられる。{range}範囲内の全てのテキストを隠すのに役立つ。
		[!]が無い時は1レベル分の折り畳みが閉じられる。

							*zn*
zn		折り畳みしない: 'foldenable' をリセットする。全ての折り畳みが
		開かれる。

							*zN*
zN		折り畳みする: 'foldenable' をセットする。全ての折り畳みが
		'foldenable' がリセットされる以前と同様になる。

							*zi*
zi		'foldenable' を反転する。


折り畳みを超えて移動する ~
							*[z*
[z		現在の開いている折り畳みの先頭へ移動する。既に先頭にいるのなら
		ば、それを含む外側の折り畳みの先頭へ移動する。外側の折り畳みが
		無い場合は、コマンドは失敗する。
		カウントが与えられた場合には、[count]回繰り返される。

							*]z*
]z		現在の開いている折り畳みの末尾へ移動する。既に末尾にいるのなら
		ば、それを含む外側の折り畳みの末尾へ移動する。外側の折り畳みが
		無い場合は、コマンドは失敗する。
		カウントが与えられた場合には、[count]回繰り返される。

							*zj*
zj		カーソルより下方の折り畳みへ移動する。閉じられた折り畳みが1つ
		の折り畳みとして数えられる。
		カウントが与えられた場合には、[count]回繰り返される。
		このコマンドは|operator|の後に使うことができる。

							*zk*
zk		カーソルより上方の折り畳みへ移動する。閉じられた折り畳みが1つ
		の折り畳みとして数えられる。
		カウントが与えられた場合には、[count]回繰り返される。
		このコマンドは|operator|の後に使うことができる。


折り畳みに対してコマンドを実行する ~

:[range]foldd[oopen] {cmd}		*:foldd* *:folddo* *:folddoopen*
		閉じた折り畳みの中以外の全ての行に対して{cmd}を実行する。
		[range]が与えられた時は、その範囲だけが対象となる。
		コマンドが各行に対して実行される時にはカーソルはその対象となる
		行に置かれている。
		これは ":global" コマンドのように動作する: まず閉じられた折り
		畳みに入っていない全ての行がマークされる。それからマークされた
		全ての行に対して{cmd}が実行される。だから{cmd}が折り畳みに対し
		て変更を加えても、コマンドの実行には影響が無い(もちろん行が消
		された時は除く)。
		例: >
			:folddoopen s/end/loop_end/ge
<		"e" フラグには "end" がマッチしなかった時にエラーメッセージが
		表示させない効果がある。

:[range]folddoc[losed] {cmd}			*:folddoc* *:folddoclosed*
		閉じた折り畳みの中にある全ての行に対して{cmd}を実行する。
		その他は ":folddoopen" と同じ。

==============================================================================
3. 折り畳みオプション				*fold-options*

☆色							*fold-colors*

閉じられた折り畳みの色はFoldedグループによって設定される|hl-Folded|。折り畳み
表示カラムの色はFoldColumnグループによって設定される|hl-FoldColumn|。
色の設定例: >

	:highlight Folded guibg=grey guifg=blue
	:highlight FoldColumn guibg=darkgrey guifg=white


☆折り畳みレベル					*fold-foldlevel*

'foldlevel' は数を設定するオプションである: 大きな数を設定するとより多くの折り
畳みが開かれる。
'foldlevel' が0の時には、全ての折り畳みが閉じられる。
'foldlevel' が正の時には、幾つかの折り畳みが閉じられる。
'foldlevel' が非常に大きい時は、全ての折り畳みが開かれる。
'foldlevel' は変更された時に適用される。その後に手動で折り畳みを開いたり閉じた
りできる。
値を増やした時には、新しいレベルの値以上の折り畳みが開かれる。手動で開かれてい
た折り畳みは閉じられない。
値を減らした時には、新しいレベルの値以上の折り畳みが閉じられる。手動で閉じられ
ていた折り畳みは開かれない。


☆折り畳みテキスト     					*fold-foldtext*

'foldtext' は式を指定する文字列オプションである。この式は閉じられた折り畳みを
示すテキストを得るために評価実行される。例: >

    :set foldtext=v:folddashes.substitute(getline(v:foldstart),'/\\*\\\|\\*/\\\|{{{\\d\\=','','g')

これは折り畳みの最初の1行を、"/*" と "*/" を追加し "{{{" を削除して表示する。
多めのバックスラッシュ(\ 記号)はある文字が ":set" コマンドに解釈されてしまうの
を避けるために使用されている。これは以下のように関数を定義すると最も簡単になる:
>

    :set foldtext=MyFoldText()
    :function MyFoldText()
    :  let line = getline(v:foldstart)
    :  let sub = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')
    :  return v:folddashes .. sub
    :endfunction

引数なしでの関数呼び出しを使用する利点は高速なことである、
|expr-option-function| を参照のこと。

'foldtext' は|sandbox|環境下で実行評価される。現在のウィンドウはそのラインの属
するウィンドウへ設定される。コンテキストはオプションを最後に設定したスクリプト
のものが設定される。

エラーは無視される。デバッグする際は、オプション 'debug' に "throw" を設定す
る。

省略値は|foldtext()|である。これはほとんどのタイプの折り畳みに対して妥当なテキ
ストを返す。それが気に入らないのならば、独自の式を 'foldtext' に設定することが
できる。その式中では以下の特別なVim変数を使用することができる:
	v:foldstart	折り畳みの先頭の行番号
	v:foldend	折り畳みの末尾の行番号
	v:folddashes	折り畳みレベルを表現したダッシュ(-)記号の文字列。
	v:foldlevel	折り畳みのレベル

結果の文字列中のタブ文字は1つの空白文字に置き換えられ、表示不可能な文字は表示
可能な文字に作り変えられる。

結果の文字列はウィンドウに合うように切り捨てられ、折り返されることはない。
テキストの後ろに余白があれば、'fillchars' で指定された文字で充たされる。

'foldtext' の式が s: か |<SID>| で始まる場合、スクリプトID(|local-function|)
に置き換えられる。例: >
		set foldtext=s:MyFoldText()
		set foldtext=<SID>SomeFoldText()
<
":set" コマンドが解釈してしまう文字: 空白、バックスラッシュ (\ 記号) そしてダ
ブルクォートを使う場合にはバックスラッシュが必要である。 |option-backslash|


☆折り畳み表示カラム					*fold-foldcolumn*

'foldcolumn' は、ウィンドウの端に確保される折り畳みを示すカラムの幅を指定する
数。0 ならば、折り畳み表示カラムは確保されない。通常は4から5が一般的。使い物に
なる最小値は2であるが、1にしてもいくらかの情報を提供する。最大値は12。

折り畳み表示カラムには、開いた折り畳みの先頭に '-' が続いて '|' が表示される。
このカラムは開いた折り畳みが終了した位置で終了する。入れ子になった折り畳みで
は、それを含む折り畳みの1つ左側に表示される。

閉じた折り畳みは '+' で表示される。

これらの文字は、'fillchars' オプションを使用して変更できる。

全ての折り畳みを表示できないほど折り畳み表示カラムが狭いときには、入れ子のレベ
ルが数字で表示される。

折り畳み表示カラムをクリックすることで、マウスにより折り畳みを開閉することがで
きる:
- 閉じた折り畳みを開くにはその行の '+' をクリックする。
- 開いた折り畳みを閉じるにはそれ以外の非空白文字をクリックする。


☆その他のオプション

'foldenable'  'fen':	無効に設定すると全ての折り畳みが開く。
'foldexpr'    'fde':	式("expr')による折り畳みで使用される。
'foldignore'  'fdi':	インデントによる折り畳みで使用される。
'foldmarker'  'fmr':	印による折り畳みで使用される印を定義する。
'foldmethod'  'fdm':	現在の折り畳み方法の名称。
'foldminlines' 'fml':	閉じた状態で表示されるべき折り畳みの、スクリーン上での
			最小行数
'foldnestmax' 'fdn':	インデント及び構文折り畳みでの最大入れ子数
'foldopen'    'fdo':	閉じている折り畳みを開くコマンドの種類
'foldclose'   'fcl':	カーソルの下ではない折り畳みをいつ閉じるか。

==============================================================================
4. 折り畳みの振舞						*fold-behavior*

カーソルを上下に移動させたりスクロールさせると、カーソルは一連の折り畳み行の先
頭へ移動する。カーソルが既に折り畳みの行にあれば、カーソルは次の折り畳みではな
い行か、閉じられた折り畳みへ移動する。

折り畳みの行にカーソルがある時には、カーソルは常に先頭のカラムに表示される。
ルーラーは実際のカーソルの位置を示すが、行が折り畳みの場合には、そこに実際に表
示することはできない。

移動コマンドは一連の折り畳みを空行として扱う。例えば、"w" コマンドは一旦先頭の
カラムで停止する。

閉じた折り畳み内から検索を開始した時は、現在の折り畳み内で検索がマッチしない。前
方検索は常に閉じた折り畳みの最後から始まり、後方検索では閉じた折り畳みの最初から
始まるようなものである。

挿入モードでは、カーソルのある行は決して折り畳みにならない。このため何を入力し
ているかわからなくなることはない!

オペレータを使用したときには、閉じた折り畳みは全体が含まれる。だから "dl" は
カーソルの下の閉じた折り畳みの全体を削除してしまう。

バッファの行に作用するExコマンドの作用範囲は、開始位置と終了位置ともに閉じられ
た折り畳みのそれらへ、それぞれ補正される。よって以下のコマンドを: >
	:s/foo/bar/g
閉じた折り畳みへカーソルを合わせて実行すると、折り畳み内の全ての行にある "foo"
が "bar" へ置き換えられてしまう。
これは|:folddoopen|と|:folddoclosed|に対してはあてはまらない。

(同一セッション中で)以前に編集したバッファに対しては、最後の折り畳み設定が再び
使用される。手動折り畳みでは以前に定義された折り畳みが復元される。全ての折り畳
み方法で、手動で開閉した折り畳みは復元される。同じウィンドウで同じバッファが編
集される時は、以前の編集時の値が使用される。そうでなければそのウィンドウで最後
に編集されていたバッファの値が使用される。

==============================================================================
 vim:tw=78:ts=8:noet:ft=help:norl:
