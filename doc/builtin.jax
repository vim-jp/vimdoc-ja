*builtin.txt*	For Vim バージョン 9.1.  Last change: 2024 Apr 04


		VIMリファレンスマニュアル    by Bram Moolenaar


組み込み関数					*builtin-functions*

Note: 式の評価はコンパイル時に無効することができる。その場合、組み込み関数は使
用できない。|+eval| と |no-eval-feature| を参照。

使用目的別に分類された関数については、|function-list| を参照。

1. 概要					|builtin-function-list|
2. 詳細					|builtin-function-details|
3. 機能リスト				|feature-list|
4. 文字列内でのパターンマッチング	|string-match|

==============================================================================
1. 概要						*builtin-function-list*

関数名の上でCTRL-]を使うことで、詳細な説明へ飛ぶことができる。

使用法				結果	説明	~

abs({expr})			浮動小数点数または数値	{expr}の絶対値
acos({expr})			浮動小数点数	{expr}のアークコサイン
add({object}, {item})		リスト/Blob	{item}を{object}に追加する
and({expr}, {expr})		数値	ビット論理積
append({lnum}, {text})		数値	{lnum}行目に{text}を付け加える
appendbufline({expr}, {lnum}, {text})
				数値	バッファ{expr}の{lnum}行目に{text}を付
					け加える
argc([{winid}])			数値	引数内のファイルの数
argidx()			数値	引数リスト内の現在のインデックス
arglistid([{winnr} [, {tabnr}]])
				数値	引数リストID
argv({nr} [, {winid}])		文字列	引数の第{nr}番目
argv([-1, {winid}])		リスト	引数リスト
asin({expr})			浮動小数点数	{expr}のアークサイン
assert_beeps({cmd})		数値	{cmd} がビープ音を鳴らすことをテストす
					る
assert_equal({exp}, {act} [, {msg}])
				数値	{exp}と{act}が等しいかどうかテストする
assert_equalfile({fname-one}, {fname-two} [, {msg}])
				数値	ファイルの内容が等しいことをテストする
assert_exception({error} [, {msg}])
				数値	|v:exception|が{error}であるかテストする
assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])
				数値	{cmd}が失敗するかどうかテストする
assert_false({actual} [, {msg}])
				数値	{actual}がfalseかどうかテストする
assert_inrange({lower}, {upper}, {actual} [, {msg}])
				数値	{actual}が範囲内にあるかテストする
assert_match({pat}, {text} [, {msg}])    数値  {pat}が{text}にマッチするかテス
					トする
assert_nobeep({cmd})		数値	{cmd} がビープ音を鳴らさないことをテス
					トする
assert_notequal({exp}, {act} [, {msg}])  数値  {exp}が{act}と等しくないことを
					テストする
assert_notmatch({pat}, {text} [, {msg}]) 数値  {pat}が{text}とマッチしないこと
					をテストする
assert_report({msg})		数値	テストの失敗を報告する
assert_true({actual} [, {msg}])
				数値	{actual}がtrueかどうかテストする
atan({expr})			浮動小数点数	{expr}のアークタンジェント
atan2({expr1}, {expr2})		浮動小数点数	{expr1} / {expr2} のアークタン
						ジェント
autocmd_add({acmds})		真偽値	自動コマンドとグループのリストを追加
autocmd_delete({acmds})		真偽値	自動コマンドとグループのリストを削除
autocmd_get([{opts}])		リスト	自動コマンドのリストを返す
balloon_gettext()		文字列	バルーン内のカレントテキストを得る
balloon_show({expr})		なし	{expr} をバルーン内に表示
balloon_split({msg})		リスト	{msg} をバルーンで使われるように分割す
					る
blob2list({blob})		リスト	{blob} を数値のリストに変換する
browse({save}, {title}, {initdir}, {default})
				文字列	ファイル選択ダイアログを表示
browsedir({title}, {initdir})	文字列	ディレクトリ選択ダイアログを表示
bufadd({name})			数値	バッファリストにバッファを追加する
bufexists({buf})		数値	バッファ{buf}が存在すれば|TRUE|
buflisted({buf})		数値	バッファ{buf}がリストにあるなら|TRUE|
bufload({buf})			数値	まだバッファ{buf}がロードされていなけ
					ればバッファをロードする
bufloaded({buf})		数値	バッファ{buf}がロード済みなら|TRUE|
bufname([{buf}])		文字列	バッファ{buf}の名前
bufnr([{buf} [, {create}]])	数値	バッファ{buf}の番号
bufwinid({buf})			数値	バッファ{buf}のウィンドウID
bufwinnr({buf})			数値	バッファ{buf}のウィンドウ番号
byte2line({byte})		数値	{byte}番目のバイトの行番号
byteidx({expr}, {nr} [, {utf16}])
				数値	{expr}の{nr}文字目のバイトインデックス
byteidxcomp({expr}, {nr} [, {utf16}])
				数値	{expr}の{nr}文字目のバイトインデックス
call({func}, {arglist} [, {dict}])
				任意	引数{arglist}をつけて{func}を呼ぶ
ceil({expr})			浮動小数点数	{expr} を切り上げる
ch_canread({handle})		数値	何か読むものがあるかをチェックする
ch_close({handle})		なし	{handle} を閉じる
ch_close_in({handle})		なし	{handle} の入力を閉じる
ch_evalexpr({handle}, {expr} [, {options}])
				任意	{handle} に {expr} を送り応答をJSONと
					して評価する
ch_evalraw({handle}, {string} [, {options}])
				任意	{handle} に {string} を送り応答を生の
					文字列として評価する
ch_getbufnr({handle}, {what})	数値	{handle}/{what} に割り当てられたバッ
					ファ番号を得る
ch_getjob({channel})		ジョブ	{channel} の Job を得る
ch_info({handle})		文字列	チャネル {handle} に関する情報を得る
ch_log({msg} [, {handle}])	なし	チャネルのログファイルに {msg} を書き
					込む
ch_logfile({fname} [, {mode}])	なし	チャネルの挙動ログ出力を開始する
ch_open({address} [, {options}])
				チャネル	{address} へのチャネルを開く
ch_read({handle} [, {options}]) 文字列	{handle} から読み込む
ch_readblob({handle} [, {options}])
				Blob	{handle} からBlobを読み込む
ch_readraw({handle} [, {options}])
				文字列	{handle} から生の文字列を読み込む
ch_sendexpr({handle}, {expr} [, {options}])
				任意	{expr}をJSONチャネル{handle}に送る
ch_sendraw({handle}, {expr} [, {options}])
				任意	{expr}をrawチャネル{handle}に送る
ch_setoptions({handle}, {options})
				なし	{handle}にオプションを設定する
ch_status({handle} [, {options}])
				文字列	チャネル{handle}の状態
changenr()			数値	現在の変更番号
char2nr({expr} [, {utf8}])	数値	{expr}の先頭文字のASCII/UTF-8コード
charclass({string})		数値	{string} の文字クラス
charcol({expr} [, {winid}])	数値	カーソルかマークのカラム番号
charidx({string}, {idx} [, {countcc} [, {utf16}]])
				数値	{string} のバイト {idx} の文字のイン
					デックス
chdir({dir})			文字列	現在の作業ディレクトリを変更する
cindent({lnum})			数値	{lnum}行目のCインデント量
clearmatches([{win}])		なし	全マッチをクリアする
col({expr} [, {winid}])		数値	カーソルかマークのカラムバイトインデッ
					クス
complete({startcol}, {matches})	なし	挿入モード補完を設定する
complete_add({expr})		数値	補完候補を追加する
complete_check()		数値	補完中に押されたキーをチェックする
complete_info([{what}])		辞書	現在の補完情報を取得
confirm({msg} [, {choices} [, {default} [, {type}]]])
				数値	ユーザーへの選択肢と番号
copy({expr})			任意	{expr}の浅いコピーを作る
cos({expr})			浮動小数点数	{expr} の余弦(コサイン)
cosh({expr})			浮動小数点数	{expr}のハイパボリックコサイン
count({comp}, {expr} [, {ic} [, {start}]])
				数値	 {comp}中に{expr}が何個現れるか数える
cscope_connection([{num}, {dbpath} [, {prepend}]])
				数値	cscope接続の存在を判定する
cursor({lnum}, {col} [, {off}])
				数値	カーソルを{lnum}, {col}, {off}へ移動
cursor({list})			数値	カーソルを{list}の位置へ移動
debugbreak({pid})		数値	デバッグするプロセスへ割り込む
deepcopy({expr} [, {noref}])	任意	{expr}の完全なコピーを作る
delete({fname} [, {flags}])	数値	ファイルやディレクトリ{fname}を消す
deletebufline({buf}, {first} [, {last}])
				数値	バッファ {buf} から行を削除する
did_filetype()			数値	FileTypeのautocommandが実行されたか?
diff({fromlist}, {tolist} [, {options}])
				リスト	2 つの文字列のリストの差分
diff_filler({lnum})		数値	差分モードで{lnum}に挿入された行
diff_hlID({lnum}, {col})	数値	差分モードで{lnum}/{col}位置の強調
digraph_get({chars})		文字列	{chars} のダイグラフ |digraph| を取得
digraph_getlist([{listall}])	リスト	すべてのダイグラフ |digraph| を取得
digraph_set({chars}, {digraph})	真偽値	ダイグラフ |digraph| の登録
digraph_setlist({digraphlist})	真偽値	複数のダイグラフ |digraph| の登録
echoraw({expr})			なし	{expr} をそのまま出力する
empty({expr})			数値	{expr}が空なら|TRUE|
environ()			辞書	すべての環境変数を返す
err_teapot([{expr}])		なし	{expr} が |TRUE| の場合、E418、または
					E503 を与える
escape({string}, {chars})	文字列	{string}内の{chars}を '\' でエスケープ
eval({string})			任意	{string}を評価し、値を得る
eventhandler()			数値	イベントハンドラの内側なら|TRUE|
executable({expr})		数値	実行可能な{expr}が存在するなら1
execute({command})		文字列	{command}を実行し、出力を得る
exepath({expr})			文字列	コマンド {expr} のフルパス
exists({expr})			数値	変数{expr}が存在したら|TRUE|
exists_compiled({expr})		数値	変数{var}がコンパイル時に存在したら|TRUE|
exp({expr})			浮動小数点数	{expr}の指数
expand({expr} [, {nosuf} [, {list}]])
				任意	{expr}内の特別なキーワードを展開
expandcmd({string} [, {options}])
				文字列	`:edit` のように{string}を展開
extend({expr1}, {expr2} [, {expr3}])
				リスト/辞書 {expr1}に{expr2}を要素として挿入
extendnew({expr1}, {expr2} [, {expr3}])
				リスト/辞書 |extend()| と同じだが新しいリスト/
				辞書を作る
feedkeys({string} [, {mode}])	数値	先行入力バッファにキーシーケンスを追加
filereadable({file})		数値	{file}が読み込み可能なら|TRUE|
filewritable({file})		数値	{file}が書き込み可能なら|TRUE|
filter({expr1}, {expr2})	リスト/辞書/Blob/文字列
					{expr2} が0となる要素を {expr1} からと
					り除く
finddir({name} [, {path} [, {count}]])
				文字列	{path}からディレクトリ{name}を探す
findfile({name} [, {path} [, {count}]])
				文字列	{path}からファイル{name}を探す
flatten({list} [, {maxdepth}])	リスト	リスト {list} を {maxdepth} の深さまで
					平坦化する
flattennew({list} [, {maxdepth}])
				リスト	{list} のコピーを平坦化する
float2nr({expr})		数値	浮動小数点数 {expr} を数値に変換する
floor({expr})			浮動小数点数	{expr} を切り捨てる
fmod({expr1}, {expr2})		浮動小数点数	{expr1} / {expr2} の余り
fnameescape({fname})		文字列	{fname} 内の特殊文字をエスケープする
fnamemodify({fname}, {mods})	文字列	ファイル名を変更
foldclosed({lnum})		数値	{lnum}の折り畳みの最初の行(閉じている
					なら)
foldclosedend({lnum})		数値	{lnum}の折り畳みの最後の行(閉じている
					なら)
foldlevel({lnum})		数値	{lnum}の折り畳みレベル
foldtext()			文字列	閉じた折り畳みに表示されている行
foldtextresult({lnum})		文字列	{lnum}で閉じている折り畳みのテキスト
foreach({expr1}, {expr2})	リスト/辞書/Blob/文字列
					{expr1} の各項目に対して {expr2} を呼
					び出す
foreground()			数値	Vimウィンドウを前面に移動する
fullcommand({name} [, {vim9}])	文字列	{name} から完全なコマンドを取得
funcref({name} [, {arglist}] [, {dict}])
				Funcref	関数{name}への参照
function({name} [, {arglist}] [, {dict}])
				Funcref	名前による関数{name}への参照
garbagecollect([{atexit}])	なし	メモリを解放する。循環参照を断ち切る
get({list}, {idx} [, {def}])	任意	{list}や{def}から要素{idx}を取得
get({dict}, {key} [, {def}])	任意	{dict}や{def}から要素{key}を取得
get({func}, {what})		任意	funcref/partial {func}のプロパティ取得
getbufinfo([{buf}])		リスト	バッファに関する情報
getbufline({buf}, {lnum} [, {end}])
				リスト	バッファ{buf}の{lnum}から{end}行目
getbufoneline({buf}, {lnum})	文字列	バッファ{buf}の{lnum}行目
getbufvar({buf}, {varname} [, {def}])
				任意	バッファ{buf}の変数 {varname}
getcellwidths()			リスト	文字のセル幅の上書き設定を取得
getchangelist([{buf}])		リスト	変更リスト要素のリスト
getchar([expr])			数値/文字列	ユーザーから1文字を取得する
getcharmod()			数値	修飾キーの状態を表す数値を取得
getcharpos({expr})		リスト	カーソル、マーク、その他のカーソル位置
getcharsearch()			辞書	最後の文字検索を取得
getcharstr([expr])		文字列	ユーザーから1文字を取得する
getcmdcompltype()		文字列	現在のコマンドライン補完のタイプを返す
getcmdline()			文字列	現在のコマンドラインを取得
getcmdpos()			数値	コマンドラインのカーソル位置を取得
getcmdscreenpos()		数値	コマンドラインのカーソルのスクリーン位
					置を返す
getcmdtype()			文字列	現在のコマンドラインの種類を取得
getcmdwintype()			文字列	現在のコマンドラインウィンドウの種類
getcompletion({pat}, {type} [, {filtered}])
				リスト	コマンドライン補完にマッチするリスト
getcurpos([{winnr}])		リスト	カーソルの位置
getcursorcharpos([{winnr}])	リスト	カーソルの位置の文字
getcwd([{winnr} [, {tabnr}]])	文字列	現在の作業ディレクトリを取得
getenv({name})			文字列	環境変数を返す
getfontname([{name}])		文字列	使用しているフォントの名前
getfperm({fname})		文字列	ファイル{fname}の許可属性を取得
getfsize({fname})		数値	ファイル{fname}のバイト数を取得
getftime({fname})		数値	ファイルの最終更新時間
getftype({fname})		文字列	ファイル{fname}の種類の説明
getimstatus()			数値	IME がアクティブの場合は |TRUE|
getjumplist([{winnr} [, {tabnr}]])
				リスト	ジャンプリスト要素のリスト
getline({lnum})			文字列	現在のバッファから行の内容を取得
getline({lnum}, {end})		リスト	カレントバッファの{lnum}から{end}行目
getloclist({nr})		リスト	locationリストの要素のリスト
getloclist({nr}, {what})	辞書	指定したlocationリストのプロパティ
getmarklist([{buf}])		リスト	グローバル/ローカルのマークのリスト
getmatches([{win}])		リスト	現在のマッチのリスト
getmousepos()			辞書	マウスの最新の位置
getmouseshape()			文字列	現在のマウス形状名
getpid()			数値	Vim のプロセス ID
getpos({expr})			リスト	カーソル・マークなどの位置を取得
getqflist()			リスト	quickfixリストの要素のリスト
getqflist({what})		辞書	指定したquickfixリストのプロパティ
getreg([{regname} [, 1 [, {list}]]])
				文字列/リスト   レジスタの中身を取得
getreginfo([{regname}])		辞書	レジスタについての情報
getregion({pos1}, {pos2} [, {opts}])
				リスト	{pos1}から{pos2}までのテキストを取得
getregtype([{regname}])		文字列	レジスタの種類を取得
getscriptinfo([{opts}])		リスト	読み込まれたスクリプトの一覧
gettabinfo([{expr}])		リスト	タブページのリスト
gettabvar({nr}, {varname} [, {def}])
				任意	タブ{nr}の変数{varname}または{def}
gettabwinvar({tabnr}, {winnr}, {name} [, {def}])
				任意	タブページ{tabnr}の{winnr}の{name}
gettagstack([{nr}])		辞書	ウィンドウ{nr}のタグスタックを取得
gettext({text})			文字列	{text} の翻訳の検索
getwininfo([{winid}])		リスト	各ウィンドウに関する情報のリスト
getwinpos([{timeout}])		リスト	Vim ウィンドウのピクセルでの X および
					Y 座標
getwinposx()			数値	Vim ウィンドウのピクセルでの X 座標
getwinposy()			数値	Vim ウィンドウのピクセルでの Y 座標
getwinvar({nr}, {varname} [, {def}])
				文字列	ウィンドウ{nr}の変数{varname}
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])
				任意	{expr}内のfile wildcardを展開
glob2regpat({expr})		文字列  globパターンを検索パターンに変換
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
				文字列	{path}の全ディレクトリに対し
					glob({expr})を行う
has({feature} [, {check}])	数値	機能{feature}がサポートならば|TRUE|
has_key({dict}, {key})		数値	{dict}が要素{key}を持つなら|TRUE|
haslocaldir([{winnr} [, {tabnr}]])
				数値	現在のウィンドウで |:lcd| か |:tcd| が
					実行されたなら|TRUE|
hasmapto({what} [, {mode} [, {abbr}]])
				数値	{what}のマッピングが存在するなら|TRUE|
histadd({history}, {item})	数値	ヒストリに追加
histdel({history} [, {item}])	数値	ヒストリからitemを削除
histget({history} [, {index}])	文字列	ヒストリから{index}アイテムを取得
histnr({history})		数値	ヒストリの数
hlID({name})			数値	highlight group {name}のID
hlexists({name})		数値	highlight group {name}が存在したら|TRUE|
hlget([{name} [, {resolve}]])	リスト	highlight group の属性を取得
hlset({list})			数値	highlight group の属性を設定
hostname()			文字列	vimが動作しているマシンの名前
iconv({expr}, {from}, {to})	文字列	{expr}のエンコーディングを変換する
indent({lnum})			文字列	行{lnum}のインデントを取得
index({object}, {expr} [, {start} [, {ic}]])
				数値	{object}中に{expr}が現れる位置
indexof({object}, {expr} [, {opts}]])
				数値	{expr} が true となる {object} 内のイ
					ンデックス
input({prompt} [, {text} [, {completion}]])
				文字列	ユーザーからの入力を取得
inputdialog({prompt} [, {text} [, {cancelreturn}]])
				文字列	input()と同様。GUIのダイアログを使用
inputlist({textlist})		数値	ユーザーに選択肢から選ばせる
inputrestore()			数値	先行入力を復元する
inputsave()			数値	先行入力を保存し、クリアする
inputsecret({prompt} [, {text}]) 文字列	input()だがテキストを隠す
insert({object}, {item} [, {idx}])
				リスト	{object}に要素{item}を挿入 [{idx}の前]
instanceof({object}, {class})	数値	{object} が {class} のインスタンスの場
					合は |TRUE|
interrupt()			なし	スクリプトの実行を中断する
invert({expr})			数値	ビット反転
isabsolutepath({path})		数値	{path} が絶対パスならば |TRUE|
isdirectory({directory})	数値	{directory}がディレクトリならば|TRUE|
isinf({expr})			数値	{expr}が無限大の値(正または負)かどうか
					を判定する
islocked({expr})		数値	{expr}がロックされているなら|TRUE|
isnan({expr})			数値	{expr}がNaNならば|TRUE|
items({dict})			リスト	{dict}のキーと値のペアを取得
job_getchannel({job})		チャネル  {job}のチャネルハンドルを取得
job_info([{job}])		辞書	{job}についての情報を取得
job_setoptions({job}, {options}) なし	{job}のオプションを設定する
job_start({command} [, {options}])
				ジョブ	ジョブを開始する
job_status({job})		文字列	{job}のステータスを取得する
job_stop({job} [, {how}])	数値	{job}を停止する
join({list} [, {sep}])		文字列	{list}の要素を連結して文字列にする
js_decode({string})		任意	JS形式のJSONをデコードする
js_encode({expr})		文字列	JS形式のJSONにエンコードする
json_decode({string})		任意	JSONをデコードする
json_encode({expr})		文字列	JSONにエンコードする
keys({dict})			リスト	{dict}のキーを取得
keytrans({string})		文字列	内部キーコードを |:map| で使用できる形
					式に変換する
len({expr})			数値	{expr}の長さを取得
libcall({lib}, {func}, {arg})	文字列	ライブラリ{lib}の関数{func}をコール
libcallnr({lib}, {func}, {arg})	数値	上と同じ。ただし数値を返す
line({expr} [, {winid}])	数値	行番号の取得
line2byte({lnum})		数値	行{lnum}のバイトカウント
lispindent({lnum})		数値	{lnum}行目のLispインデント量を取得
list2blob({list})		Blob	数値のリスト {list} をBlobに変換する
list2str({list} [, {utf8}])	文字列	数値のリスト {list} を文字列に変換する
listener_add({callback} [, {buf}])
				数値	変更を監視するためのコールバックを追加
listener_flush([{buf}])		なし	リスナーコールバックを呼び出す
listener_remove({id})		なし	リスナーコールバックを削除する
localtime()			数値	現在時刻
log({expr})			浮動小数点数	{expr}の自然対数(底e)
log10({expr})			浮動小数点数	浮動小数点数 {expr} の 10 を底
						とする対数
luaeval({expr} [, {expr}])	任意	|Lua| の式を評価する
map({expr1}, {expr2})		リスト/辞書/Blob/文字列
					{expr1} の各要素を {expr2} に変える
maparg({name} [, {mode} [, {abbr} [, {dict}]]])
				文字列/辞書
					モード{mode}でのマッピング{name}の値
mapcheck({name} [, {mode} [, {abbr}]])
				文字列	{name}にマッチするマッピングを確認
maplist([{abbr}])		リスト	全マッピングのリスト、各要素は辞書
mapnew({expr1}, {expr2})	リスト/辞書/Blob/文字列
					|map()| と同様だが新規のリストか辞書を
					作る
mapset({mode}, {abbr}, {dict})	なし	|maparg()| の結果からマッピングを復元
					する
match({expr}, {pat} [, {start} [, {count}]])
				数値	{expr}内で{pat}がマッチする位置
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
				数値	{pattern} を {group} で強調表示する
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
				数値	位置を {group} で強調表示する
matcharg({nr})			リスト	|:match|の引数
matchbufline({buf}, {pat}, {lnum}, {end}, [, {dict})
				リスト	バッファ {buf} 内のすべての {pat} の
					マッチ
matchdelete({id} [, {win}])	数値	{id} で指定されるマッチを削除する
matchend({expr}, {pat} [, {start} [, {count}]])
				数値	{expr}内で{pat}が終了する位置
matchfuzzy({list}, {str} [, {dict}])
				リスト	{list} 内について {str} でのファジー
					マッチ
matchfuzzypos({list}, {str} [, {dict}])
				リスト	{list} 内について {str} でのファジー
					マッチ
matchlist({expr}, {pat} [, {start} [, {count}]])
				リスト	{expr}内の{pat}のマッチと部分マッチ
matchstr({expr}, {pat} [, {start} [, {count}]])
				文字列	{expr}内の{count}番目の{pat}のマッチ
matchstrlist({list}, {pat} [, {dict})
				リスト	{list} 内のすべての {pat} にマッチ
matchstrpos({expr}, {pat} [, {start} [, {count}]])
				リスト	{expr}内の{count}番目の{pat}のマッチ
max({expr})			数値	{expr}内の要素の最大値
menu_info({name} [, {mode}])	辞書	メニューの項目情報を取得する
min({expr})			数値	{expr}内の要素の最小値
mkdir({name} [, {flags} [, {prot}]])
				数値	ディレクトリ{name}を作成
mode([expr])			文字列	現在の編集モード
mzeval({expr})			任意	|MzScheme| の式を評価する
nextnonblank({lnum})		数値	{lnum}行目以降で空行でない行の行番号
nr2char({expr} [, {utf8}])	文字列	ASCII/UTF-8コード{expr}で示される文字
or({expr}, {expr})		数値    ビット論理和
pathshorten({expr} [, {len}])	文字列	path内の短縮したディレクトリ名
perleval({expr})		任意	|Perl|の式を評価する
popup_atcursor({what}, {options}) 数値	カーソルの近くにポップアップウィンドウ
					を作成する
popup_beval({what}, {options})	数値	'balloon_eval' のポップアップウィンド
					ウを作成する
popup_clear()			なし	すべてのポップアップウィンドウを閉じる
popup_close({id} [, {result}])	なし	{id} のポップアップウィンドウを閉じる
popup_create({what}, {options})	数値	ポップアップウィンドウを作成する
popup_dialog({what}, {options}) 数値	ダイアログとしてポップアップウィンドウ
					を作成する
popup_filter_menu({id}, {key})	数値	ポップアップウィンドウのメニューのフィ
					ルター
popup_filter_yesno({id}, {key})	数値	ポップアップウィンドウのダイアログの
popup_findecho()		数値	`:echowin` のポップアップのウィンドウ
					ID を取得する
					フィルター
popup_findinfo()		数値	情報ポップアップウィンドウの window ID
					を取得する
popup_findpreview()		数値	プレビューポップアップウィンドウの
					window ID を取得する
popup_getoptions({id})		辞書	ポップアップウィンドウ {id} のオプショ
					ンを取得する
popup_getpos({id})		辞書	ポップアップウィンドウ {id} の位置を取
					得する
popup_hide({id})		なし	ポップアップメニュー {id} を隠す
popup_list()			リスト	全ポップアップのウィンドウIDのリストを
					取得する
popup_locate({row}, {col})	数値	指定位置のポップアップのウィンドウIDを
					取得する
popup_menu({what}, {options})	数値	メニューとして使われるポップアップウィ
					ンドウを作成する
popup_move({id}, {options})	なし	ポップアップウィンドウ {id} の位置を
					セットする
popup_notification({what}, {options})
				数値	ポップアップウィンドウの通知を作成する
popup_setoptions({id}, {options})
				なし	ポップアップウィンドウ {id} のオプショ
					ンを設定する
popup_settext({id}, {text})	なし	ポップアップウィンドウ {id} のテキスト
					を設定する
popup_show({id})		なし	ポップアップウィンドウ {id} を再表示す
					る
pow({x}, {y})			浮動小数点数	{x} の {y} 乗
prevnonblank({lnum})		数値	{lnum}行目以前の空行でない行の行番号
printf({fmt}, {expr1}...)	文字列	文字列を組み立てる
prompt_getprompt({buf})		文字列	プロンプト文字列の取得
prompt_setcallback({buf}, {expr}) なし	プロンプトコールバック関数を設定する
prompt_setinterrupt({buf}, {text}) なし	プロンプト割り込み関数を設定する
prompt_setprompt({buf}, {text}) なし	プロンプトテキストを設定する
prop_add({lnum}, {col}, {props})  なし	テキストプロパティ1つを追加
prop_add_list({props}, [[{lnum}, {col}, {end-lnum}, {end-col}], ...])
				なし	複数のテキストプロパティを追加
prop_clear({lnum} [, {lnum-end} [, {props}]])
				なし	全てのテキストプロパティを削除
prop_find({props} [, {direction}])
				辞書	テキストプロパティを検索する
prop_list({lnum} [, {props}])	リスト	{lnum}行目のテキストプロパティを取得
prop_remove({props} [, {lnum} [, {lnum-end}]])
				数値	テキストプロパティを削除
prop_type_add({name}, {props})	なし	新しいプロパティタイプを定義
prop_type_change({name}, {props})
				なし	既存のプロパティタイプを変更
prop_type_delete({name} [, {props}])
				なし	プロパティタイプを削除
prop_type_get({name} [, {props}])
				辞書	プロパティタイプの値を取得
prop_type_list([{props}])	リスト	プロパティタイプ一覧を取得
pum_getpos()			辞書	ポップアップメニューが表示されている場
					合、位置とサイズを取得
pumvisible()			数値	ポップアップメニューが表示されているか
py3eval({expr})			任意	|python3| の式を評価する
pyeval({expr})			任意	|Python| の式を評価する
pyxeval({expr})			任意	|python_x| の式を評価する
rand([{expr}])			数値	疑似乱数を取得する
range({expr} [, {max} [, {stride}]])
				リスト	{expr}から{max}までの要素のリスト
readblob({fname} [, {offset} [, {size}]])
				Blob	{fname} から |Blob| を読む
readdir({dir} [, {expr} [, {dict}]])
				リスト	{expr}によって選択された{dir}内のファ
					イル名を取得
readdirex({dir} [, {expr} [, {dict}]])
				リスト	{expr}によって選択された{dir}内のファ
					イル情報を取得
readfile({fname} [, {type} [, {max}]])
				リスト	ファイル{fname}から行のリストを取得
reduce({object}, {func} [, {initial}])
				任意	{func} を使って {object} の 畳み込み
					(reduce) を行う
reg_executing()			文字列	実行中のレジスタ名を取得する
reg_recording()			文字列	記録中のレジスタ名を取得する
reltime([{start} [, {end}]])	リスト	時刻の値を取得
reltimefloat({time})		浮動小数点数	時刻の値を浮動小数点に変換
reltimestr({time})		文字列	時刻の値を文字列に変換
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
				文字列	式を送信する
remote_foreground({server})	数値	Vimサーバーを前面に出す
remote_peek({serverid} [, {retvar}])
				数値	返信文字列を確認する
remote_read({serverid} [, {timeout}])
				文字列	返信文字列を読み込む
remote_send({server}, {string} [, {idvar}])
				文字列	キーシーケンスを送信する
remote_startserver({name})	なし	サーバー {name} になる
remove({list}, {idx} [, {end}])	任意/リスト
					{list}から{idx}と{end}間の要素を削除
remove({blob}, {idx} [, {end}])	数値/Blob
					{Blob}から{idx}と{end}間のバイトを削除
remove({dict}, {key})		任意	{dict}から要素{key}を削除
rename({from}, {to})		数値	{file}から{to}へファイル名変更
repeat({expr}, {count})		リスト/Blob/文字列
					{expr}を{count}回繰り返す
resolve({filename})		文字列	ショートカットが指す先のファイル名
reverse({obj})			リスト/Blob/文字列
				{obj} を反転させる
round({expr})			浮動小数点数	{expr} を四捨五入する
rubyeval({expr})		任意	|Ruby| の式を評価
screenattr({row}, {col})	数値	スクリーン位置の属性
screenchar({row}, {col})	数値	スクリーン位置の文字
screenchars({row}, {col})	リスト	スクリーン位置の文字のリスト
screencol()			数値	現在のカーソル列
screenpos({winid}, {lnum}, {col}) 辞書	スクリーン行と列のテキスト
screenrow()			数値	現在のカーソル行
screenstring({row}, {col})	文字列	スクリーン位置の文字列
search({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
				数値	{pattern} を検索する
searchcount([{options}])	辞書	検索の統計の取得もしくは更新する
searchdecl({name} [, {global} [, {thisblock}]])
				数値	変数の宣言を検索
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				数値	開始/終端のペアの他方を検索
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				リスト	開始/終端のペアの他方を検索
searchpos({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
				リスト	{pattern}を検索
server2client({clientid}, {string})
				数値	返信文字列を送信する
serverlist()			文字列	利用可能なサーバーのリストを取得
setbufline({expr}, {lnum}, {text})
				数値	バッファ {expr} の {lnum} 行目に {text}
					を設定する
setbufvar({buf}, {varname}, {val})	バッファ{buf}内の変数{varname}に{val}を
					セット
setcellwidths({list})		なし	文字のセル幅の上書き設定
setcharpos({expr}, {list})	数値	{list} の {expr} 位置に設定
setcharsearch({dict})		辞書	文字検索を{dict}に設定
setcmdline({str} [, {pos}])	数値	コマンドラインを設定する
setcmdpos({pos})		数値	コマンドライン内のカーソル位置を設定
setcursorcharpos({list})	数値	{list} の位置へカーソルを移動
setenv({name}, {val})		なし	環境変数を設定
setfperm({fname}, {mode})	数値	ファイル {fname} のパーミッションを
					{mode} に設定
setline({lnum}, {line})		数値	行{lnum}に{line}(文字列)をセット
setloclist({nr}, {list} [, {action}])
				数値	{list}を使ってlocationリストを変更
setloclist({nr}, {list}, {action}, {what})
				数値	指定したlocationリストのプロパティを
					変更
setmatches({list} [, {win}])	数値	マッチのリストを復元する
setpos({expr}, {list})		なし	{expr}の位置を{list}にする
setqflist({list} [, {action}])	数値	{list}を使ってquickfixリストを変更
setqflist({list}, {action}, {what})
				数値	指定したquickfixリストのプロパティを
					変更
setreg({n}, {v} [, {opt}])	数値	レジスタの値とタイプを設定
settabvar({nr}, {varname}, {val}) なし	タブページ{nr}の変数{varname}を{val}に
					設定する
settabwinvar({tabnr}, {winnr}, {varname}, {val})
				なし	タブページ{tabnr}内のウィンドウ{winnr}
					の変数{varname}に{val}をセット
settagstack({nr}, {dict} [, {action}])
				数値	{dict}を使ってタグスタックを変更
setwinvar({nr}, {varname}, {val}) なし	ウィンドウ{nr}の変数{varname}に{val}を
					セット
sha256({string})		文字列	{string}のSHA256チェックサム
shellescape({string} [, {special}])
				文字列	{string}をシェルコマンド引数として使う
					ためにエスケープする。
shiftwidth([{col}])		数値	実際に使用される 'shiftwidth' の値
sign_define({name} [, {dict}])	数値	目印を定義または更新する
sign_define({list})		リスト	目印のリストを定義または更新する
sign_getdefined([{name}])	リスト	定義されている目印のリストを取得する
sign_getplaced([{buf} [, {dict}]])
				リスト	設置されている目印のリストを取得する
sign_jump({id}, {group}, {buf})
				数値	目印に移動する
sign_place({id}, {group}, {name}, {buf} [, {dict}])
				数値	目印を設置する
sign_placelist({list})		リスト	目印のリストを設置する
sign_undefine([{name}])		数値	目印を削除する
sign_undefine({list})		リスト	目印のリストを削除する
sign_unplace({group} [, {dict}])
				数値	目印を解除する
sign_unplacelist({list})	リスト	目印のリストを解除する
simplify({filename})		文字列	ファイル名を可能なかぎり簡略化する
sin({expr})			浮動小数点数	{expr} の正弦(サイン)
sinh({expr})			浮動小数点数	{expr}のハイパボリックサイン
slice({expr}, {start} [, {end}])  文字列、リスト、Blob
					文字列、リスト、Blob のスライス
sort({list} [, {how} [, {dict}]])
				リスト	{list} を {how} で比較してソートする
sound_clear()			なし	すべてのサウンドの再生を停止する
sound_playevent({name} [, {callback}])
				数値	イベントサウンドを再生する
sound_playfile({path} [, {callback}])
				数値	サウンドファイル{path}を再生する
sound_stop({id})		なし	サウンド{id}の再生を停止する
soundfold({word})		文字列	{word}のsound-fold
spellbadword()			文字列	カーソル位置のスペルミスした単語
spellsuggest({word} [, {max} [, {capital}]])
				リスト	スペリング補完
split({expr} [, {pat} [, {keepempty}]])
				リスト	{expr}を{pat}で区切ってリストを作る
sqrt({expr})			浮動小数点数	{expr} の平方根
srand([{expr}])			リスト	|rand()| 用の種を取得する
state([{what}])			文字列	Vimの現在の状態
str2float({expr} [, {quoted}])	浮動小数点数	文字列を浮動小数点数に変換する
str2list({expr} [, {utf8}])	リスト	{expr}の各文字をASCII/UTF-8値に変換する
str2nr({expr} [, {base} [, {quoted}]])
				数値	文字列を数値に変換する
strcharlen({expr})		数値	文字列 {expr} の文字の長さ
strcharpart({str}, {start} [, {len} [, {skipcc}]])
				文字列	{str} 内 {start} 文字目 から {len} 文
					字分
strchars({expr} [, {skipcc}])	数値	文字列{expr}の文字の数
strdisplaywidth({expr} [, {col}]) 数値	文字列{expr}の表示幅
strftime({format} [, {time}])	文字列	指定されたフォーマットで時刻を書式化
strgetchar({str}, {index})	数値	{str} から {index} 番目の文字インデッ
					クスを得る
stridx({haystack}, {needle} [, {start}])
				数値	{haystack}内の{needle}のインデックス
string({expr})			文字列	{expr}の値の文字列表現
strlen({expr})			数値	文字列{expr}の長さ
strpart({str}, {start} [, {len} [, {chars}]])
				文字列	{str}内{start}バイトから{len}バイト/
					文字分
strptime({format}, {timestring})
				数値	{timestring} を unix タイムスタンプに
					変換
strridx({haystack}, {needle} [, {start}])
				数値	{haystack}内の最後の{needle}のインデッ
					クス
strtrans({expr})		文字列	文字列を表示可能に変更
strutf16len({string} [, {countcc}])
				数値	{string} の UTF-16 コード単位の数
strwidth({expr})		数値	文字列{expr}の表示セル幅
submatch({nr} [, {list}])	文字列/リスト
					":s" やsubstitute()における特定のマッチ
substitute({expr}, {pat}, {sub}, {flags})
				文字列	{expr}の{pat}を{sub}に置換え
swapfilelist()			リスト	'directory' 内で見つかったスワップファイ
					ルのリスト
swapinfo({fname})		辞書	スワップファイル {fname} に関する情報
swapname({buf})			文字列	バッファ{buf}のスワップファイル名
synID({lnum}, {col}, {trans})	数値	{line}と{col}のsyntax IDを取得
synIDattr({synID}, {what} [, {mode}])
				文字列	syntax ID{synID}の属性{what}を取得
synIDtrans({synID})		数値	{synID}の翻訳されたsyntax ID
synconcealed({lnum}, {col})	リスト  Conceal の情報
synstack({lnum}, {col})	リスト	{lnum}行{col}列目における構文IDの
					スタック
system({expr} [, {input}])	文字列	シェルコマンド{expr}の出力結果
systemlist({expr} [, {input}])	リスト	シェルコマンド{expr}の出力結果
tabpagebuflist([{arg}])		リスト	タブページ内のバッファ番号のリスト
tabpagenr([{arg}])		数値	現在または最後のタブページの番号
tabpagewinnr({tabarg} [, {arg}])
				数値	タブページ内の現在のウィンドウの番号
tagfiles()			リスト	使用しているタグファイルのリスト
taglist({expr} [, {filename}])	リスト	{expr}にマッチするタグのリスト
tan({expr})			浮動小数点数	{expr}のタンジェント
tanh({expr})			浮動小数点数	{expr}のハイパボリックタンジェ
						ント
tempname()			文字列	テンポラリファイルの名前
term_dumpdiff({filename}, {filename} [, {options}])
				数値	2 つのダンプ間の差分を表示する
term_dumpload({filename} [, {options}])
				数値	スクリーンダンプの表示
term_dumpwrite({buf}, {filename} [, {options}])
				なし	端末ウィンドウの内容をダンプする
term_getaltscreen({buf})	数値	代替スクリーンフラグを取得する
term_getansicolors({buf})	リスト	GUI カラーモードでの ANSI パレットを取
					得する
term_getattr({attr}, {what})	数値	属性 {what} の値を取得する
term_getcursor({buf})		リスト	端末のカーソル位置を取得する
term_getjob({buf})		ジョブ	端末に関連付けられているジョブを取得す
					る
term_getline({buf}, {row})	文字列	端末から 1 行のテキストを取得する
term_getscrolled({buf})		数値	端末のスクロール数を取得する
term_getsize({buf})		リスト	端末のサイズを取得する
term_getstatus({buf})		文字列	端末の状態を取得する
term_gettitle({buf})		文字列	端末のタイトルを取得する
term_gettty({buf}, [{input}])	文字列	端末の tty 名を取得する
term_list()			リスト	端末バッファのリストを取得する
term_scrape({buf}, {row})	リスト	端末スクリーンの行を取得する
term_sendkeys({buf}, {keys})	なし	キー入力を端末に送信する
term_setansicolors({buf}, {colors})
				なし	GUI カラーモードでの ANSI パレットを設
					定する
term_setapi({buf}, {expr})	なし	|terminal-api| の関数名プリフィックス
					を設定する
term_setkill({buf}, {how})	なし	端末のジョブを停止するためのシグナルを
					設定する
term_setrestore({buf}, {command}) なし	端末を復元するためのコマンドを設定する
term_setsize({buf}, {rows}, {cols})
				なし	端末のサイズを設定する
term_start({cmd} [, {options}])	数値	端末ウィンドウを開きジョブを実行する
term_wait({buf} [, {time}])	数値	スクリーンが更新されるのを待つ
terminalprops()			辞書	端末のプロパティ
test_alloc_fail({id}, {countdown}, {repeat})
				なし	メモリの確保を失敗にさせる
test_autochdir()		なし	起動時に 'autochdir' を有効にする
test_feedinput({string})	なし	キー入力を入力バッファに追加する
test_garbagecollect_now()	なし	テスト用に直ちにメモリを解放する
test_garbagecollect_soon()	なし	テスト用にすぐにメモリを解放する
test_getvalue({string})		任意	内部変数の値を取得する
test_gui_event({event}, {args})	真偽値	テスト用の GUI イベントを発生させる
test_ignore_error({expr})	なし	特定のエラーを無視する
test_mswin_event({event}, {args})
				真偽値	テスト用の MS-Windows イベントを生成
test_null_blob()		Blob	テスト用のnull値
test_null_channel()		チャネル	テスト用のnull値
test_null_dict()		辞書	テスト用のnull値
test_null_function()		Funcref	テスト用のnull値
test_null_job()			ジョブ	テスト用のnull値
test_null_list()		リスト	テスト用のnull値
test_null_partial()		Funcref	テスト用のnull値
test_null_string()		文字列	テスト用のnull値
test_option_not_set({name})	なし	オプション設定フラグをリセットする
test_override({expr}, {val})	なし	Vimの内部処理を置き換えてテストする
test_refcount({expr})		数値	{expr}の参照カウントを取得
test_setmouse({row}, {col})	なし	テスト用にマウス位置を設定する
test_settime({expr})		なし	テスト用に現在の時刻を設定する
test_srand_seed([seed])		なし	srand() のテスト用に種を設定する
test_unknown()			任意	テスト用のunknown値
test_void()			任意	テスト用のvoid値
timer_info([{id}])		リスト	タイマーに関する情報
timer_pause({id}, {pause})	なし	タイマーの一時停止または一時停止解除
timer_start({time}, {callback} [, {options}])
				数値	タイマーを作成する
timer_stop({timer})		なし	タイマーを停止する
timer_stopall()			なし	すべてのタイマーを停止する
tolower({expr})			文字列	文字列{expr}を小文字にする
toupper({expr})			文字列	文字列{expr}を大文字にする
tr({src}, {fromstr}, {tostr})	文字列	{src}中に現れる文字{fromstr}を{tostr}
					に変換する
trim({text} [, {mask} [, {dir}]])
				文字列	{text} から {mask} 内の文字を切り取る
trunc({expr})			浮動小数点数	浮動小数点数{expr}を切り詰める
type({expr})			数値	変数{expr}の型
typename({expr})		文字列	{expr}の型を表す
undofile({name})		文字列	{name}に対するアンドゥファイルの名前
undotree([{buf}])		リスト	バッファ {buf} のアンドゥファイルツリー
uniq({list} [, {func} [, {dict}]])
				リスト	リストから隣接した重複を削除
utf16idx({string}, {idx} [, {countcc} [, {charidx}]])
				数値	{string} のバイト {idx} の UTF-16 イン
					デックス
values({dict})			リスト	{dict}の値のリスト
virtcol({expr} [, {list} [, {winid}])
				数値/リスト
					カーソルまたはマークのスクリーン桁
virtcol2col({winid}, {lnum}, {col})
				数値	スクリーン上の文字のバイトインデックス
visualmode([expr])		文字列	最後に使われたビジュアルモード
wildmenumode()			数値	'wildmenu' モードが有効かどうか
win_execute({id}, {command} [, {silent}])
				文字列	ウィンドウ{id}で{command}を実行する
win_findbuf({bufnr})		リスト	{bufnr}を含むウィンドウを見つける
win_getid([{win} [, {tab}]])	数値	{tab}の{win}のウィンドウIDを取得
win_gettype([{nr}])		文字列	ウィンドウ {nr} の型
win_gotoid({expr})		数値	ID {expr}のウィンドウに行く
win_id2tabwin({expr})		リスト	ウィンドウIDからタブとウィンドウnr取得
win_id2win({expr})		数値	ウィンドウIDからウィンドウnr取得
win_move_separator({nr})	数値	ウィンドウの垂直セパレータの移動
win_move_statusline({nr})	数値	ウィンドウのステータス行の移動
win_screenpos({nr})		リスト	ウィンドウ {nr} のスクリーン位置を取得
					する
win_splitmove({nr}, {target} [, {options}])
				数値	ウィンドウ {nr} を {target} の分割へ移
					動
winbufnr({nr})			数値	ウィンドウ{nr}のバッファ番号
wincol()			数値	カーソル位置のウィンドウ桁
windowsversion()		文字列	MS-Windows OS のバージョン
winheight({nr})			数値	ウィンドウ{nr}の高さ
winlayout([{tabnr}])		リスト	タブ {tabnr} 内のウィンドウの配置
winline()			数値	カーソル位置のウィンドウ行
winnr([{expr}])			数値	現在のウィンドウの番号
winrestcmd()			文字列	ウィンドウサイズを復元するコマンド
winrestview({dict})		なし	現在のウィンドウのビューを復元
winsaveview()			辞書	現在のウィンドウのビューを保存
winwidth({nr})			数値	ウィンドウ{nr}の幅を取得
wordcount()			辞書	バイト/文字/単語の統計情報を取得
writefile({object}, {fname} [, {flags}])
				数値	行の |Blob| または |list| をファイルに
					書き込む
xor({expr}, {expr})		数値	ビット排他的論理和

==============================================================================
2. 詳細						*builtin-function-details*

すべての関数はここにはなく、いくつかはそのカバーしている特別な機能のヘルプファ
イルへ移動している。

abs({expr})							*abs()*
		{expr} の絶対値を返す。{expr} の値が浮動小数点数である場合は浮
		動小数点数を返す。{expr} が|Number|に変換可能な場合は数値が戻
		り値になる。それ以外の場合はエラーメッセージを表示し、-1
		を返す。
		例: >
			echo abs(1.456)
<			1.456  >
			echo abs(-5.456)
<			5.456  >
			echo abs(-4)
<			4

		|method| としても使用できる: >
			Compute()->abs()


acos({expr})							*acos()*
		{expr} の逆余弦 (アークコサイン) をラジアンで返す。
		値は [0, pi] の範囲の浮動小数点数 (|Float|)。
		{expr} は [-1, 1] の範囲の浮動小数点数 (|Float|) か数値
		(|Number|) でなければならない。それ以外の場合、acos() は "nan"
		を返す。
		例: >
			:echo acos(0)
<			1.570796 >
			:echo acos(-0.5)
<			2.094395

		|method| としても使用できる: >
			Compute()->acos()


add({object}, {expr})					*add()*
		|List| または |Blob| {object}の末尾に項目{expr}を追加する。結
		果の |List| か |Blob| を返す。例: >
			:let alist = add([1, 2, 3], item)
			:call add(mylist, "woodstock")
<		Note {expr}がリストのときは、1個の要素として追加される。リスト
		を連結するには|extend()|を使う。
		{object}が |Blob| の場合、{expr}は数値でなければならない。
		他の位置に要素を追加するには|insert()|を使う。
		{object} が |List| または |Blob| でない場合は 1 を返す。

		|method| としても使用できる: >
			mylist->add(val1)->add(val2)


and({expr}, {expr})					*and()*
		二つの引数のビット論理積。引数は数値に変換される。リスト、辞
		書、浮動小数点数を指定するとエラーになる。
		`or()` および `xor()` も参照。
		例: >
			:let flag = and(bits, 0x80)
<		|method| としても使用できる: >
			:let flag = bits->and(0x80)


append({lnum}, {text})					*append()*
		{text}がリスト|List|のときは、各要素をカレントバッファの{lnum}
		行目以降にテキストとして追加する。
		リストでないときは、{text}をテキストとしてカレントバッファの
		{lnum}行目以降にテキストとして追加する。
		要素としてどの型でも受け入れて文字列に変換される。
		{lnum}は0でもよく、その場合は1行目の前に行を挿入する。
		{lnum}は|getline()|と同様に扱われる。
		失敗した場合は1を返す({lnum}が不正な範囲であるか、メモリ不足)。
		成功なら0を返す。{text} が空のリストの場合、{lnum} の値に関係
		なくゼロが返される。
		|Vim9| script では不正な引数であるか負数の場合は結果がエラーに
		なる。例: >
			:let failed = append(line('$'), "# THE END")
			:let failed = append(0, ["Chapter 1", "the beginning"])

<		リストの後に |method| としても使用でき、ベースは第2引数として
		渡される: >
			mylist->append(lnum)


appendbufline({buf}, {lnum}, {text})			*appendbufline()*
		|append()| と同様、ただしバッファ {buf} にテキストを追加する。

		この関数は、ロードされたバッファに対してのみ機能する。必要であ
		れば、最初に |bufload()| を呼び出すこと。

		{buf} の使い方については |bufname()| を参照。

		{lnum} は行番号をその下に追加する。Note: |line()| の使用は、追
		加対象のバッファではなくカレントバッファに適用される。バッファ
		の最後に追加するには "$" を使用する。他の文字列値はサポートれ
		ない。

		成功時には 0 が返り、失敗時には 1 が返る。
		|Vim9| script では不正な {lnum} を与えられた時エラーになる。

		{buf} が有効なバッファでない、もしくは {lnum} が有効でない場
		合、エラーメッセージが与えられる。例: >
			:let failed = appendbufline(13, 0, "# THE START")
<		ただし、{text} が空のリストの場合、{lnum} は実際には使用されな
		いため、無効な {lnum} に対してエラーは発生しない。

		リストの後に |method| としても使用でき、ベースは第2引数として
		渡される: >
			mylist->appendbufline(buf, lnum)


argc([{winid}])					*argc()*
		引数リスト内の、ファイルの数を返す。|arglist|を参照。
		{winid} が指定されていない場合は、カレントウィンドウの引数リス
		トが使われる。
		{winid} が -1 の場合、グローバル引数リストが使われる。
		もしくは、{winid} は、引数リストが使用されるウィンドウを指定す
		る: ウィンドウ番号またはウィンドウID。引数{winid} が無効な場合
		は -1 を返す。

							*argidx()*
argidx()	引数リスト内の現在のインデックスを返す。最初のファイルは0とな
		る。argc() - 1が最後のファイルとなる。|arglist|を参照。

							*arglistid()*
arglistid([{winnr} [, {tabnr}]])
		引数リストの ID を返す。値は引数リストを区別するための数値であ
		る。ゼロはグローバル引数リストを意味する。|arglist| 参照。
		引数が無効な場合は -1 を返す。

		引数を指定しなかった場合はカレントウィンドウが使われる。
		{winnr} を指定した場合はカレントタブページ内のウィンドウが使わ
		れる。
		{winnr} と {tabnr} を指定した場合は指定したタブページ内のウィ
		ンドウが使われる。
		{winnr} にはウィンドウ番号または|window-ID|が使える。

							*argv()*
argv([{nr} [, {winid}]])
		結果は引数リスト内の、{nr}番目のファイル。|arglist| を参照。
		"argv(0)" は一番最初のファイルを示す。例: >
	:let i = 0
	:while i < argc()
	:  let f = escape(fnameescape(argv(i)), '.')
	:  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'
	:  let i = i + 1
	:endwhile
<		引数{nr} が指定されなかった場合、または、-1 の場合、引数リス
		ト |arglist| 全体を返す。

		引数{winid} はウィンドウIDを指定する。
		Vimのコマンドライン引数については、|v:argv| を参照。

		{nr} 番目の引数が引数リストに存在しない場合は、空の文字列を返
		す。{winid} 引数が無効な場合は、空のリストを返す。

asin({expr})						*asin()*
		{expr} の逆正弦 (アークサイン) をラジアンで返す。
		値は [-pi/2, pi/2] の範囲の浮動小数点数 (|Float|)。
		{expr} は [-1, 1] の範囲の浮動小数点数 (|Float|) か数値
		(|Number|) でなければならない。
		{expr} が [-1, 1] の範囲外の場合は "nan" を返す。{expr} が
		|Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo asin(0.8)
<			0.927295 >
			:echo asin(-0.5)
<			-0.523599

		|method| としても使用できる: >
			Compute()->asin()
<

assert_ 関数群はここに文書化されている: |assert-functions-details|



atan({expr})						*atan()*
		{expr} の逆正接(アークタンジェント)の主値を浮動小数点数
		|Float| で返す。主値はラジアンで[-pi/2, +pi/2]の範囲内にある。
		{expr} は |Float| か |Number| に評価されなければならない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo atan(100)
<			1.560797 >
			:echo atan(-4.01)
<			-1.326405

		|method| としても使用できる: >
			Compute()->atan()


atan2({expr1}, {expr2})					*atan2()*
		{expr1} / {expr2} の逆正接 (アークタンジェント) をラジアンで返
		す。値は [-pi, pi] の範囲の浮動小数点数 (|Float|)。
		{expr1} と {expr2} は浮動小数点数 (|Float|) か数値 (|Number|)
		でなければならない。
		{expr} または {expr2} が |Float| または |Number| でない場合は
		0.0 を返す。
		例: >
			:echo atan2(-1, 1)
<			-0.785398 >
			:echo atan2(1, -1)
<			2.356194

		|method| としても使用できる: >
			Compute()->atan2(1)


autocmd_add({acmds})					*autocmd_add()*
		自動コマンドと自動コマンドグループを追加する。

		引数 {acmds} は、各項目が以下のオプション項目を持つ辞書のリス
		トである:
		    bufnr	バッファローカルな自動コマンドを追加するための
				バッファ番号。この項目を指定した場合、
				"pattern" 項目は無視される。
		    cmd		この自動コマンドイベントに対して実行する Ex コ
				マンド
		    event	自動コマンドイベント名。|autocmd-events| を参
				照。これは、単一のイベント名の文字列またはイベ
				ント名のリストのどちらかである。
		    group	自動コマンドグループ名。|autocmd-groups| を参
				照。グループが存在しない場合は作成される。指定
				しない場合、または空の場合は、デフォルトのグ
				ループが使用される。
		    nested	真偽値フラグ。v:true に設定すると、ネストされ
				た自動コマンドを追加する。|autocmd-nested| を
				参照。
		    once	真偽値フラグ。v:true に設定すると、一度だけ実
				行される自動コマンドが追加される。
				|autocmd-once| を参照。
		    pattern	自動コマンドパターン文字列。|autocmd-patterns|
				を参照。"bufnr" 項目が存在する場合、この項目は
				無視される。単一のパターンを持つ文字列またはパ
				ターンのリストにすることができる。
		    replace	真偽値フラグ。v:true に設定すると、指定された
				自動コマンドイベントおよびグループに関連付けら
				れたすべてのコマンドが削除され、{cmd} が追加さ
				れる。これは、グループ内の自動コマンドイベント
				に対して同じコマンドを複数回追加することを避け
				るのに役立つ。

		成功した場合は v:true を返し、失敗した場合は v:false を返す。
		例: >
			" バッファ 5 のバッファローカルな自動コマンドを作成
			let acmd = {}
			let acmd.group = 'MyGroup'
			let acmd.event = 'BufEnter'
			let acmd.bufnr = 5
			let acmd.cmd = 'call BufEnterFunc()'
			call autocmd_add([acmd])
<
		|method| としても使用できる: >
			GetAutocmdList()->autocmd_add()
<
autocmd_delete({acmds})					*autocmd_delete()*
		自動コマンドと自動コマンドグループを削除する。

		引数 {acmds} は、各項目が以下のオプション項目を持つ辞書のリス
		トである:
		    bufnr	バッファローカルな自動コマンドを削除するための
				バッファ番号。この項目を指定した場合、
				"pattern" 項目は無視される。
		    cmd		この自動コマンドイベントに対して実行する Ex コ
				マンド
		    event	自動コマンドイベント名。|autocmd-events| を参
				'*' の場合、このグループ内のすべての自動コマン
				ドイベントが削除される。
		    group	自動コマンドグループ名。|autocmd-groups| を参
				照。指定なし、または空の場合は、デフォルトのグ
				ループが使用される。
		    nested	ネストされた自動コマンドの場合は v:true に設定
				する。|autocmd-nested| を参照。
		    once	一度だけ実行される自動コマンドの場合は v:true
				に設定する。|autocmd-once| を参照。
		    pattern	自動コマンドパターン文字列。|autocmd-patterns|
				を参照。"bufnr" 項目が存在する場合、この項目は
				無視される。

		{acmds} エントリで {group} のみが指定されており、{event}、
		{pattern}、および {cmd} が指定されていない場合、その自動コマン
		ドグループは削除される。

		成功した場合は v:true を返し、失敗した場合は v:false を返す。
		例: >
			" :autocmd! BufLeave *.vim
			let acmd = #{event: 'BufLeave', pattern: '*.vim'}
			call autocmd_delete([acmd]})
			" :autocmd! MyGroup1 BufLeave
			let acmd = #{group: 'MyGroup1', event: 'BufLeave'}
			call autocmd_delete([acmd])
			" :autocmd! MyGroup2 BufEnter *.c
			let acmd = #{group: 'MyGroup2', event: 'BufEnter',
							\ pattern: '*.c'}
			" :autocmd! MyGroup2 * *.c
			let acmd = #{group: 'MyGroup2', event: '*',
							\ pattern: '*.c'}
			call autocmd_delete([acmd])
			" :autocmd! MyGroup3
			let acmd = #{group: 'MyGroup3'}
			call autocmd_delete([acmd])
<
		|method| としても使用できる: >
			GetAutocmdList()->autocmd_delete()

autocmd_get([{opts}])					*autocmd_get()*
		自動コマンドの |List| を返す。{opts} が指定されていない場合は、
		すべてのグループのすべてのイベントの自動コマンドを返す。

		オプションの {opts} 辞書引数は、以下の項目をサポートする:
		    group	自動コマンドグループ名。指定した場合、このグ
				ループで定義されている自動コマンドのみを返す。
				指定したグループが存在しない場合は、エラーメッ
				セージが表示される。空の文字列を設定すると、デ
				フォルトの自動コマンドグループが使用される。
		    event	自動コマンドイベント名。指定した場合、このイベ
				ントに定義された自動コマンドのみを返す。"*" を
				設定すると、すべてのイベントの自動コマンドが返
				される。指定したイベントが存在しない場合は、エ
				ラーメッセージが表示される。
		    pattern	自動コマンドパターン。指定した場合、このパター
				ンに定義されている自動コマンドのみを返す。
		上記 3 つの組み合わせを {opts} で指定できる。

		返されたリストの各辞書には次の項目が含まれる:
		    bufnr	バッファローカルな自動コマンドの場合、自動コマ
				ンドが定義されているバッファ番号。
		    cmd		自動コマンドに対して実行されたコマンド。
		    event	自動コマンドイベント名。
		    group	自動コマンドグループ名。
		    nested	Booleanフラグ。ネストされた自動コマンドの場合、
				v:true が設定される。|autocmd-nested| を参照。
		    once	Booleanフラグ。自動コマンドが 1 回だけ実行され
				る場合は、v:true に設定する。|autocmd-once| を
				参照。
		    pattern	自動コマンドパターン。バッファローカルな自動コ
				マンドの場合、"<buffer=n>" の形式になる。
		グループ内の自動コマンドイベントに複数のコマンドがある場合、コ
		マンドごとに個別の項目が返される。

		指定されたグループ、イベント、またはパターンを持つ自動コマンド
		が見つからない場合は、空のリストを返す。

		例: >
			" :autocmd MyGroup
			echo autocmd_get(#{group: 'Mygroup'})
			" :autocmd G BufUnload
			echo autocmd_get(#{group: 'G', event: 'BufUnload'})
			" :autocmd G * *.ts
			let acmd = #{group: 'G', event: '*', pattern: '*.ts'}
			echo autocmd_get(acmd)
			" :autocmd Syntax
			echo autocmd_get(#{event: 'Syntax'})
			" :autocmd G BufEnter *.ts
			let acmd = #{group: 'G', event: 'BufEnter',
							\ pattern: '*.ts'}
			echo autocmd_get(acmd)
<
		|method| としても使用できる: >
			Getopts()->autocmd_get()
<
balloon_gettext()					*balloon_gettext()*
		バルーン内の現在のテキストを返す。文字列に対してのみ使用され、
		リストには使用されない。バルーンが存在しない場合は空の文字列を
		返す。

balloon_show({expr})					*balloon_show()*
		{expr} をバルーン内に表示する。GUI では {expr} は文字列として
		扱われる。端末では {expr} をバルーンの行を含むリストとしてもよ
		い。{expr} がリストでない場合、|balloon_split()| で分割される。
		{expr} が空文字列の場合、既存のバルーンは削除される。

		例: >
			func GetBalloonContent()
			   " ... 内容の取得を開始
			   return ''
			endfunc
			set balloonexpr=GetBalloonContent()

			func BalloonCallback(result)
			  call balloon_show(a:result)
			endfunc
<		|method| としても使用できる: >
			GetText()->balloon_show()
<
		想定される使用方法は、バルーンの内容の取得が 'balloonexpr' か
		ら開始されることである。そこから非同期メソッドを呼び出し、コー
		ルバックから balloon_show() を呼び出す。'balloonexpr' 自身は
		空文字列かプレースホルダーを返すことができる。例えば、
		"loading..."。

		バルーンを表示できないときは何も起こらず、エラーメッセージも表
		示されない。
		{Vimが |+balloon_eval| もしくは |+balloon_eval_term| 機能付き
		でコンパイルされたときのみ有効}

balloon_split({msg})					*balloon_split()*
		文字列 {msg} をバルーン内で表示される行に分割する。カレントウィ
		ンドウサイズ用に分割され、デバッガ出力を表示するために最適化さ
		れる。
		分割された行の |List| を返す。エラーが発生した場合は空のリスト
		を返す。
		|method| としても使用できる: >
			GetText()->balloon_split()->balloon_show()

<		{|+balloon_eval_term| 機能付きでコンパイルされたときのみ有効}

blob2list({blob})					*blob2list()*
		Blob {blob} の各バイトを数値として保持するリストを返す。例: >
			blob2list(0z0102.0304)	returns [1, 2, 3, 4]
			blob2list(0z)		returns []
<		エラーの時は空リストを返す。|list2blob()| は反対のことをする。

		|method| としても使用できる: >
			GetBlob()->blob2list()
<
							*browse()*
browse({save}, {title}, {initdir}, {default})
		ファイル選択ダイアログを起動。"has("browse")" が|TRUE|を返すと
		き (幾つかのGUIバージョンに限定)だけ利用可能。
		入力フィールドの意味は:
		    {save}	|TRUE|ならば書込み用ファイルの選択
		    {title}	ダイアログのタイトル
		    {initdir}	ダイアログの始まるディレクトリ
		    {default}	ファイル名の省略値
		ダイアログがキャンセルされるか、何かエラーがあるか、もしくはブ
		ラウジングが不可能ならば、空文字列が戻ってくる。

							*browsedir()*
browsedir({title}, {initdir})
		ディレクトリ選択ダイアログを起動。"has("browse")" が|TRUE|を返
		すとき(幾つかのGUIバージョンに限定)だけ利用可能。
		ディレクトリ選択ダイアログがないシステムにおいてはファイル選択
		ダイアログが使われる。その場合は、指定したいディレクトリの中の
		ファイルを選択すること。
		入力フィールドの意味は:
		    {title}	ダイアログのタイトル
		    {initdir}	ダイアログの始まるディレクトリ
		ダイアログがキャンセルされるか、何かエラーがあるか、もしくはブ
		ラウジングが不可能ならば、空文字列が戻ってくる。

bufadd({name})						*bufadd()*
		バッファリストに {name} (文字列でなければならない) という名前
		でバッファを追加する。
		もし、ファイル {name} 用のバッファが既に存在した場合、そのバッ
		ファの番号を返す。そうでなければ、新しく作られたバッファの番号
		を返す。{name} が空の文字列だったときは新しいバッファが常に作
		成される。
		バッファには 'buflisted' が設定されず、まだロードされない。
		バッファにテキストを追加するにはこれを使用する: >
			let bufnr = bufadd('someName')
			call bufload(bufnr)
			call setbufline(bufnr, 1, ['some', 'text'])
<		エラーが発生した場合は 0 を返す。
		|method| としても使用できる: >
			let bufnr = 'somename'->bufadd()

bufexists({buf})					*bufexists()*
		結果は数値で、{buf}と呼ばれるバッファが存在すれば|TRUE|となる。
		{buf}が数値の場合、バッファ番号とみなされる。数値の 0 はカレン
		トウィンドウの代替バッファである。

		{buf}が文字列の場合、バッファ名に正確にマッチしなければならな
		い。名前として以下のものが許される:
		- カレントディレクトリからの相対パス。
		- フルパス。
		- 'buftype' が "nofile" であるバッファの名前
		- URL名。
		バッファリストにないバッファも検索される。
		Note |:buffers|の出力で、ヘルプファイルは短い名前でリストされ
		ているが、bufexists()は長い名前でないと見つけることができない。
		ある名前を bufexists() に与えて非零になったとしても、その名前
		をコマンド |:buffer| に与える際には |expand()| を使って展開し
		なければならない場合がある。特に MS-Windows の "c:\DOCUME~1"
		という 8.3 名形式において。
		代替ファイル名が存在するかを判定するには "bufexists(0)" を使う。

		|method| としても使用できる: >
			let exists = 'somename'->bufexists()
<
							*buffer_exists()*
		以前の名前: buffer_exists().

buflisted({buf})					*buflisted()*
		戻り値は数値で、{buf}と呼ばれるバッファが存在しリストされてい
		る ('buflisted' オプションがオンになっている) ならば結果は
		|TRUE|となる。引数{buf}は|bufexists()|と同じように扱われる。

		|method| としても使用できる: >
			let listed = 'somename'->buflisted()

bufload({buf})						*bufload()*
		バッファ{buf}がロードされていることを保証する。バッファの名前
		が既存のファイルを参照しているときは、そのファイルが読み込まれ
		る。そうでなければバッファは空になる。もし既にバッファが読み込
		まれていれば、変更はない。バッファがファイルに関連していない場
		合、ファイルは読み取られない (例: 'buftype' が "nofile" の場
		合)。
		バッファのファイルに対して既存のスワップファイルがある場合、ダ
		イアログなしで、バッファはロードされる。
		引数{buf}は|bufexists()|と同じように扱われる。

		|method| としても使用できる: >
			eval 'somename'->bufload()

bufloaded({buf})					*bufloaded()*
		戻り値は数値で、{buf}と呼ばれるバッファが存在しロード済み(ウィ
		ンドウに表示されているか、隠されているかは問わない)ならば結果
		は|TRUE|となる。引数{buf}は|bufexists()|と同じように扱われる。

		|method| としても使用できる: >
			let loaded = 'somename'->bufloaded()

bufname([{buf}])					*bufname()*
		戻り値はバッファの名前。バッファ名はコマンド `:ls` で表示され
		るものとほとんど同じだが、例えば "[No Name]" などの特殊名は使
		用しない。
		{buf}が省略された場合は、カレントバッファが使われる。
		{buf}が数値ならば、その番号のバッファ名が返される。0は現在の
		ウィンドウの代替バッファを意味する。{buf}が文字列ならば、バッ
		ファ名に対してファイル名マッチング |file-pattern| を行うパター
		ンとなる。このマッチングは常に、'magic' をセットし 'cpoptions'
		を空にした状態で行われる。複数マッチしてしまった場合には空文字
		列が返される。
		"" や "%" は現在のバッファを意味し、"#" は代替バッファを意味す
		る。
		完全マッチのものが優先され、完全マッチがなければ、バッファ名の
		先頭でのマッチ、末尾でのマッチ、中間でのマッチが探される。完全
		マッチのみを探すには、パターン先頭に "^" を、末尾に "$" をつけ
		る。
		まずバッファリストにあるバッファが探される。そこで1個だけマッ
		チが見つかればそれを返す。次にバッファリストにないものが探され
		る。
		{buf}が文字列のときに、それをバッファ番号として使いたいならば、
		0を足すことによって強制的に数値にすることができる: >
			echo bufname("3" + 0)
<		|method| としても使用できる: >
			echo bufnr->bufname()

<		バッファが存在しないか名前を持っていない場合には、空文字列が返
		される。 >
	bufname("#")		alternate buffer name
	bufname(3)		name of buffer 3
	bufname("%")		name of current buffer
	bufname("file2")	name of buffer where "file2" matches.
<							*buffer_name()*
		以前の名前: buffer_name().

							*bufnr()*
bufnr([{buf} [, {create}]])
		結果はバッファの番号。バッファ番号はコマンド `:ls` で表示され
		るものと同様。{buf}の使い方は前述の |bufname()| を参照。

		バッファが存在しない場合-1が返される。ただし、{create}が与えら
		れて真であるときは、バッファリストに載せない新しいバッファを作
		成し、その番号を返す。例: >
			let newbuf = bufnr('Scratch001', 1)
<		空の名前を使用すると、カレントバッファが使用される。空の名前で
		新しいバッファを作成するには、|bufadd()| を使用する。

		bufnr("$")は最後のバッファを意味する: >
			:let last_buffer = bufnr("$")
<		結果は存在しているバッファのうちで、もっとも大きなバッファ番号
		となる。Note そのバッファ番号より小さいバッファ番号を持つ(ハズ
		の)バッファが、必ずしも全て存在するとは限らない。なぜなら
		":bwipeout" がバッファを消すことができるからだ。バッファが存在
		するかテストするにはbufexists()を使う。

		|method| としても使用できる: >
			echo bufref->bufnr()
<
		以前の名前: buffer_number().		*buffer_number()*
							*last_buffer_nr()*
		bufnr("$")の以前の名前: last_buffer_nr().

bufwinid({buf})						*bufwinid()*
		その結果は数値で、バッファ{buf}に関連付けられた最初のウィンド
		ウの |window-ID|。{buf}の使い方は前述の|bufname()|を参照。バッ
		ファ{buf}が存在しないか、ウィンドウが無い場合は、-1が返される。
		例: >

	echo "A window containing buffer 1 is " .. (bufwinid(1))
<
		現在のタブページのみを処理する。さらにウィンドウを探すために
		は、|win_findbuf()| を参照。

		|method| としても使用できる: >
			FindBuffer()->bufwinid()

bufwinnr({buf})						*bufwinnr()*
		|bufwinid()| と同様だが、バッファの |window-ID| ではなくウィン
		ドウ番号を返す。バッファ{buf} が存在しないか、ウィンドウが無い
		場合には-1を返す。例: >

	echo "A window containing buffer 1 is " .. (bufwinnr(1))

<		この番号は|CTRL-W_w|や ":wincmd w" |:wincmd|で使える。

		|method| としても使用できる: >
			FindBuffer()->bufwinnr()

byte2line({byte})					*byte2line()*
		カレントバッファの先頭から{byte}番目の文字が、何行目に含まれる
		かを返す。これにはカレントバッファの 'fileformat' に依存した、
		改行文字も含まれる。先頭の文字にはバイトカウント1が与えられる。
		|line2byte()|と|go|と|:goto|も参照。

		{byte} 値が無効な場合は -1 を返す。

		|method| としても使用できる: >
			GetOffset()->byte2line()

<		{|+byte_offset| 機能付きでコンパイルされたときのみ有効}

byteidx({expr}, {nr} [, {utf16}])			*byteidx()*
		文字列{expr}の{nr}番目の文字のバイトインデックスを返す。最初の
		文字の{nr}は0であり、そして戻り値は0となる。
		マルチバイト文字がない時は{nr}に等しい値を返す。
		合成文字はまとめて計算される。合成文字のバイト数はそれが合成さ
		れているベース文字のバイト数に合算される。合成文字を別々に数え
		るには |byteidxcomp()| を参照。
		{utf16} が存在し、TRUE の場合、{nr} は文字インデックスとしてで
		はなく、文字列 {expr} 内の UTF-16 インデックスとして使用され
		る。UTF-16 インデックスは、文字列が 16 ビットワードでエンコー
		ドされたときのインデックスである。指定された UTF-16 インデック
		スが文字の途中 (例: 4 バイト文字) にある場合、その文字の最初の
		バイトのバイトインデックスが返される。詳細は
		|string-offset-encoding| を参照。
		例 : >
			echo matchstr(str, ".", byteidx(str, 3))
<		は4文字目を表示する。次も同じことをする: >
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		|strgetchar()| と |strcharpart()| も参照。
		{expr}が{nr}文字以下の場合は-1を返す。
		{expr}がちょうど{nr}文字の場合は文字列の長さ(バイト単位)を返す。
		バイトインデックスから文字インデックスと UTF-16 インデックスを
		それぞれ取得する方法については、|charidx()| と |utf16idx()| を
		参照。
		例: >
			echo byteidx('a😊😊', 2)	returns 5
			echo byteidx('a😊😊', 2, 1)	returns 1
			echo byteidx('a😊😊', 3, 1)	returns 5
<
		|method| としても使用できる: >
			GetName()->byteidx(idx)

byteidxcomp({expr}, {nr} [, {utf16}])			*byteidxcomp()*
		byteidx() と同じだが、合成文字は個別にカウントされる。例: >
			let s = 'e' .. nr2char(0x301)
			echo byteidx(s, 1)
			echo byteidxcomp(s, 1)
			echo byteidxcomp(s, 2)
<		1 番目と 3 番目は 3 が出力される ('e' の長さと合成文字の長さを
		足すと 3 バイト)。2 番目は 1 が出力される ('e' は 1 バイト)。
		'encoding' に Unicode が設定されているときのみ byteidx() と違っ
		た動作になる。

		|method| としても使用できる: >
			GetName()->byteidxcomp(idx)

call({func}, {arglist} [, {dict}])			*call()* *E699*
		リスト|List|{arglist}の要素を引数として関数{func}を呼ぶ。
		{func}は|Funcref|でも関数の名前でもよい。
		a:firstlineとa:lastlineにはカレント行が代入される。
		呼び出した関数の戻り値を返す。
		{dict}は "dict" 属性つきの関数用で、これがローカル変数 "self"
		に代入される。|Dictionary-function|を参照。

		|method| としても使用できる: >
			GetFunc()->call([arg, arg], dict)

ceil({expr})							*ceil()*
		{expr} 以上となる最小の整数を浮動小数点数 |Float| で返す
		(切り上げる)。
		{expr} は |Float| か |Number| に評価されなければならない。
		例: >
			echo ceil(1.456)
<			2.0  >
			echo ceil(-5.456)
<			-5.0  >
			echo ceil(4.0)
<			4.0

		{expr} が |Float| または |Number| でない場合は 0.0 を返す。

		|method| としても使用できる: >
			Compute()->ceil()
<

ch_ 関数群はここに文書化されている: |channel-functions-details|


changenr()						*changenr()*
		最も最近の変更の番号を返す。|:undolist|で表示される番号と同じ
		であり、|:undo|コマンドの引数として使うことができる。
		変更を行った直後ではその変更の番号となる。redoを行った直後は
		redoされた変更の番号となる。undoを行った直後はundoされた変更よ
		り1小さい番号になる。
		undo リストが空の場合は 0 を返す。

char2nr({string} [, {utf8}])					*char2nr()*
		{string}の最初の文字のASCIIコードを返す。例: >
			char2nr(" ")		returns 32
			char2nr("ABC")		returns 65
<		{utf8} を省略、またはゼロを指定すると、現在の 'encoding' が適
		用される。"utf-8" の場合の例: >
			char2nr("á")		returns 225
			char2nr("á"[0])		returns 195
<		{utf8} に真が指定された場合、常に UTF-8 文字として扱われる。
		合成文字は個別の文字として扱われる。
		|nr2char()| はこの逆を行う。
		文字列を文字の番号のリストに変換するには: >
		    let str = "ABC"
		    let list = map(split(str, '\zs'), {_, val -> char2nr(val)})
<		結果: [65, 66, 67]

		{string} が |String| でない場合は 0 を返す。

		|method| としても使用できる: >
			GetChar()->char2nr()

charclass({string})					*charclass()*
		{string} 内の最初の文字の文字クラスを返す。
		文字クラスは次のいずれか:
			0	空白
			1	区切り文字
			2	単語文字
			3	絵文字
			その他	Unicode 固有のクラス
		クラスはパターンと単語単位の移動で使われる。
		{string} が |String| でない場合は 0 を返す。

charcol({expr} [, {winid}])				*charcol()*
		|col()| と同様だが {expr} で返す桁位置がバイトインデックスでは
		なく文字インデックスになる。

		例:
		5行目のテキスト "여보세요" の '세' にカーソルがある状態: >
			charcol('.')		returns 3
			col('.')		returns 7

<		|method| としても使用できる: >
			GetPos()->col()
<
							*charidx()*
charidx({string}, {idx} [, {countcc} [, {utf16}]])
		{string} 内の {idx} バイト目の文字インデックスを返す。最初の文
		字のインデックスは0。
		マルチバイト文字がない時は {idx} に等しい値を返す。

		{countcc} がないもしくは |FALSE| の場合、合成文字は分割して文
		字としてカウントせず、先行する基底文字に合成文字のバイト長が足
		される。
		{countcc} が |TRUE| の場合、合成文字は分割した文字としてカウン
		トされる。

		{utf16} が存在し、TRUE の場合、{idx} はバイトインデックスとし
		てではなく、文字列 {expr} 内の UTF-16 インデックスとして使用さ
		れる。

		引数が無効な場合、または {idx} バイト未満の場合は -1 を返す。
		ちょうど {idx} バイトの場合は、文字列の長さが文字数で返される。

		第 1 引数が文字列でない場合、第 2 引数が数値でない場合、第 3
		引数が 0 または 1 でない場合、エラーが発生し、-1 が返される。

		文字インデックスからバイトインデックスを取得するには
		|byteidx()|と |byteidxcomp()| を、文字インデックスから UTF-16
		インデックスを取得するには、|utf16idx()| を参照。
		詳細については |string-offset-encoding| を参照。
		例: >
			echo charidx('áb́ć', 3)		returns 1
			echo charidx('áb́ć', 6, 1)	returns 4
			echo charidx('áb́ć', 16)		returns -1
			echo charidx('a😊😊', 4, 0, 1)	returns 2
<
		|method| としても使用できる: >
			GetName()->charidx(idx)

chdir({dir})						*chdir()*
		{dir}は文字列でなければならない。
		現在の作業ディレクトリを {dir} に変更する。ディレクトリの変更
		範囲は、カレントウィンドウのディレクトリによって異なる:
			- カレントウィンドウにウィンドウローカルディレクトリ
			  (|:lcd|)がある場合は、ウィンドウローカルディレクトリ
			  を変更する。
			- それ以外の場合、カレントタブページにローカルディレク
			  トリ(|:tcd|)がある場合は、タブページのローカルディレ
			  クトリを変更する。
			- それ以外の場合、グローバルディレクトリを変更する。
		成功した場合は、前の作業ディレクトリを返す。ディレクトリを復元
		するには、これを別の chdir() に渡すこと。
		失敗した場合は、空の文字列を返す。

		例: >
			let save_dir = chdir(newdir)
			if save_dir != ""
			   " ... いくつかの作業をおこなう
			   call chdir(save_dir)
			endif

<		|method| としても使用できる: >
			GetDir()->chdir()
<
cindent({lnum})						*cindent()*
		'cindent' で使われるのと同じC言語用のインデント規則に従った場
		合の{lnum}行目のインデント量を返す。
		インデント量はスペースで数えられ、'tabstop' の値は関係ない。
		{lnum}は|getline()|の場合と同様に扱われる。
		{lnum}が無効な場合は -1 を返す。
		|C-indenting|を参照。

		|method| としても使用できる: >
			GetLnum()->cindent()

clearmatches([{win}])					*clearmatches()*
		|matchadd()| と コマンド |:match| によりカレントウィンドウに定
		義されたマッチをすべて消去する。
		{win} が指定されれば、カレントウィンドウではなく指定されたウィ
		ンドウあるいはウィンドウID を対象にする。

		|method| としても使用できる: >
			GetWin()->clearmatches()
<
col({expr} [, {winid}])					*col()*
		戻り値は数値で、{expr}で与えられる位置の桁番号(バイトインデッ
		クス)。有効な位置は:
		    .	    現在の位置
		    $	    カレント行の末尾(カレント行のバイト数+1を返す)
		    'x	    マークxの位置(マークが設定されていない場合0)
		    v	    ビジュアルモードでは: ビジュアル選択領域の開始行
			    (カーソルがその端)。ビジュアルモード以外ではカーソ
			    ル位置を返す。すぐに更新される点が |'<| と違う。
		さらに {expr} は [lnum, col] という行番号と桁番号のリストで
		あってもよい。col に "$" を指定して、ある行の最後の桁を取得す
		るのにとても便利である。"lnum" か "col" が範囲外である場合は
		0 を返す。
		オプションの {winid} 引数を指定すると、カレントウィンドウでは
		なく、そのウィンドウの値が取得される。
		行番号を取得するには|line()|を使う。行番号と桁番号両方を取得す
		るには|getpos()|を使う。
		画面上の桁番号を取得するには|virtcol()|を使う。文字の位置を取
		得するには |charcol()| を使う。
		Note 現在のファイルのマークしか使えないことに注意。
		例: >
			col(".")		カーソルの桁
			col("$")		カレント行の長さ+1
			col("'t")		マークtの桁
			col("'" .. markname)	マークmarknameの桁
<		先頭の桁は1になる。{expr} が無効な場合か、{winid} のウィンドウ
		が見つからない場合は 0 を返す。
		大文字のマークは他のバッファを指しているかもしれない。
		'virtualedit' が有効なとき、カーソルが行末を越えていると、桁番
		号は行の長さより 1 大きい値を返す。また、<Cmd> マッピングを使
		うとカーソルが移動しないので、挿入モードで桁を取得するのに使え
		る: >
			:imap <F2> <Cmd>echowin col(".")<CR>

<		|method| としても使用できる: >
			GetPos()->col()
<
complete({startcol}, {matches})			*complete()* *E785*
		挿入モード補完の候補を設定する。
		挿入モードでのみ使用できる。CTRL-R = (|i_CTRL-R| を参照)と組み
		合わせてマッピングを作る必要がある。CTRL-Oの後や、<expr>マッピ
		ングの中では正しく動作しない。
		{startcol}は補完すべき単語の開始位置を示す、行内のバイトオフセッ
		トである。その位置からカーソルまでのテキストが補完すべき単語と
		なる。
		{matches}はリスト|List|でなければならない。リストの各要素が1つ
		の候補となる。この要素として許される値については
		|complete-items|を参照。
		'completeopt' の "longest" は無視される。
		Note この関数を呼んだ後は補完を停止させるようなテキストの挿入
		をしないように注意しなければならない。
		この関数で設定した候補は普通の挿入モード補完と同じ様にCTRL-Nと
		CTRL-Pで選択できる。設定されていればポップアップメニューが表示
		される。|ins-completion-menu|を参照。
		例: >
	inoremap <F5> <C-R>=ListMonths()<CR>

	func ListMonths()
	  call complete(col('.'), ['January', 'February', 'March',
		\ 'April', 'May', 'June', 'July', 'August', 'September',
		\ 'October', 'November', 'December'])
	  return ''
	endfunc
<		この例はそれほど役には立たないが、使い方を示している。Note 0が
		挿入されてしまわないように空文字列を返していることに注意。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetMatches()->complete(col('.'))

complete_add({expr})				*complete_add()*
		候補のリストに{expr}を追加する。'completefunc' で指定された関
		数の中でのみ使われる。
		失敗したときは0を返す(空文字列かメモリ不足)。候補が追加された
		ときは1を返し、その候補が既にリストに存在するときは2を返す。
		{expr}の説明については|complete-functions|を参照。'omnifunc'
		が返すリストと同じである。

		|method| としても使用できる: >
			GetMoreMatches()->complete_add()

complete_check()				*complete_check()*
		補完候補を探している間にキーがタイプされたかどうか確認する。補
		完の検索に時間がかかる場合に使われる。候補の検索を中断しようと
		しているときは|TRUE|を返す。そうでないときは0を返す。
		'completefunc' で指定された関数の中でのみ使われる。


complete_info([{what}])				*complete_info()*
		挿入モードの補完に関する情報を辞書 |Dictionary| で返す。
		|ins-completion| を参照。
		要素は以下の通り:
		   mode		現在の補完モード名の文字列。
				値は |complete_info_mode| を参照。
		   pum_visible	ポップアップメニューが表示されているなら |TRUE|
				|pumvisible()| を参照。
		   items 	補完マッチのリスト。各要素は "word", "abbr",
				"menu", "kind", "info", "user_data" を含む辞書。
				|complete-items| を参照。
		   selected	選択された補完候補のインデックス。最初のイン
				デックスが 0。どの補完候補も選択されていなけれ
				ば -1 (入力したテキストのみ表示、もしくは <Up>
				や <Down> キーを利用した最後の補完後に選択しな
				かった場合)。
		   inserted	入力された文字列。[現時点では未実装]

							*complete_info_mode*
		mode の値は:
		   ""		     補完モードでない
		   "keyword"	     キーワード補完 |i_CTRL-X_CTRL-N|
		   "ctrl_x"	     CTRL-X のみが入力された |i_CTRL-X|
		   "scroll"	     |i_CTRL-X_CTRL-E| か |i_CTRL-X_CTRL-Y|
				     でのスクロール
		   "whole_line"	     行全体補完 |i_CTRL-X_CTRL-L|
		   "files"	     ファイル名補完 |i_CTRL-X_CTRL-F|
		   "tags"	     タグ補完 |i_CTRL-X_CTRL-]|
		   "path_defines"    定義補完 |i_CTRL-X_CTRL-D|
		   "path_patterns"   インクルード補完 |i_CTRL-X_CTRL-I|
		   "dictionary"	     辞書補完 |i_CTRL-X_CTRL-K|
		   "thesaurus"	     同義語補完 |i_CTRL-X_CTRL-T|
		   "cmdline"	     Vim コマンドライン補完 |i_CTRL-X_CTRL-V|
		   "function"	     ユーザー定義補完 |i_CTRL-X_CTRL-U|
		   "omni"	     オムニ補完 |i_CTRL-X_CTRL-O|
		   "spell"	     スペル補完 |i_CTRL-X_s|
		   "eval"	     |complete()| 補完
		   "unknown"	     その他の内部モード

		オプショナル引数としてリスト {what} が与えられると、 {what} に
		ある項目のみが返る。{what} 内のサポートされていない項目は無視
		される。

		ポップアップメニューの位置とサイズを取得するには、
		|pum_getpos()| を参照。|CompleteChanged| イベント中に |v:event|
		でも利用可能である。

		エラー時は空の |Dictionary| を返す。

		例: >
			" 全ての項目を取得
			call complete_info()
			" 'mode' のみを取得
			call complete_info(['mode'])
			" 'mode' と 'pum_visible' のみを取得
			call complete_info(['mode', 'pum_visible'])

<		|method| としても使用できる: >
			GetItems()->complete_info()
<
							*confirm()*
confirm({msg} [, {choices} [, {default} [, {type}]]])
		confirm()はユーザーに選択させるためのダイアログを提供する。戻
		り値は選択した番号になる。最初の選択肢が1である。
		Note: confirm()は、ダイアログサポートを有効にしてコンパイルし
		た時にだけ動作する。|+dialog_con|, |+dialog_con_gui| と
		|+dialog_gui| を参照。

		ダイアログには{msg}に加えて{choices}の選択肢が表示される。
		{choices}が指定されない、または空の場合は選択肢 "&OK" が表示さ
		れる(使用している言語に翻訳される)。
		{msg}は文字列で '\n' を改行として使用できる。幾つかのシステム
		では、長すぎる行は自動的に折り返される。

		{choices}は文字列で、個々の選択肢は '\n' によって区切られる。
		例: >
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
<		'&' の後の文字は選択肢のショートカットキーになる。この場合
		"Cancel" を選択するのに 'c' をタイプすることができる。ショート
		カットキーは最初の文字である必要は無い: >
			confirm("file has been modified", "&Save\nSave &All")
<		コンソールでは、デフォルトのショートカットキーとして、各選択肢
		の最初の文字が使われる。大文字小文字は区別されない。

		省略可能な引数{default}は<CR>キーを叩いた時に選択される選択肢
		の番号を指定する。最初の選択肢をデフォルトにするならば1を使用
		する。デフォルトを設定したくないのならば0を使用する。
		{default}を省略した場合、1が使用される。

		省略可能な文字列引数{type}はダイアログの種類を指定する。これは
		GTK, Mac, Motif, Win32 の GUI でアイコンを指定するのに使われ
		る。"Error", "Question", "Info", "Warning", "Generic" のうちど
		れか一つを指定する。以上のうちの先頭の文字だけで指定できる。
		{type} が省略された場合、"Generic" が使用される。

		ユーザーが<Esc>やCTRL-Cや、その他の割りこみキーでダイアログを
		中断した場合、confirm()は0を返す。

		例: >
		   let choice = confirm("What do you want?",
					\ "&Apples\n&Oranges\n&Bananas", 2)
		   if choice == 0
			echo "make up your mind!"
		   elseif choice == 3
			echo "tasteful"
		   else
			echo "I prefer bananas myself."
		   endif
<		GUIのダイアログではボタンが使用される。ボタンの配置は
		'guioptions' の 'v' フラグに依存する。もしも 'v' フラグが含ま
		れているのなら、ボタンは常に垂直に配置される。そうでなければ水
		平に配置しようと試みられる。水平配置がうまくマッチしない場合
		は、垂直配置が使われる。幾つかのシステムでは常に水平配置が使わ
		れる。

		|method| としても使用できる: >
			BuildMessage()->confirm("&Yes\n&No")
<
							*copy()*
copy({expr})	{expr}のコピーを作る。数値と文字列の場合は、{expr}そのものとコ
		ピーの間に違いはない。
		{expr}がリスト|List|の場合は浅いコピーを作る。つまり元のリスト
		を変更してもコピーは変更されず、逆も同じである。しかし要素は共
		通で、片方の要素に対し変更を加えると、もう一方の要素も変更され
		る。
		辞書はリストと同様な方法でコピーされる。
		|deepcopy()|も参照。
		|method| としても使用できる: >
			mylist->copy()

cos({expr})						*cos()*
		{expr} の余弦(コサイン)をラジアンで浮動小数点数 |Float| で返す。
		{expr} は |Float| または |Number| に評価されなければならない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo cos(100)
<			0.862319 >
			:echo cos(-4.01)
<			-0.646043

		|method| としても使用できる: >
			Compute()->cos()


cosh({expr})						*cosh()*
		{expr} の双曲線余弦 (ハイパボリックコサイン) を返す。
		値は [1, inf] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か 数値 (|Number|) でなければ
		ならない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo cosh(0.5)
<			1.127626 >
			:echo cosh(-0.5)
<			-1.127626

		|method| としても使用できる: >
			Compute()->cosh()


count({comp}, {expr} [, {ic} [, {start}]])		*count()* *E706*
		文字列|String|、リスト|List|または辞書|Dictionary| {comp} の中
		に値 {expr} が何回現れるかを返す。

		{start} が指定されたときはそのインデックスの要素から検索を開始
		する。{start} は {comp} がリストの場合のみ使用できる。

		{ic} が指定され、|TRUE|の場合は大文字・小文字は区別されない。

		{comp} が文字列の場合、オーバーラップしていない {expr} の回数
		が返される。{expr} が空文字列の場合は 0 が返る。

		|method| としても使用できる: >
			mylist->count(val)
<
							*cscope_connection()*
cscope_connection([{num} , {dbpath} [, {prepend}]])
		|cscope|接続が存在するかどうか判定する。引数が1個も指定されな
		かった場合、戻り値は以下のようになる:
			0, cscopeが利用できない(コンパイル時に無効化されている)
			   またはcscope接続が存在しない場合
			1, 1個以上のcscope接続が存在する場合

		引数が与えられた場合は次のようになる。{num}は、接続の存在を確
		認する際のマッチング方法を指定する。

		{num}	存在確認の方法
		-----	------------------------------
		0	引数なしの場合と同じ (例: "cscope_connection()")。
		1	{prepend}を無視し、{dbpath}に部分マッチを行う。
		2	{prepend}を無視し、{dbpath}に部分マッチを行う。
		3	{prepend}を使用し、{dbpath}と{prepend}に部分マッチを行
			う。
		4	{prepend}を使用し、{dbpath}と{prepend}に完全マッチを行
			う。

		Note: 以上のどの場合も文字列の比較は大文字・小文字を区別する。

		例: ":cs show" の表示が以下のようになったとする: >

  # pid    database name			prepend path
  0 27664  cscope.out				/usr/local
<
		実行						戻り値 ~
		----------					---------- >
		cscope_connection()					1
		cscope_connection(1, "out")				1
		cscope_connection(2, "out")				0
		cscope_connection(3, "out")				0
		cscope_connection(3, "out", "local")			1
		cscope_connection(4, "out")				0
		cscope_connection(4, "out", "local")			0
		cscope_connection(4, "cscope.out", "/usr/local")	1
<
cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
		{lnum}行目の{col}桁目(バイトで数える)にカーソルを移動させる。
		桁番号{col}は1から始まる。

		引数に {list} が 1 つだけ指定された場合は、それは要素が 2 個か
		3 個、または 4 個の |List| として解釈される:
			[{lnum}, {col}]
			[{lnum}, {col}, {off}]
			[{lnum}, {col}, {off}, {curswant}]
		これは |getpos()| や |getcurpos()| の戻り値とほぼ同じである。
		違いは最初の要素がないこと。

		{col} を文字数として使用してカーソルを配置するには、
		|setcursorcharpos()| を使う。

		この関数を呼んでもジャンプリストは変更されない。
		{lnum} は |getline()| と同様に使用されるが、{lnum} がゼロの場
		合、カーソルはカレント行に留まる。
		{lnum}がバッファの行数よりも大きい場合は、最後の行へ移動する。
		{col}がその行のバイト数より大きい場合は、その行の最後の文字へ
		移動する。
		{col}が0の場合は、カレント桁に留まる。
		{curswant} が与えられた場合は、縦方向移動の優先的列番号として
		使われる。指定がない場合は {col} が使われる。

		'virtualedit' が有効のとき、{off}は文字の先頭からの画面上のオ
		フセットを指定する。例えば、<Tab>の中の位置や最後の文字より後
		などへも移動できる。
		カーソルを移動できたときは 0 を、できなかったときは-1 を返す。

		|method| としても使用できる: >
			GetCursorPos()->cursor()

debugbreak({pid})					*debugbreak()*
		主にデバッグしているプログラムに割り込むために使用される。プロ
		セス {pid} に対して SIGTRAP を発生させる。関係のないプロセスへ
		の振る舞いは未定義である。|terminal-debugger| を参照。
		{MS-Windows 上でのみ有効}

		正常にプログラムが中断された場合、|TRUE| を返す。それ以外の場
		合は |FALSE| を返す。

		|method| としても使用できる: >
			GetPid()->debugbreak()

deepcopy({expr} [, {noref}])				*deepcopy()* *E698*
		{expr}のコピーを作る。数値と文字列の場合は、{expr}そのものとコ
		ピーの間に違いはない。
		{expr}がリスト|List|の場合は完全なコピーを作る。つまり元のリス
		トを変更してもコピーは変更されず、逆も同じである。要素の1つが
		リストまたは辞書であるときは、再帰的にコピーが作成される。
		よってコピーの要素に変更を加えても元のリストの要素は変更を受け
		ない。
		辞書はリストと同様な方法でコピーされる。

		{noref}が省略された、または0のとき、含まれているリストや辞書は
		1度だけコピーされる。全ての参照はこのただ1つのコピーを指す。
		{noref}が1の場合、リストや辞書は現れるたびに新しいコピーが作ら
		れる。そのため循環参照があるとdeepcopy()は失敗する。
								*E724*
		ネストは100レベルまで可能である。それ以上参照を繰り返している
		要素があると、{noref}が1の場合は失敗する。
		|copy()|も参照。

		|method| としても使用できる: >
			GetObject()->deepcopy()

delete({fname} [, {flags}])				*delete()*
		{flags}を指定しないもしくは{flags}を空で指定した場合: ファイル
		{fname}を削除する。

		これは{fname}がシンボリックリンクの時でも動作し、シンボリック
		リンクは、それが示すものではなく、リンク自身が削除される。

		{flags}が "d" の場合: ディレクトリ{fname}を削除する。
		これはディレクトリ{fname}が空でない場合は失敗する。

		{flags}が "rf" の場合: ディレクトリ{fname}、その中に含むすべて
		のものを再帰的に削除する。気をつけて！
		Note: MS-Windowsでは、使用中のディレクトリを削除することはでき
		ない。

		結果は数値であり、削除に成功すれば 0/false、削除に(部分的にで
		も)失敗すれば -1/true である。

		リスト |List| から項目を削除するには |remove()| を使う。
		バッファから行を削除するには|:delete|もしくは|deletebufline()|
		を使う。

		|method| としても使用できる: >
			GetName()->delete()

deletebufline({buf}, {first} [, {last}])		*deletebufline()*
		{first} から {last} (を含む) までの行をバッファ {buf} から削除
		する。{last} が省略されている場合、{first} 行だけを削除する。
		成功時には 0 が返され、失敗時には 1 が返される。

		この関数は、ロードされたバッファに対してのみ機能する。必要であ
		れば、最初に |bufload()| を呼び出すこと。

		{buf} の使い方は前述の |bufname()| を参照。

		{first} および {last} は |getline()| と同様に扱われる。Note:
		|line()| の使用はカレントバッファを参照する。バッファ {buf} 内
		の最後の行を参照するには "$" を使用する。

		|method| としても使用できる: >
			GetBuffer()->deletebufline(1)
<
							*did_filetype()*
did_filetype()	autocommandが実行されFileTypeイベントが一度でも起こっていれば、
		|TRUE|が返る。スクリプトのFileTypeイベントが、複数回呼び出され
		るのを回避するのに使える。 |FileType|
		`:setf FALLBACK` が使用されている場合は |FALSE| を返す。
		他のファイルへ移動すると、このカウンタはリセットされる。よって
		実際は、カレントバッファに対してFileTypeイベントが発生したかど
		うかを判定する。他のバッファを開く自動コマンドの中でこの関数を
		使って 'filetype' を設定し、構文ファイルを読み込むために使え
		る。

diff({fromlist}, {tolist} [, {options}])		*diff()*
		{fromlist} と {tolist} の文字列の差分を含む文字列またはリスト
		を返す。Vim の内部 diff ライブラリを使用して差分を計算する。

							*E106*
		{options} のオプションの "output" 項目は、返される diff 形式を
		指定する。次の値がサポートされている:
		    indices	開始インデックスと終了インデックスのリストと、
				各 diff hunk (差分の塊) 内の文字列数を返す。
		    unified	unified diff 出力を文字列として返す。
				これがデフォルトである。

		{options} の "output" 項目が "indices" の場合、リストが返され
		る。各リスト項目には、各 diff hunk (差分の塊) の以下の項目を含
		む辞書が含まれている:
		    from_idx	この diff hunk の {fromlist} 内の開始インデッ
				クス。
		    from_count	この diff hunk で追加/削除/変更された
				{fromlist} 内の文字列数。
		    to_idx	この diff hunk の {tolist} 内の開始インデック
				ス。
		    to_count	この diff hunk で追加/削除/変更された {tolist}
				内の文字列数。

		{options} 辞書引数は diff オプション ('diffopt' と同様) も指定
		し、以下の項目をサポートする:
		    algorithm		使用する diff アルゴリズムを指定する辞
					書。サポートされている真偽値項目は
					"myers", "minimal", "patience",
					"histogram"。
		    context		diff context の長さ。デフォルトは 0。
		    iblank		行がすべて空白の変更は無視する。
		    icase		テキストの大小文字の変更を無視する。
		    indent-heuristic	内部 diff ライブラリのインデントヒュー
					リスティックを使用する。
		    iwhite		空白の量の変化を無視する。
		    iwhiteall		すべての空白の変更を無視する。
		    iwhiteeol		行末の空白の変更を無視する。
		これらのオプションの詳細については、'diffopt' を参照。

		Unified diff を計算するために、{fromlist} のすべての項目は改行
		区切りを用いてひとつの文字列に連結される。{tolist} も同様であ
		る。Unified diff の出力は行番号を用いる。

		{fromlist} と {tolist} が同一の場合、空のリストまたは文字列を
		返す。

		例: >
		    :echo diff(['abc'], ['xxx'])
		     @@ -1 +1 @@
		     -abc
		     +xxx

		    :echo diff(['abc'], ['xxx'], {'output': 'indices'})
		     [{'from_idx': 0, 'from_count': 1, 'to_idx': 0, 'to_count': 1}]
		    :echo diff(readfile('oldfile'), readfile('newfile'))
		    :echo diff(getbufline(5, 1, '$'), getbufline(6, 1, '$'))
<
		その他の例については、|diff-func-examples| を参照

		|method| としても使用できる: >
			GetFromList->diff(to_list)
<
diff_filler({lnum})					*diff_filler()*
		{lnum}行目より上にある削除行の数を返す。削除行とは、差分モード
		で他方のウィンドウにテキストが挿入されていることを表す行のこと
		である。削除行は表示はされているが、実際にはバッファに存在しな
		い。
		{lnum}は|getline()|と同様に扱われる。つまり "." はカレント行と
		なり、"'m" はマークmを表す。
		カレントウィンドウが差分モードでないときは0を返す。

		|method| としても使用できる: >
			GetLnum()->diff_filler()

diff_hlID({lnum}, {col})				*diff_hlID()*
		差分モードで{lnum}行{col}桁(バイト単位)の位置のハイライトIDを
		返す。カレント行に変更がないときは0を返す。
		{lnum}は|getline()|と同様に扱われる。つまり "." はカレント行と
		なり、"'m" はマークmを表す。
		先頭の桁の{col}は1となり、最初の行の{lnum}は1となる。
		ハイライトIDは|synIDattr()|を使って構文情報を得るために使える。

		|method| としても使用できる: >
			GetLnum()->diff_hlID(col)
<

digraph_get({chars})					*digraph_get()* *E1214*
		{chars} のダイグラフを返す。これは正確に2文字の文字列である必
		要がある。もし {chars} が2文字ちょうどでない、もしくは {chars}
		のダイグラフがないなら、エラーとなり空文字列を返す。

		必要であれば文字はUnicodeから 'encoding' に変換される。変換が
		利用可能である必要があり、失敗することがある。

		|digraph_getlist()| も参照。

		例: >
		" 組み込みのダイグラフの取得
		:echo digraph_get('00')		" '∞' が返る

		" ユーザー定義のダイグラフの取得
		:call digraph_set('aa', 'あ')
		:echo digraph_get('aa')		" 'あ' が返る
<
		|method| としても使用できる: >
			GetChars()->digraph_get()
<
		この関数は |+digraphs| 機能付きでコンパイルされたときのみ動作
		する。機能が無効の場合、この関数はエラーメッセージを表示する。


digraph_getlist([{listall}])				*digraph_getlist()*
		ダイグラフのリストを返す。引数 {listall} が真で与えられたとき、
		デフォルトのダイグラフを含む全ダイグラフを返す。それ以外はユー
		ザー定義のダイグラフのみを返す。

		必要であれば文字はUnicodeから 'encoding' に変換される。変換が
		利用可能である必要があり、失敗することがある。

		|digraph_get()| も参照。

		例: >
		" ユーザー定義のダイグラフの取得
		:echo digraph_getlist()

		" デフォルトを含む全ダイグラフの取得
		:echo digraph_getlist(1)
<
		|method| としても使用できる: >
			GetNumber()->digraph_getlist()
<
		この関数は |+digraphs| 機能付きでコンパイルされたときのみ動作
		する。機能が無効の場合、この関数はエラーメッセージを表示する。


digraph_set({chars}, {digraph})				*digraph_set()*
		ダイグラフ {chars} をリストに追加する。{chars} は2文字の文字列
		の必要がある。{digraph} はUTF-8でエンコードされた1文字の文字
		列。 *E1215*
		合成文字は無視されないことに注意。この関数は |:digraphs| と同
		様だがスペース始まりのダイグラフを登録するのに便利である。

		この関数はダイグラフ |digraph| は登録されたなら v:true を返す。
		もし失敗したなら、エラーメッセージとともに v:false を返す。

		一度に複数のダイグラフを登録したいなら、|digraph_setlist()| が
		使える。

		例: >
			call digraph_set('  ', 'あ')
<
		|method| としても使用できる: >
			GetString()->digraph_set('あ')
<
		この関数は |+digraphs| 機能付きでコンパイルされたときのみ動作
		する。機能が無効の場合、この関数はエラーメッセージを表示する。


digraph_setlist({digraphlist})				*digraph_setlist()*
		|digraph_set()| と同じだが複数のダイグラフを一度に追加できる。
		{digraphlist} はリストのリストで、各リストは |digraph_set()|
		と同じ {chars} と {digraph} の2つの文字列を持つ。 *E1216*
		例: >
		    call digraph_setlist([['aa', 'あ'], ['ii', 'い']])
<
		これは以下と似ている: >
		    for [chars, digraph] in [['aa', 'あ'], ['ii', 'い']]
			  call digraph_set(chars, digraph)
		    endfor
<		しかし、この関数は最初のエラーでリターンし、それ以降のダイグラ
		フは追加されない点が異なる。

		|method| としても使用できる: >
		    GetList()->digraph_setlist()
<
		この関数は |+digraphs| 機能付きでコンパイルされたときのみ動作
		する。機能が無効の場合、この関数はエラーメッセージを表示する。


echoraw({string})					*echoraw()*
		{string}を表示不可能な文字を含み、そのまま出力する。これは端末
		コードを出力するために使える。例えば、modifyOtherKeysを無効に
		するためには: >
			call echoraw(&t_TE)
<		さらに再度有効にするためには: >
			call echoraw(&t_TI)
<		この方法でターミナルを壊すことができるため、気を付けて取り扱う
		こと。

empty({expr})						*empty()*
		{expr}が空なら1を、そうでなければ0を返す。
		- リスト|List|または辞書|Dictionary|は要素を1個も持たないとき
		  空とみなされる。
		- 文字列 |String| はその長さが0のとき空とみなされる。
		- 数値と浮動小数点数は値が0のとき空とみなされる。
		- |v:false|, |v:none|, |v:null| は空であり、|v:true| は空では
		  ない。
		- ジョブ |Job| は開始に失敗したときは空である。
		- チャネル |Channel| は閉じられていると空である。
		- |Blob| はその長さが0のときは空である。
		- |Object| はオブジェクトの empty() メソッドが (もし存在し) 真
		  を返すとき空である。|object-empty()|

		長いリストに対しては長さを0と比較するよりこちらの方がずっと高
		速である。

		|method| としても使用できる: >
			mylist->empty()

environ()						*environ()*
		すべての環境変数を辞書として返す。このように環境変数が存在する
		かどうかを確認できる: >
			:echo has_key(environ(), 'HOME')
<		Note 変数名はキャメルケース(CamelCase)でも構わない。大文字と小
		文字を区別しないためにこれを使用すること: >
			:echo index(keys(environ()), 'HOME', 0, 1) != -1

err_teapot([{expr}])					*err_teapot()*
		RFC 2324 の実装に必要な 418 番のエラーを生成する。
		{expr} が提示され、それが TRUE である場合、エラー 503 が与えら
		れ、コーヒーが一時的に使用できないことを示す。
		{expr} が提示される場合は文字列でなければならない。


escape({string}, {chars})				*escape()*
		{string}内に現れる{chars}の文字をバックスラッシュでエスケープ
		する。例: >
			:echo escape('c:\program files\vim', ' \')
<		結果: >
			c:\\program\ files\\vim
<		|shellescape()| および |fnameescape()| も参照。

		|method| としても使用できる: >
			GetText()->escape(' \')
<
							*eval()*
eval({string})	{string}を評価し、値を返す。|string()|の戻り値を元の値に戻すの
		に非常に便利である。数値、浮動小数点数、文字列、Blob およびそ
		れらの複合に対して動作する。実際に存在する関数への |Funcref|
		に対しても動作する。|Vim9| script においては、完全修飾名から
		|enum| の値を取得するのに使用できる。

		|method| としても使用できる: >
			argv->join()->eval()

eventhandler()						*eventhandler()*
		イベントハンドラの中では1を返す。つまり、ユーザーの文字入力を
		待っている間に、ファイルをドラッグ＆ドロップするなど割り込みさ
		れたことを表す。このときは対話的なコマンドは使えない。イベント
		ハンドラの中でないときは0を返す。

executable({expr})					*executable()*
		{expr}という名前の実行可能ファイルが存在するかどうか判定する。
		{expr}は引数を何もつけないプログラム名でなければならない。
		executable()は$PATHと通常のプログラム検索ディレクトリを参照す
		る。					*PATHEXT*
		MS-Windowsでは ".exe"、".bat" などの拡張子は含めても含めなくて
		もよい。省略された場合は$PATHEXTの拡張子を検索する。よって
		"foo.exe" が存在しなければ "foo.exe.bat" が見つかることもあり
		うる。$PATHEXTが存在しなければ ".com;.exe;.bat;.cmd" が使われ
		る。$PATHEXTにドットだけを含めると拡張子なしの名前を検索するこ
		とができる。'shell' がUnixシェルのように思われるときは、{expr}
		の後に拡張子をつけない名前も検索される。
		MS-Windowsではファイルが存在するかどうかだけを判定し、それが
		ディレクトリでないことや、それが本当に実行可能であるかどうかは
		判定されない。
		MS-WindowsではVimと同じディレクトリにある実行ファイルは通常は
		発見できる。Vimがこのディレクトリを$PATHに加えるためであ
		る |win32-PATH|。これは、$NoDefaultCurrentDirectoryInExePath
		環境変数を設定することで無効にできる。
		*NoDefaultCurrentDirectoryInExePath*
		戻り値は数値:
			1	存在する
			0	存在しない
			-1	このシステム上では実装されていない
		|exepath()| は、実行ファイルの絶対パスを取得するのに使用するこ
		とができる。

		|method| としても使用できる: >
			GetCommand()->executable()

execute({command} [, {silent}])					*execute()*
		単一あるいは複数のExコマンドを実行して、出力を文字列として返
		す。
		{command} は文字列かリストを使える。リストの場合はそれらの行は
		1 行ずつ実行される。
		これは多かれ少なかれ以下と同等である: >
			redir => var
			{command}
			redir END
<		ただし、{command} 内の行継続は認識されない。

		オプションの {silent} の引数は以下の値を取ることができる:
			""		`:silent` を使わない
			"silent"	`:silent` を使う
			"silent!"	`:silent!`を使う
		デフォルトは "silent" である。Note "silent!" は `redir` とは異
		なり、エラーメッセージは削除されることに注意すること。もし外部
		コマンドを使って画面がおかしくなる様であれば、代わりに
		`system()`を使うことができる。
							*E930*
		{command} の中のどこかで`:redir`を使うことができない。

		行のリストを得るために、出力に `split()` を使うことができる: >
			execute('args')->split("\n")

<		現在のウィンドウとは別のウィンドウでコマンドを実行するには
		`win_execute()` を使用すること。

		再帰的に使用されると、再帰呼び出しの出力は、上位呼び出しの出力
		に含まれない。

		|method| としても使用できる: >
			GetCommand()->execute()

exepath({expr})						*exepath()*
		{expr} が実行ファイルで、それが絶対パス、相対パス、または
		$PATH の中に存在する場合は、そのフルパスを返す。
		Note: {expr} が "./" で開始している場合はカレントディレクトリ
		が使われる。Vim のパスを得る場合に問題になるかもしれない: >
			echo exepath(v:progpath)
<		{expr} が $PATH の中に見つからないか、それが実行ファイルではな
		かった場合は空文字列が返る。

		|method| としても使用できる: >
			GetCommand()->exepath()
<
							*exists()*
exists({expr})	結果は数値で、変数{expr}が存在すれば|TRUE|となり、そうでなけれ
		ば0となる。

		Note: コンパイルされる |:def| 関数は実行時に評価が完了する。
                `exists_compiled()` を使うことでコンパイル時に式が評価される。

		ある機能がサポートされているか判定するには|has()|を使う。
		ファイルが存在するかを判定するには|filereadable()|を使う。

		引数{expr}は文字列で次のうちいずれかである。
			varname		内部変数(|internal-variables|)
			dict.key	|curly-braces-names|, |Dictionary|の要
			list[i]		素、|List|の要素、クラスとオブジェクト
			import.Func	のメソッド、import要素などに対しても動
			class.Func	作する。
			object.Func	コンパイルされる |:def| 関数内のローカ
			class.varname	ル変数には動作しない。
			object.varname	また関数参照が使用できるため、|Vim9|
					script の関数でも動作する。
					インデックスの評価で無効な式であるとエ
					ラーメッセージが出る可能性があることに
					注意。例: >
					   :let l = [1, 2, 3]
					   :echo exists("l[5]")
<					   0 >
					   :echo exists("l[xx]")
<					   E121: Undefined variable: xx
					   0
			&option-name	Vimオプション(存在するかだけを判定し、
					本当に動作するかは判定しない)
			+option-name	動作するVimオプション
			$ENVNAME	環境変数(空文字列と比較することでも判
					定できる)
			*funcname	組み込み関数(|functions|参照)かユーザー
					が定義した関数(|user-functions|参照)の
					内、実装済みのもの。また Funcref であ
					る変数に対しても動作する。
			?funcname	実装されているかもしれない組み込み関数。
					"funcname" が有効かチェックするのに利
					用できる。
			:cmdname	exコマンド: 組み込みコマンド、ユーザー
					定義コマンド、コマンド修飾子|:command|。
					戻り値:
					1  コマンド名の先頭に一致
					2  コマンド名に完全一致
					3  複数のユーザー定義コマンドに一致
					コマンドが定義されているかどうかを判定
					するには、必ず戻り値が2であるかを確認
					すること。
			:2match		|:2match| コマンド。
			:3match		|:3match| コマンド (ただし、内部使用の
					ために予約されているため、おそらく使用
					すべきではない)
			#event		このイベントに対する自動コマンド定義
			#event#pattern	このイベントとパターンに対する自動コマ
					ンド定義(パターンは文字そのままに解釈
					され、自動コマンドのパターンと1文字ず
					つ比較される)
			#group		自動コマンドグループが存在するか
			#group#event	このグループとイベントに対して自動コマ
					ンドが定義されているか
			#group#event#pattern
					このグループ、イベント、パターンに対す
					る自動コマンド定義
			##event		このイベントに対する自動コマンドがサ
					ポートされているか

		例: >
			exists("&shortname")
			exists("$HOSTNAME")
			exists("*strftime")
			exists("*s:MyFunc")	" 旧来のスクリプトのみ
			exists("*MyFunc")
			exists("bufcount")
			exists(":Make")
			exists("#CursorHold")
			exists("#BufReadPre#*.gz")
			exists("#filetypeindent")
			exists("#filetypeindent#FileType")
			exists("#filetypeindent#FileType#*")
			exists("##ColorScheme")
<		シンボルである&/$/*と名前の間には、空白文字があってはならな
		い。
		ある少数の場合では無視されるが、名前の後に余計な文字があっては
		ならない。将来はもっと厳格になる可能性があるので、現在許される
		からといって頼ってはならない。
		正しい例: >
			exists(":make")
<		正しくない例: >
			exists(":make install")

<		Note 引数は変数そのものではなく、文字列でなければならない。例
		えば、次は動作しない: >
			exists(bufcount)
<		これは変数 "bufcount" の存在を判定するのではなく、bufcountの値
		を渡し、それが存在するかどうか判定してしまう。

		|method| としても使用できる: >
			Varname()->exists()
<

exists_compiled({expr})					*exists_compiled()*
		`exists()` と同様だがコンパイル時に評価を行う。関数にあるブロッ
		クが使うとエラーになってしまう場合にスキップするに便利である:
		>
			if exists_compiled('*ThatFunction')
			   ThatFunction('works')
			endif
<		`exists()` を使った場合はコンパイル時に ThatFunction() が未定
		義だとエラーになる。

		{expr} は文字列定数の必要がある。 *E1232*
		|:def| 関数の中で使える。 *E1233*
		引数やローカル変数のチェックには機能しない。


exp({expr})							*exp()*
		{expr} の指数を返す。
		値は [0, inf] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か数値 (|Number|) でなければな
		らない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo exp(2)
<			7.389056 >
			:echo exp(-1)
<			0.367879

		|method| としても使用できる: >
			Compute()->exp()


expand({string} [, {nosuf} [, {list}]])				*expand()*
		ワイルドカードと{string}内の特殊なキーワードを展開する。
		'wildignorecase' が適用される。

		{list} が指定されその値が|TRUE|なら、結果はリストで返される。
		そうでない場合は結果は文字列で返される。その場合、複数のマッチ
		があるときはそれらは文字 <NL> で区切られる。[Note: バージョン
		5.0 では空白文字が用いられ、スペースを含むファイル名について問
		題を引き起こしていた]

		展開が失敗した場合、結果は空文字列となる。{string} が
		'%'、'#'、'<' で始まらない限り、存在しないファイル名というの
		は、結果の文字列には含まれない。下記を参照のこと。

		|:terminal| のウィンドウに対しては、'%' は '!' とそれに続く実
		行中のコマンドまたはシェルに展開される。|terminal-bufname|

		{string} が '%' か '#' か '<' で始まる場合には、展開は
		|cmdline-special|のように、変換子を受け付け、それらに関連付け
		られた変換が施される。ここに簡単な概略を示す:

			%		現在のファイル名
			#		代替バッファのファイル名
			#n		n番の代替バッファのファイル名
			<cfile>		カーソルの下のファイル名
			<afile>		autocmdのファイル名
			<abuf>		autocmdのバッファ名
			<amatch>	autocmdのマッチした名称
			<cexpr>		カーソル下のC言語の式
			<sfile>		取り込み(source)中のファイル名、関数名
			<slnum>		取り込み(source)中の行番号または関数内
					の行番号
			<sflnum>	スクリプトファイルの行番号。関数内でも
					同様。
			<SID>		"<SNR>123_"  ここで "123" は現在のスク
					リプトのID |<SID>|
			<script>	取り込み(source)中のファイル名、あるい
					は現在の関数が定義されたスクリプトファ
					イル名
			<stack>		コールスタック
			<cword>		カーソル下の単語(word)
			<cWORD>		カーソル下の単語(WORD)
			<client>	最後に受け取ったメッセージの{clientid}
					|server2client()|
		変換子:
			:p		フルパス名を展開
			:h		ヘッド(ディレクトリ)
			:t		テイル(ファイル名だけ)
			:r		拡張子が削除される
			:e		拡張子だけ

		例: >
			:let &tags = expand("%:p:h") .. "/tags"
<		'%' や '#' や '<' で始まる文字列を展開する時には、それに続くテ
		キストは無視されることに注意。従ってこれは正しくない: >
			:let doesntwork = expand("%:h.bak")
<		こうすると良い: >
			:let doeswork = expand("%:h") .. ".bak"
<		"<cfile>" やそれらを展開する時には、戻り値が完全な展開をされな
		い参照名であることにも注意が必要。もしも "<cfile>" が
		"~/.cshrc" であった場合、"~/" を展開してホームディレクトリにす
		るために、もう一度expand()を呼び出す必要がある: >
			:echo expand(expand("<cfile>"))
<
		変数と変換子の間には空白文字があってはならない。関数
		|fnamemodify()|が通常のファイル名の変換には使用可能である。

		カレントバッファや代替バッファの名前が未定義のときに '%' や
		'#' を使うと空文字列になる。"%:p" を名無しのバッファに使用した
		場合、結果はカレントディレクトリに '/' が付加されたものになる。
		'verbose' が設定されていると、'%', '#' および <> の項目を展開
		できない場合、エラーメッセージが表示される。

		'%' や '#' や '<' で始まらない{string}は、コマンドラインのファ
		イル名と同じように展開される。{nosuf}引数に|TRUE|を指定しない
		限り、'suffixes' と 'wildignore' が使用される。
		存在しないファイルの名前も結果の文字列に含まれる。"**" を使う
		とディレクトリツリーを検索できる。例えば、カレントディレクトリ
		以下にある全ての "README" を見つけるには次のようにする: >
			:echo expand("**/README")
<
		expand() はシェルの持っている変数や環境変数を展開できる。しか
		し展開のためにシェルを起動するかもしれないので速度が遅くなるこ
		とがある。|expr-env-expand| 参照。
		展開された変数はファイル名のリストのように扱われる。環境変数を
		展開できないときはそのままになる。よって、
		":echo expand('$FOOBAR')" の結果は "$FOOBAR" となる。

		存在するファイルを探すには|glob()|を参照。外部コマンドの「生
		の」実行結果を扱うには|system()|を参照。

		|method| としても使用できる: >
			Getpattern()->expand()

expandcmd({string} [, {options}])			*expandcmd()*
		`:edit` などのExコマンドに対しておこなわれているように、文字列
		{string} の特殊な項目を展開する。これは {string} の中のどこで
		も、|expand()| のような特殊なキーワードと環境変数を展開する。
		"~user" および "~/path" は冒頭でのみ展開される。

		引数の辞書 {options} は以下の項目をサポートする:
		    errmsg	TRUEに設定された場合、展開中に遭遇したエラーの
				エラーメッセージを表示する。デフォルトでは、エ
				ラーメッセージは表示されない。

		展開された文字列を返す。展開中にエラーに遭遇した場合、変更され
		ていない {string} を返す。

		例: >
			:echo expandcmd('make %<.o')
			make /path/runtime/doc/builtin.o
			:echo expandcmd('make %<.o', {'errmsg': v:true})
<
		|method| としても使用できる: >
			GetCommand()->expandcmd()
<
extend({expr1}, {expr2} [, {expr3}])			*extend()*
		{expr1}と{expr2}は両方ともリスト|List|であるか、両方とも辞書
		|Dictionaries|でなければならない。

		両方ともリストであるなら、{expr2}を{expr1}に付け加える。
		{expr3}が指定された場合は、{expr1}の第{expr3}番目の要素の前に
		{expr2}の要素を挿入する。{expr3}が0のときは最初の要素の前に挿
		入する。{expr3}がlen({expr1})に等しいときは末尾に{expr2}が付け
		加えられる。
		例: >
			:echo sort(extend(mylist, [7, 5]))
			:call extend(mylist, [2, 3], 1)
<		{expr1} が {expr2} と同じリストである場合、コピーされる要素の
		数はリストの元の長さと同じである。
		例として {expr3} が 1 のとき、最初の要素の N 個の新しいコピー
		が挿入される(ここで N はリストの元の長さ)。
		リストに1個の要素を加えるには|add()|を使う。2つのリストを連結
		して新しいリストを作るには演算子+を使う: >
			:let newlist = [1, 2, 3] + [4, 5]
<
		両方とも辞書である場合:
		{expr2}の全要素を{expr1}に加える。
		{expr1}と{expr2}で共通のキーがある場合は、{expr3}によって動作
		が決まる:
		{expr3} = "keep" の場合: {expr1}の値そのままにする
		{expr3} = "force" の場合: {expr2}の値で上書きする
		{expr3} = "error" の場合: エラーメッセージを表示する	*E737*
		{expr3}が省略された場合は "force" と同じになる。

		{expr2}が空でないならば{expr1}が変更される。必要ならば最初に
		{expr1}のコピーを作ること。
		{expr2}は変更されない。
		{expr1} がロックされていて、かつ {expr2} が空でない場合は操作
		は失敗する。
		{expr1}を返す。エラー時は 0 を返す。

		|method| としても使用できる: >
			mylist->extend(otherlist)


extendnew({expr1}, {expr2} [, {expr3}])			*extendnew()*
		|extend()| と同様だが、{expr1} へ要素を追加する代わりに、新し
		いリストまたは辞書が作成されて返される。{expr1} は変更されな
		い。


feedkeys({string} [, {mode}])				*feedkeys()*
		{string}中の各文字を、あたかもマッピングまたはユーザーによって
		タイプされたかのように、処理キューに入れる。

		デフォルトではこれらの文字は先行入力バッファの末尾に付け足され
		る。そのためマッピングを展開している途中であれば、これらの文字
		はマッピングを展開した後に来ることになる。他の文字の前に挿入す
		るには、'i' フラグを使用する。それらはマッピングからの任意の文
		字の前の挿入の次に実行される。

		この関数は、{string}中の文字が処理されるまでは待たない。

		特殊なキーを{string}に含めるにはダブルクォートと "\..." 記法を
		使う(|expr-quote|を参照)。例えば、feedkeys("\<CR>")は<Enter>
		キーの押下をシミュレートする。しかしfeedkeys('\<CR>')とすると、
		この文字の通り5文字を挿入する。
		役に立つかもしれない特別なコードは <Ignore> だ。それは何もせず
		に文字の待機を終了する。  *<Ignore>*

		{mode}は以下の文字フラグを含む文字列:
		'm'	キーをマップ展開する。これが既定である。{mode}が省略さ
			れたときは、挿入されたキーはマップ展開の対象になる。
		'n'	キーをマップ展開しない。
		't'	キーをタイプされたかのように扱う。そうでない場合は
			マッピングから展開されたかのように扱われる。これは
			undoや折り畳みの展開などで違いが現れる。
		'L'	低レベル入力。UnixまたはGUIを使用している場合にのみ機
			能する。キーは端末から来ているかのように使われる。他の
			フラグは使用されない。  *E980*
			CTRL-C で割り込み時、かつ 't' が含まれていると内部
			"got_int" フラグが設定される。
		'i'	追加する代わりに文字を挿入する。(上記参照)
		'x'	先行入力が空になるまでコマンドを実行する。
			これは ":normal!" を使うのと似ている。
			'x' なしで数回feedkeys()を呼んだ後、'x' ありで1回
			({string}が空でも可能) feedkeys()を呼ぶことで先行入力
			をすべて実行できる。Note Vimが挿入モードを終了したとき
			は、スクリプト続行前の文字入力待ちによる立ち往生を避け
			るために、<Esc>が入力されたかのように振る舞う。
			Note コマンドの実行中に feedkeys() を再帰的に呼び出し
			た場合、最後の呼び出しですべての先行入力が消費される。
		'c'	実行時のスクリプトのコンテキストを削除し、旧来のスクリ
			プトの構文が適用され、"s:var" が動作しないようにする。
			Note 供給される文字列がスクリプトコンテキストを設定す
			る場合でも、これは適用されることに注意。
		'!'	'x' と一緒に使用すると挿入モードを終了しない。タイマー
			が少し後で挿入モードを終了するように設定されているとき
			にテストで使用できる。CursorHoldIのテストに便利である。

		戻り値は常に0。

		|method| としても使用できる: >
			GetInput()->feedkeys()
<
							*filereadable()*
filereadable({file})
		結果は数値で、{file}というファイルが存在し、読み込むことが可能
		ならば|TRUE|となる。ファイル{file}が存在しないかディレクトリ
		だった場合には、結果は|FALSE|となる。引数{file}は文字列として
		使えればどのような表現でもよい。
		ファイルが読み込み可能でなくてもよい場合には|glob()|を使う。
		{file} はそのまま使用されるため、最初にワイルドカードを展開す
		ることを推奨する: >
			echo filereadable('~/.vimrc')
			0
			echo filereadable(expand('~/.vimrc'))
			1

<		|method| としても使用できる: >
			GetName()->filereadable()
<							*file_readable()*
		以前の名前: file_readable().

filewritable({file})					*filewritable()*
		結果は数値で、{file}というファイルが存在し、書き込むことが可能
		ならば1となる。ファイル{file}が存在しないか書き込み不可能であ
		る場合には、結果は0となる。{file}がディレクトリであり、書き込
		み可能な場合、結果は2となる。

		|method| としても使用できる: >
			GetName()->filewritable()


filter({expr1}, {expr2})					*filter()*
		{expr1}はリスト |List|、文字列 |String|、|Blob|、辞書
		|Dictionary| でなければならない。
		{expr1}の各要素に対して{expr2}を評価し、その結果が0もしくは偽
		ならばリストまたは辞書からその要素を削除する。|Blob| の各バイ
		トや文字列 |String| の各文字も同様に行う。

		{expr2}は文字列|string|または関数参照|Funcref|でなければならな
		い。

		{expr2}が文字列の場合、{expr2}の内部では|v:val|が現在の要素の
		値を保持している。辞書の場合は|v:key|が現在の要素のキーを保持
		しており、リストの場合は|v:key|が現在の要素のインデックスを保
		持している。|Blob| の場合は |v:key| が現在のバイトのインデック
		スになる。文字列 |String| の場合は |v:key| が現在の文字のイン
		デックスになる。
		例: >
			call filter(mylist, 'v:val !~ "OLD"')
<		は要素 "OLD" を削除する。 >
			call filter(mydict, 'v:key >= 8')
<		は8未満のキーを持つ要素を削除する。 >
			call filter(var, 0)
<		は全要素を削除する。つまりリストまたは辞書をクリアする。

		Note {expr2}は式を表す文字列である。バックスラッシュを二重に
		しなくても済むように|literal-string|を使うとよいだろう。ただし
		その場合はシングルクォートを二重にしなければならない。

		{expr2}が|Funcref|の場合は、2つの引数で呼び出される:
			1. 現在の要素のキーまたはインデックス。
			2. 現在の要素の値。
		関数は、その要素を保持すべきときは|TRUE|を返さなければならな
		い。リストの奇数版目の要素を保持する例: >
			func Odd(idx, val)
			  return a:idx % 2 == 1
			endfunc
			call filter(mylist, function('Odd'))
<		|lambda| を使えばより短く書ける。|Vim9| の構文では: >
			call filter(myList, (idx, val) => idx * val <= 42)
<		旧来のスクリプトの構文では: >
			call filter(myList, {idx, val -> idx * val <= 42})
<		"val" を使わない場合は省略できる: >
			call filter(myList, {idx -> idx % 2 == 1})
<
		|Vim9| script では結果が true、false、0もしくは1になる。
		それ以外の値では結果が型エラーになる。

		この操作はその場で(in-place)行われる。リストや辞書を変更したく
		ない場合は最初にコピーを作ること: >
			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		{expr1}のリスト |List|、|Blob|、 または辞書 |Dictionary| をフ
		ィルターした結果を返す。{expr2}を評価している最中にエラーが発
		生した場合は、{expr1}内のそれ以降の要素の処理は行われない。
		{expr2}が関数参照の場合、関数が "abort" フラグつきで定義されて
		いない限り、関数内のエラーは無視される。

		リストや辞書でのこの操作はその場で(in-place)行われる。変更した
		くない場合は最初にコピーを作ること: >
			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		{expr1}のリスト |List| または辞書 |Dictionary| をフィルターし
		た結果、もしくは新規の |Blob| か文字列 |String| を返す。{expr2}
		を評価している最中にエラーが発生した場合は、{expr1}内のそれ以
		降の要素の処理は行われない。{expr2}が関数参照の場合、関数が
		"abort" フラグつきで定義されていない限り、関数内のエラーは無視
		される。

		|method| としても使用できる: >
			mylist->filter(expr2)

finddir({name} [, {path} [, {count}]])				*finddir()*
		{path}から{name}という名前のディレクトリを探す。ディレクトリを
		上方・下方のどちらにも再帰的に検索できる。{path}の記法について
		は|file-searching|を参照。

		最初に見つかったディレクトリのパスを返す。そのディレクトリがカ
		レントディレクトリの下にある場合は相対パスを返す。そうでなけれ
		ば絶対パスを返す。
		{path}が省略されたとき、または空のときはオプション 'path' の値
		が使われる。

		省略可能な引数{count}が指定されたときは、最初に見つかったディ
		レクトリでなく、{count}番目に見つかったディレクトリを返す。
		{count}が負の場合は、見つかったディレクトリ全てのリスト|List|
		を返す。

		ディレクトリが見つからない場合は空の文字列を返す。

		これはexコマンド`:find`によく似ている。

		|method| としても使用できる: >
			GetName()->finddir()

findfile({name} [, {path} [, {count}]])				*findfile()*
		|finddir()|と同様だが、ディレクトリでなくファイルを検索する。
		'suffixesadd' が適用される。
		例: >
			:echo findfile("tags.vim", ".;")
<		この例は、カレントファイルがあるディレクトリから上方に
		"tags.vim" を見つけるまで再帰的に検索する。

		|method| としても使用できる: >
			GetName()->findfile()

flatten({list} [, {maxdepth}])					*flatten()*
		リスト {list} を {maxdepth} の深さまで平坦化する。{maxdepth}
		が無い場合の結果は {maxdepth} が非常に巨大な数であるのように、
		リスト |List| からネストを除去する。
		{list} は変更が入るので、それを望まないなら |flattennew()| を
		使うこと。
		Vim9 script では flatten() は使用できないため、常に
		|flattennew()| を使う必要がある。
								*E900*
		{maxdepth} はリストのネストをどれだけ深く変更するかを意味する。
		{maxdepth} が0なら {list} は変更されない。
		{maxdepth} は正の数でなければならない。

		エラーがあったときは数値の0を返す。

		例: >
			:echo flatten([1, [2, [3, 4]], 5])
<			[1, 2, 3, 4, 5] >
			:echo flatten([1, [2, [3, 4]], 5], 1)
<			[1, 2, [3, 4], 5]

		|method| としても使用できる: >
			mylist->flatten()
<
flattennew({list} [, {maxdepth}])			*flattennew()*
		|flatten()| と同様だが最初に {list} のコピーを作る。


float2nr({expr})					*float2nr()*
		{expr} の小数点以下を切り捨てて |Number| に変換する。
		{expr} は |Float| または |Number| に評価されなければならない。
		{expr} が |Float| または |Number| でない場合は 0 を返す。
		{expr} の値が |Number| の範囲外の場合、結果は 0x7fffffff また
		は -0x7fffffff になる(64ビット数値が有効化されている場合は
		0x7fffffffffffffff または -0x7fffffffffffffff)。
		NaN は -0x80000000 になる(64ビット数値が有効化されている場合は
		-0x8000000000000000)。
		例: >
			echo float2nr(3.95)
<			3  >
			echo float2nr(-23.45)
<			-23  >
			echo float2nr(1.0e100)
<			2147483647  (または 9223372036854775807) >
			echo float2nr(-1.0e150)
<			-2147483647  (または -9223372036854775807) >
			echo float2nr(1.0e-100)
<			0

		|method| としても使用できる: >
			Compute()->float2nr()


floor({expr})							*floor()*
		{expr} 以下の最大の整数を |Float| で返す(切り捨て)。
		{expr} は |Float| または |Number| に評価されなければならない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			echo floor(1.856)
<			1.0  >
			echo floor(-5.456)
<			-6.0  >
			echo floor(4.0)
<			4.0

		|method| としても使用できる: >
			Compute()->floor()


fmod({expr1}, {expr2})					*fmod()*
		{expr1} / {expr2} の余りを返す (割り算が表現できなくても)。
		{expr2} が非ゼロなら {expr1} - i * {expr2} の結果を返す (i は
		戻り値が {expr1} と同じ符号を持ちその絶対値が {expr2} よりも小
		さくなるような値)。{expr2} がゼロならゼロが返る。戻り値の型は
		浮動小数点数 (|Float|)。
		{expr1} と {expr2} は浮動小数点数 (|Float|) か数値 (|Number|)
		でなければならない。
		{expr1} または {expr2} が |Float| または |Number| でない場合は
		0.0 を返す。
		例: >
			:echo fmod(12.33, 1.22)
<			0.13 >
			:echo fmod(-12.33, 1.22)
<			-0.13

		|method| としても使用できる: >
			Compute()->fmod(1.22)


fnameescape({string})					*fnameescape()*
		コマンド引数のファイル名として使うために {string} をエスケープ
		する。'%' や '|' など特別な意味を持つ全ての文字がバックスラッ
		シュでエスケープされる。
		特別な文字とは、ほとんどのシステムにおいて
		" \t\n*?[{`$\\%#'\"|!<" である。ファイル名にバックスラッシュが
		現れるシステムにおいては 'isfname' の値に依存する。
		先頭の '+' と '>' もエスケープされる(|:edit| と |:write| の引
		数では特別な意味を持つ)。{string} が "-" である場合もエスケー
		プされる(|:cd| の引数では意味を持つ)。
		エラー時は空文字列を返す。
		例: >
			:let fname = '+some str%nge|name'
			:exe "edit " .. fnameescape(fname)
<		上記は次と同じ結果になる: >
			edit \+some\ str\%nge\|name
<
		|method| としても使用できる: >
			GetName()->fnameescape()

fnamemodify({fname}, {mods})				*fnamemodify()*
		ファイル名{fname}を{mods}にしたがって変更する。{mods}はコマン
		ドラインで使われるのと同様な文字列である。詳細は
		|filename-modifiers|を参照。
		例: >
			:echo fnamemodify("main.c", ":p:h")
<		結果: >
			/home/user/vim/vim/src/
<		{mods} が空、またはサポートされていない修飾子が使われた場合は
		{fname} が返される。
		{fname} が空の場合で {mods} が ":h" だと "." を返すので、`:cd`
		を一緒に使うことができる。これは、空の文字列を返すバッファ名な
		しの Expand('%:h') とは異なる。
		Note: {fname}の中の環境変数は展開されない。環境変数を展開させ
		るには|expand()|を使うこと。

		|method| としても使用できる: >
			GetName()->fnamemodify(':p:h')

foldclosed({lnum})					*foldclosed()*
		結果は数値。{lnum}行目が閉じた折り畳みの中にあるなら、その折り
		畳みを構成する最初の行の行番号を返す。{lnum}行目が閉じた折り畳
		みに入っていないなら-1を返す。
		{lnum} は |getline()| と同様に扱われる。例えば "." は現在の行、
		"'m" は m でマークした行、など。

		|method| としても使用できる: >
			GetLnum()->foldclosed()

foldclosedend({lnum})					*foldclosedend()*
		結果は数値。{lnum}行目が閉じた折り畳みの中にあるなら、その折り
		畳みを構成する最後の行の行番号を返す。{lnum}行目が閉じた折り畳
		みに入っていないなら-1を返す。
		{lnum} は |getline()| と同様に扱われる。例えば "." は現在の行、
		"'m" は m でマークした行、など。

		|method| としても使用できる: >
			GetLnum()->foldclosedend()

foldlevel({lnum})					*foldlevel()*
		カレントバッファの{lnum}行目の折り畳みレベルを表す数値を返す。
		折り畳みがネストしているときは一番下のレベルを返す。{lnum}行目
		に折り畳みがまったくないときは0を返す。折り畳みが開いているか
		閉じているかは関係ない。('foldexpr' の中で)折り畳みを更新して
		いる最中に呼ぶと、まだ折り畳みを更新していなく、折り畳みレベル
		が未知の行に対しては-1を返す。特別な場合として、普通は1行前の
		レベルは取得できる。
		{lnum} は |getline()| と同様に扱われる。例えば "." は現在の行、
		"'m" は m でマークした行、など。

		|method| としても使用できる: >
			GetLnum()->foldlevel()
<
							*foldtext()*
foldtext()	閉じた折り畳みに表示する文字列を返す。これはオプション
		'foldtext' のデフォルトの関数であり、'foldtext' を評価している
		ときにだけ呼ぶようにすべきである。この関数は変数|v:foldstart|,
		|v:foldend|, |v:folddashes|を使用する。
		戻り値の文字列は次のようになる: >
			+-- 45 lines: abcdef
<		先導するダッシュ(-)の数は折り畳みレベルによって決まる。"45" は
		その折り畳みに含まれている行数である。"abcdef" はその折り畳み
		の中の最初の空行でない行のテキストである。行頭の空白と、"//"
		や "/*"、'foldmarker' と'commentstring' に設定されている文字列
		は削除される。
		実際に折り畳みテキストを表示するときには、行の残りは
		'fillchars' で設定した折り畳み用の文字で埋められる。
		折り畳みが無い場合は空文字列を返す。
		{|+folding|機能付きでコンパイルされたときのみ利用可能}

foldtextresult({lnum})					*foldtextresult()*
		{lnum}行目の閉じた折り畳みに表示される文字列を返す。'foldtext'
		を適切なコンテキストの中で評価する。{lnum}行目に閉じた折り畳み
		がないときは空文字列を返す。
		{lnum}は|getline()|のときと同様に扱われる。つまり "." はカレン
		ト行、"'m" はマークmを表す。
		折り畳まれたテキストをHTMLなどにエクスポートするときに有用。
		{|+folding|機能付きでコンパイルされたときのみ利用可能}


		|method| としても使用できる: >
			GetLnum()->foldtextresult()

foreach({expr1}, {expr2})					*foreach()*
		{expr1} は |List|, |String|, |Blob| または |Dictionary| でなけ
		ればならない。
		{expr1} の各項目に対して {expr2} を実行する。{expr1} は変更さ
		れない。その値は |:lockvar| 1 と同様に変更されるかもしれない。
		|E741|
		{expr1} を変更するには |map()| および |filter()| を参照。

		{expr2} は |string| か |Funcref| でなければならない。

		{expr2} が |string| の場合、{expr2} 内では |v:val| は現在の項
		目の値を持つ。|Dictionary| の場合、|v:key| は現在の項目のキー
		を持ち、|List| の場合、|v:key| は現在の項目のインデックスを持
		つ。
		|Blob| の場合、|v:key| は現在のバイトインデックスを持つ。
		|String| の場合、|v:key| は現在の文字インデックスを持つ。

		例: >
			call foreach(mylist, 'used[v:val] = true')
<		これは {expr1} リスト内の項目を記録する。

		Note {expr2} は式の結果であり、コマンドとして使用されることに
		注意。多くの場合、|literal-string| を使用するのが良い。バック
		スラッシュを 2 重にする必要がないようにするためである。

		{expr2} が |Funcref| の場合 2 つの引数を取る必要がある:
			1. 現在の項目のキーまたはインデックス。
			2. 現在の項目の値。
		旧来のスクリプトの lambda では引数を 1 つだけ受け入れてもエラー
		は発生しないが、Vim9 の lambda では "E1106: One argument too
		many" になり、引数の数は一致する必要がある。
		関数が値を返した場合、その値は無視される。

		すべてのケースで {expr1} を返す。
		{expr2} の実行中にエラーが発生した場合、{expr1} 内の項目はそれ
		以上処理されない。
		{expr2} が Funcref の場合、"abort" フラグを使用して定義されて
		いない限り、関数内のエラーは無視される。

		|method| としても使用できる: >
			mylist->foreach(expr2)
<
							*foreground()*
foreground()	Vimのウィンドウを前面に移動する。この関数はクライアントからVim
		サーバーへ送ると便利である。|remote_send()|
		Win32では自分自身のウィンドウを前面に持ってくることが必ずしも
		許可されていないので、動作しないかもしれない。そのときは代わり
		に|remote_foreground()|を使うこと。
		{Win32, Motif, GTKいずれかのGUI版とWin32コンソール版でのみ利用
		できる}

fullcommand({name} [, {vim9}])				*fullcommand()*
		短縮コマンド名から完全なコマンド名を取得する。コマンドの短縮名
		については |20.2| を参照。

		文字列引数 {name} は `:` から始まっても [range] を含んでよい
		が、それらはスキップされ戻り値には含まない。
		コマンドが存在しない場合、曖昧な場合 (ユーザー定義コマンドの場
		合)、またはこの方法で短縮できない場合は空文字列を返す。
		|vim9-no-shorten|

		引数 {vim9} がない場合は、現在のスクリプトのバージョンを使用す
		る。
		{vim9} が存在し、FALSE の場合、旧来のスクリプトルールが使用さ
		れる。{vim9} が存在し、TRUE の場合、Vim9 のルールが使用される。
		例えば、"en" は "endif" の短縮形ではない。

		例えば `fullcommand('s')`、 `fullcommand('sub')`、
		`fullcommand(':%substitute')` はすべて "substitute" を返す。

		|method| としても使用できる: >
			GetName()->fullcommand()
<
						*funcref()*
funcref({name} [, {arglist}] [, {dict}])
		|function()|と同様である。ただし、返されたFuncrefは、関数を名
		前ではなく参照で検索する。これは関数{name}が後で再定義されると
		きに重要である。

		|function()|とは違い、{name}はユーザー定義関数として存在してい
		なければならない。autoload関数ではすでにロード済みのときだけ機
		能する(関数名のみを利用する場合にautoload関数を誤ってロードし
		ないようにするには、代わりに |function()| を使用する)。{name}
		は組込み関数であってはならない。
		エラー時は 0 を返す。

		|method| としても使用できる: >
			GetFuncname()->funcref([arg])
<
				*function()* *partial* *E700* *E923*
function({name} [, {arglist}] [, {dict}])
		関数{name}を参照する|Funcref|の変数を返す。{name}はユーザー定義
		関数でも組み込み関数でもよい。

		ここで{name}は関数の参照、もしくは部分適用である。部分適用であ
		るとき、それに格納されている辞書が使用され、{dict}引数が使用で
		きない。例: >
			let FuncWithArg = function(dict.Func, [arg])
			let Broken = function(dict.Func, [arg], dict)
<
		Funcrefが利用されるとき、その関数は{name}から見つけられる。こ
		れは後で再定義された場合も同様である。常に同じ関数を見つけるた
		めには|funcref()|を使うこと。

		{arglist}もしくは{dict}が与えられると、関数の部分適用が作られ
		る。すなわち引数のリスト及び/または辞書はFuncrefに格納され、
		そのFuncrefが呼ばれるときに使用される。

		格納された引数は他の引数よりも前に関数に渡される。しかし、メ
		ソッドからの任意の引数の後になる。例えば: >
			func Callback(arg1, arg2, name)
			...
			let Partial = function('Callback', ['one', 'two'])
			...
			call Partial('name')
<		関数は次のように呼び出す: >
			call Callback('one', 'two', 'name')

<		|method| の場合: >
			func Callback(one, two, three)
			...
			let Partial = function('Callback', ['two'])
			...
			eval 'one'->Partial('three')
<		次のように関数を呼び出す: >
			call Callback('one', 'two', 'three')

<		function()はFuncrefにより多くの引数を加えるためにネストして呼
		び出すことができる。余分な引数は、引数のリストに追加される。
		例えば: >
			func Callback(arg1, arg2, name)
			"...
			let Func = function('Callback', ['one'])
			let Func2 = function(Func, ['two'])
			"...
			call Func2('name')
<		これは次のように関数を呼び出す: >
			call Callback('one', 'two', 'name')

<		辞書は "dict" 関数を呼び出すときのみ有用である。この場合、
		{dict}は "self" として渡される。例えば: >
			function Callback() dict
			   echo "called for " .. self.name
			endfunction
			"...
			let context = {"name": "example"}
			let Func = function('Callback', context)
			"...
			call Func()	" will echo: called for example
<		追加の引数がない場合は function() を使用する必要はない。
		Callback() が context.Callback() として定義されている場合、以
		下の 2 つは同等である: >
			let Func = function('Callback', context)
			let Func = context.Callback

<		引数のリストと辞書を同時に使用することもできる: >
			function Callback(arg1, count) dict
			"...
			let context = {"name": "example"}
			let Func = function('Callback', ['one'], context)
			"...
			call Func(500)
<		これは次のように関数を呼び出す: >
			call context.Callback('one', 500)
<
		エラー時は 0 を返す。

		|method| としても使用できる: >
			GetFuncname()->function([arg])

garbagecollect([{atexit}])				*garbagecollect()*
		循環参照を持ち、使われていないリスト|List|、辞書
		|Dictionaries|、チャネル|Channels|、ジョブ|Jobs| をクリーン
		アップする。

		これはメモリ不足に陥ったときや、'updatetime' 経過後ユーザーの
		キー入力を待っているときに自動的に行われるので、この関数を呼ぶ
		必要があることはほとんどない。循環参照を持たない要素は、使われ
		なくなったとき必ず解放される。長時間実行されるスクリプトの中で
		循環参照を持つ非常に大きなリストや辞書を削除したときに有用であ
		る。

		省略可能な引数 {atexit} に 1 を指定すると、Vim を終了するとき
		にもガーベッジコレクションが行われる。これはメモリリークを発見
		するのに役に立つ。

		ガーベッジコレクションはすぐには実行されず、安全な場合のみ実行
		される。これはユーザーが文字を入力するのを待っているときであ
		る。ガーベッジコレクションを強制するには、すぐに
		|test_garbagecollect_now()|を使用すること。

get({list}, {idx} [, {default}])			*get()*
		リスト|List| {list}から{idx}番目の要素を取得する。この要素を取
		得できないときは{default}を返す。{default}が省略されたときは0
		を返す。
		|method| として使用したいなら: >
			mylist->get(idx)
get({blob}, {idx} [, {default}])
		|Blob| {blob}から{idx}番目のバイトを取得する。このバイトを取得
		できないときは{default}を返す。{default}が省略されたときは -1
		を返す。
		|method| として使用したいなら: >
			myblob->get(idx)
get({dict}, {key} [, {default}])
		辞書|Dictionary| {dict}からキー{key}に関連づけられた値を取得す
		る。この要素を取得できないときは{default}を返す。{default}が省
		略されたときは0を返す。便利な例: >
			let val = get(g:, 'var_name', 'default')
<		g:var_nameの値が存在する場合はこれを取得し使用するが、存在しな
		い場合は 'default' を返す。
		|method| として使用したいなら: >
			mydict->get(key)
get({func}, {what})
		Funcref {func} から項目 {what} を取得する。{what}の可能な値は:
			"name"	関数名
			"func"	関数
			"dict"	辞書
			"args"	引数リスト
		エラー時はゼロを返す。
		|method| として使用したいなら: >
			myfunc->get(what)
<
							*getbufinfo()*
getbufinfo([{buf}])
getbufinfo([{dict}])
		バッファの情報を辞書のリストとして取得する。

		引数なしの場合、すべてのバッファに関する情報が返される。

		引数が辞書 |Dictionary| の場合、指定された条件を満たすバッファ
		のみが返される。{dict}には以下のキーを指定できる:
			buflisted	リストされたバッファのみを含む。
			bufloaded	ロードされたバッファのみを含む。
			bufmodified	修正されたバッファのみを含む。

		それ以外の場合、{buf}は情報を返す特定のバッファを指定する。
		{buf}の使用については、上記の|bufname()|を参照。バッファが見つ
		かった場合、返されるListには1つの項目がある。それ以外の場合、
		結果は空のリストになる。

		返される各List項目は、次のエントリを持つ辞書である:
			bufnr		バッファ番号。
			changed		バッファが変更されている場合はTRUE。
			changedtick	バッファに加えられた変更の数。
			command		バッファがコマンドラインウィンドウ
					|cmdwin| に属する場合は TRUE。
			hidden		バッファが隠されている場合はTRUE。
			lastused	バッファが最後に使用されたときの
					|localtime()| のような秒単位のタイムス
					タンプ。
					{|+viminfo| 機能付きでコンパイルされた
					ときのみ有効}
			listed		バッファがリストされている場合はTRUE。
			lnum		バッファがカレントウィンドウに表示され
					ていたときの現在行の行番号。
					過去にバッファがカレントウィンドウに表
					示されていた場合にのみ有効である。特定
					のウィンドウの最後のカーソル位置の行番
					号が必要な場合は |line()| を使うこと: >
						:echo line('.', {winid}))
<
			linecount	バッファ内の行数 (ロードされているとき
					のみ有効)
			loaded		バッファがロードされている場合はTRUE。
			name		バッファ内のファイルへのフルパス。
			signs		バッファに設置された目印のリスト。
					各リスト項目は、次のフィールドを含む辞
					書である:
					    id	  目印ID
					    lnum  行番号
					    name  目印名
			variables	バッファローカル変数の辞書への参照。
			windows		バッファを表示する|window-ID|のリスト
			popups		バッファを表示するpopup|window-id|のリ
					スト

		例: >
			for buf in getbufinfo()
			    echo buf.name
			endfor
			for buf in getbufinfo({'buflisted':1})
			    if buf.changed
				....
			    endif
			endfor
<
		バッファローカルオプションを取得するには: >
			getbufvar({bufnr}, '&option_name')
<
		|method| としても使用できる: >
			GetBufnr()->getbufinfo()
<

							*getbufline()*
getbufline({buf}, {lnum} [, {end}])
		バッファ{buf}の{lnum}行目から{end}行目まで(両端含む)の行からな
		るリスト|List|を返す。{end}が省略されたときは{lnum}行目だけか
		らなるリストを返す。1 行のみの取得については `getbufoneline()`
		を参照。

		{buf}の指定の仕方については|bufname()|を参照。

		{lnum}と{end}では "$" でバッファの最後の行を表すことができる。
		それ以外は数値でなければならない。

		{lnum}が1より小さいときや、バッファの行数より大きいときは空リ
		ストを返す。

		{end}がバッファの行数より大きいときは、バッファの行数が設定さ
		れたものとして扱う。{end}が{lnum}行目より前に設定された場合は
		空リストを返す。

		この関数は読み込まれているバッファに対してのみ動作する。既にア
		ンロードされているバッファや存在しないバッファに対しては空リス
		トを返す。

		例: >
			:let lines = getbufline(bufnr("myfile"), 1, "$")

<		|method| としても使用できる: >
			GetBufnr()->getbufline(lnum)
<
							*getbufoneline()*
getbufoneline({buf}, {lnum})
		`getbufline()` と似ているが、1 行だけを取得して文字列として返
		す。

getbufvar({buf}, {varname} [, {def}])				*getbufvar()*
		バッファ{buf}のオプションの値やバッファローカル変数{varname}
		の値を返す。Note "b:" をつけない変数名を指定すること。
		{varname} が空文字列の場合、全てのバッファローカル変数からなる
		辞書 |Dictionary| を返す。
		{varname} が "&" に等しいとき、すべてのバッファローカルオプショ
		ンを持つ辞書 |Dictionary| を返す。
		そうでなく、{varname} が "&" で始まるとき、バッファローカルオ
		プションの値を返す。
		グローバルオプション、バッファローカルオプションのどちらに対し
		ても動作するが、グローバル変数、ウィンドウローカル変数、ウィン
		ドウローカルオプションに対しては動作しない。
		{buf}の指定の仕方については|bufname()|を参照。
		バッファや変数が存在しないときは{def}または空文字列を返し、エ
		ラーメッセージは表示されない。
		例: >
			:let bufmodified = getbufvar(1, "&mod")
			:echo "todo myvar = " .. getbufvar("todo", "myvar")

<		|method| としても使用できる: >
			GetBufnr()->getbufvar(varname)
<
getcellwidths()						*getcellwidths()*
		|setcellwidths()| によって上書きされた文字範囲のセル幅の
		|List| を返す。形式は |setcellwidths()| の引数と同じである。セ
		ル幅が上書きされた文字範囲がない場合、空のリストが返される。


getchangelist([{buf}])					*getchangelist()*
		バッファ {buf} の |changelist| を返す。{buf} の使い方は前述の
		|bufname()| を参照。バッファ {buf} が存在しない場合、空のリス
		トが返される。

		返されるリストは 2 つのエントリを含む: 変更位置のリストと、リ
		スト内の現在地。変更リスト内のそれぞれの項目は、以下の項目を含
		む辞書になっている:
			col		列番号
			coladd		'virtualedit' 用の列のオフセット
			lnum		行番号
		バッファ {buf} がカレントバッファの場合、現在地はリスト内の位
		置を指す。それ以外のバッファではリストの長さに設定される。

		|method| としても使用できる: >
			GetBufnr()->getchangelist()

getchar([expr])						*getchar()*
		ユーザーまたは入力ストリームから1文字を取得する。
		[expr] が省略された場合、1文字を取得できるまで待つ。
		[expr] が0の場合、1文字を取得できる時だけ取得する。取得できな
			い時は0を返す。
		[expr] が1の場合は、1文字を取得できるかを判定するだけである。
			入力は消費されない。取得できないと判定された時は0を返
			す。
 		常に文字列として取得したい場合は |getcharstr()| を使用する。

		[expr] が省略されたときや [expr] が0のときは、文字全体または特
		殊キーを返す。それが1文字なら戻り値は数値である。これを文字列
		に戻すには |nr2char()| を使う。それ以外の場合にはエンコードし
		て文字列にして返す。
		特殊キーとは0x80(10進数で128)で始まるバイト列からなる文字列で
		ある。これは文字列 "\<Key>" と同じ値である(例: "\<Left>")。戻
		り値は文字列であり、修飾キー(shift, control, alt)は含まれない。

		[expr] が0や Esc が入力された場合は、これがエスケープシーケン
		スの始まりであるかどうかをVimが知るために待つ間、短い遅延があ
		るだろう。

		[expr] が1のときは最初のバイトだけを返す。1バイト文字の場合、
		これはその文字そのものを表す数値である。これを文字列に変換する
		にはnr2char()を使う。

		修飾キーを取得するには getcharmod() を使う。

		ユーザーがマウスをクリックしたときはマウスイベントを返す。クリッ
		クした位置は|v:mouse_col|, |v:mouse_lnum|, |v:mouse_winid|,
		|v:mouse_win|で得られる。|getmousepos()| も使える。マウスの移
		動イベントは無視される。
		以下の例は、普通にマウスがクリックされたときと同じようにカーソ
		ルを移動させる。 >
			let c = getchar()
			if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win .. "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " .. v:mouse_col .. "|"
			endif
<
		bracketed pasteを使用しているときは最初の文字のみが返され、ペー
		ストされた残りのテキストは切り捨てられる。
		|xterm-bracketed-paste|.

		この関数を呼んだときプロンプトは表示されない。文字入力を待って
		いることをなんらかの方法でユーザーがわかるようにしなければなら
		ないだろう。画面は再描画されない、例えばウィンドウのリサイズ。
		ポップアップウィンドウを使っているなら |popup-filter| を使うと
		よりよく動作する。
		入力された文字に対してマッピングは適用されない。
		キーコードは置換される。つまりユーザーが<Del>を押した場合、
		「生の」文字シーケンスでなく<Del>キーに対応するコードが得られ
		る。
		例: >
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		以下の例は大文字・小文字を区別しないように "f" を再定義する: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction
<
		あなたは|<CursorHold>|のような合成文字も取得するかもしれない。
		多くの場合、あなたはこれを無視して別の文字を取得することにな
		る: >
			:function GetKey()
			:  let c = getchar()
			:  while c == "\<CursorHold>"
			:    let c = getchar()
			:  endwhile
			:  return c
			:endfunction

getcharmod()						*getcharmod()*
		最後にgetchar()などで得た文字に対する修飾キーの状態を表す数値
		を返す。以下の値の和となる:
			2	shift
			4	control
			8	alt (meta)
			16	meta (ALT と META が区別される場合)
			32	マウスのダブルクリック
			64	マウスのトリプルクリック
			96	マウスのクアドラプルクリック (== 32 + 64)
			128	command (Mac) または super (GTK)
		文字自身に含まれていない修飾キーのみ取得できる。つまり、
		Shift-aは修飾キーなしの "A" となる。修飾なしの場合は 0 を返す。

							*getcharpos()*
getcharpos({expr})
		文字列 {expr} の位置を得る。|getpos()| と同様だが返すリスト内
		の桁番号はバイトインデックスの代わりに文字インデックスになって
		いる。
		|getpos()| が |v:maxcol| と等しい非常に大きな桁番号を返す場合、
		getcharpos() は最後の文字の文字インデックスを返す。

		例:
		5行目のテキスト "여보세요" の '세' にカーソルがある状態: >
			getcharpos('.')		returns [0, 5, 3, 0]
			getpos('.')		returns [0, 5, 7, 0]
<
		|method| としても使用できる: >
			GetMark()->getcharpos()

getcharsearch()						*getcharsearch()*
		現在の文字検索の情報である{dict}を返し、この辞書は下記のエント
		リを持つ:

		    char	文字検索(|t|, |f|, |T|, |F|)で以前に使われた文
				字。
				もし文字検索が実行されていないなら空文字列。
		    forward	文字検索の方向。1は前方、0は後方。
		    until	文字検索の種類。1は|t|もしくは|T|の文字検索、0は
				|f|もしくは|F|の文字検索。

		下記の設定は前回の文字検索の方向にかかわらず、|;| で前方検索、
		|,| で後方検索を常に行えるようになり便利である: >
			:nnoremap <expr> ; getcharsearch().forward ? ';' : ','
			:nnoremap <expr> , getcharsearch().forward ? ',' : ';'
<		|setcharsearch()|も参照。

getcharstr([expr])					*getcharstr()*
		ユーザーまたは入力ストリームから1文字を文字列として取得する。
		[expr] が省略された場合、1文字を取得できるまで待つ。
		[expr] が0もしくは偽の場合、1文字を取得できる時だけ取得する。
			取得できない時は空文字列を返す。
		[expr] が1もしくは真の場合は、1文字を取得できるかを判定するだ
			けである。入力は消費されない。取得できないと判定された
			時は空文字列を返す。
		結果の数値が文字列に変換される以外は |getchar()| と同様に動作
		する。

getcmdcompltype()					*getcmdcompltype()*
		現在のコマンドライン補完のタイプを返す。
		コマンドラインが編集時にのみ動作するので、|c_CTRL-e| または
		|c_CTRL-R_=| を使用する必要がある。
                返す文字列については |:command-completion| を参照のこと。
		|getcmdtype()|、|setcmdpos()|、|getcmdline()|、|setcmdline()|
		も参照。
                補完が定義されていない場合は空文字列を返す。

getcmdline()						*getcmdline()*
		現在のコマンドラインの内容を取得する。コマンドラインを編集して
		いるときのみ動作する。つまり|c_CTRL-\_e|または|c_CTRL-R_=|を使っ
		ているときのみ有効。
		例: >
			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		|getcmdtype()|, |getcmdpos()|, |setcmdpos()| および
		|setcmdline()| も参照。
		パスワードを入力する時や |inputsecret()| を使う時は空文字列を
		返す。

getcmdpos()						*getcmdpos()*
		コマンドラインにおけるカーソル位置をバイト単位で取得する。最初
		の桁は1となる。コマンドラインを編集しているときのみ動作する。
		つまり|c_CTRL-\_e|または|c_CTRL-R_=|または式マッピングを使って
		いるときのみ有効。そうでないときは 0 を返す。
		|getcmdtype()|, |setcmdpos()|, |getcmdline()|, |setcmdline()|
		も参照。

getcmdscreenpos()					*getcmdscreenpos()*
		コマンドラインのカーソルのスクリーン位置をバイト単位で返す。最
		初の桁は 1 である。
                |getcmdpos()| の代わりにプロンプトの位置を加える。
		コマンドラインの編集時のみ動作するため、|c_CTRL-e| または
		|c_CTRL-R_=| または式マッピングを使用する必要がある。それ以外
		は 0 を返す。
		|getcmdpos()|, |setcmdpos()|, |getcmdline()|, |setcmdline()|
		も参照。

getcmdtype()						*getcmdtype()*
		現在のコマンドラインの種類を返す。戻り値は次のいずれか:
		    :	通常のexコマンド
		    >	デバッグモードコマンド |debug-mode|
		    /	前方検索コマンド
		    ?	後方検索コマンド
		    @	|input()| コマンド
		    -	|:insert| または |:append| コマンド
		    =	|i_CTRL-R_=|
		コマンドラインを編集しているときのみ動作する。つまり
		|c_CTRL-\_e|または|c_CTRL-R_=|または式マッピングを使っていると
		きのみ有効。そうでないときは空文字列を返す。
		|getcmdpos()|, |setcmdpos()|, |getcmdline()|も参照。

getcmdwintype()						*getcmdwintype()*
		現在のコマンドラインウィンドウ (|command-line-window|) の種類
		を返す。戻り値の意味は |getcmdtype()| と同じ。コマンドライン
		ウィンドウでなければ空文字列を返す。

getcompletion({pat}, {type} [, {filtered}])		*getcompletion()*
		コマンドライン補完のマッチするリストを返す。文字列 {type}は何
		のためのものかを指定する。次の補完タイプがサポートされている:

		arglist		引数リスト内のファイル名
		augroup		自動コマンドグループ
		buffer		バッファ名
		behave		|:behave| サブオプション
		breakpoint	|:breakadd| および |:breakdel| サブオプション
		color		カラースキーム
		command		Exコマンド
		cmdline		|cmdline-completion| の結果
		compiler	コンパイラ
		cscope		|:cscope|のサブオプション
		custom,{func}	{func} で定義されたカスタム補完
		customlist,{func} {func} で定義されたカスタム補完
		diff_buffer     |:diffget| と |:diffput| の補完
		dir		ディレクトリ名
		environment	環境変数名
		event		自動コマンドのイベント
		expression	Vim式
		file		ファイルおよびディレクトリ名
		file_in_path	|'path'|のファイルおよびディレクトリ名
		filetype	ファイルタイプ名 |'filetype'|
		function	関数名
		help		ヘルプ項目
		highlight	ハイライトグループ
		history		|:history| サブオプション
		keymap		キーボードマッピング
		locale		ロケール名 (locale -aの出力)
		mapclear	バッファ引数
		mapping		マッピング名
		menu		メニュー
		messages	|:messages|サブオプション
		option		オプション
		packadd		任意パッケージ |pack-add| 名
		runtime		|:runtime| 補完
		scriptnames	読み込まれているスクリプト名 |:scriptnames|
		shellcmd	シェルコマンド
		sign		|:sign|サブオプション
		syntax		構文ファイル名 |'syntax'|
		syntime		|:syntime|サブオプション
		tag		タグ
		tag_listfiles	タグ、ファイル名
		user		ユーザー名
		var		ユーザー変数

		{pat}が空文字列の場合、すべてのマッチが返される。それ以外の場
		合、{pat}と一致する項目のみが返される。{pat}での特殊文字の使用
		については、|wildcards|を参照。

		オプションの{filtered}フラグが1に設定されている場合、結果をフィ
		ルタリングするために 'wildignore'が適用される。そうでなければ、
		すべての一致が返される。'wildignorecase'オプションは常に適用さ
		れる。

		'wildoptions' オプションが 'fuzzy' を含む場合、補完のマッチ取
		得にファジーマッチが使われる。そうでない場合は正規表現マッチが
		使われる。その結果この関数はコマンドラインで何が起こるかという
		ユーザー設定に従う。これを望まない場合、getcompletion() が呼ば
		れる前に 'wildoptions' を空にしてその後元に戻すようにする。

		{type}が "cmdline" ならば |cmdline-completion| の結果が返され
		る。
		例えば、":call" コマンドの後で補完できる値は: >
			echo getcompletion('call ', 'cmdline')
<
		一致するものがなければ、空のリストが返される。{type}の値が無効
		だと、エラーが発生する。

		|method| としても使用できる: >
			GetPattern()->getcompletion('color')
<
							*getcurpos()*
getcurpos([{winid}])
		カーソルの位置を返す。これは getpos('.') に似ているが、追加の
		"curswant" 情報を含む:
		    [0, lnum, col, off, curswant] ~
		"curswant" は縦方向移動の優先的列番号である。|$| コマンド後は
		非常に巨大な値として |v:maxcol| と同値を返す。
		|getcursorcharpos()| と |getpos()| も参照。
		最初の "bufnum" は常に0である。カーソルのバイトでの位置は
		'col' に返される。文字の位置を得るには |getcursorcharpos()| を
		使う。

		オプションの {winid} 引数はウィンドウを指定する。これはウィン
		ドウ番号か |window-ID| である。最後のカーソル位置を返すが、こ
		れはバッファがカレントウィンドウでない場合、現在の値は無効にな
		りうる。
		{winid} が無効の場合、値がゼロのリストを返す。

		次のようにしてカーソル位置の保存と復元ができる: >
			let save_cursor = getcurpos()
			MoveTheCursorAround
			call setpos('.', save_cursor)
<		Note: これはウィンドウ内でのみ機能する。より多くの状態を復元す
		る方法については |winrestview()| を参照。

		|method| としても使用できる: >
			GetWinid()->getcurpos()
<
							*getcursorcharpos()*
getcursorcharpos([{winid}])
		|getcurpos()| と同様だが返すリスト内の桁番号はバイトインデック
		スの代わりに文字インデックスになっている。

		Example:
		3行目のテキスト "여보세요" の '보' にカーソルがある状態: >
			getcursorcharpos()	returns [0, 3, 2, 0, 3]
			getcurpos()		returns [0, 3, 4, 0, 3]
<
		|method| としても使用できる: >
			GetWinid()->getcursorcharpos()

<							*getcwd()*
getcwd([{winnr} [, {tabnr}]])
		結果は現在の作業ディレクトリ名の文字列である。'autochdir' は無
		視される。

		{winnr} が指定された場合、現在のタブページ内の {winnr} のウィ
		ンドウのローカルカレントディレクトリを返す。{winnr} にはウィン
		ドウ番号または|window-ID|が使える。
		{winnr} が -1 の場合、グローバル作業ディレクトリ名を返す。
		|haslocaldir()| も参照。

		{winnr}と{tabnr}が指定された場合、{tabnr}のタブページ内の
		{winnr}のウィンドウのローカルカレントディレクトリを返す。
		{winnr}が -1 の場合、タブページの作業ディレクトリを返す。
		{winnr}が 0 の場合、カレントウィンドウを使用し、{tabnr}が 0 の
		場合はカレントタブページを使用する。
		引数なしの場合は、カレントウィンドウの実際の作業ディレクトリを
		返す。
		もし引数が不正の場合、空文字列を返す。

		例: >
			" カレントウィンドウの作業ディレクトリを取得
			:echo getcwd()
			:echo getcwd(0)
			:echo getcwd(0, 0)
			" タブページ2のウィンドウ3の作業ディレクトリを取得
			:echo getcwd(3, 2)
			" グローバル作業ディレクトリを取得
			:echo getcwd(-1)
			" タブページ3の作業ディレクトリを取得
			:echo getcwd(-1, 3)
			" カレントタブページの作業ディレクトリを取得
			:echo getcwd(-1, 0)

<		|method| としても使用できる: >
			GetWinnr()->getcwd()

getenv({name})						*getenv()*
		環境変数{name}の値を返す。引数 {name} は先行する '$' のない文
		字列。例: >
			myHome = getenv('HOME')

<		変数が存在しない場合は |v:null| が返される。これは、空の文字列
		に設定された変数とは異なるが、一部のシステムは空の値を削除され
		る変数として解釈する。|expr-env| も参照。

		|method| としても使用できる: >
			GetVarname()->getenv()

getfontname([{name}])					*getfontname()*
		引数なしで使われた場合には現在の通常のフォント名を返す。ハイラ
		イトグループNormalに対して使われるものと同様|hl-Normal|。
		引数が指定された場合には文字列{name}が有効なフォント名であるか
		判定される。有効でないときは空文字列を返す。
		有効なときは実際のフォント名を返す。またはGUIが実際の名前の取
		得をサポートしていないときは{name}をそのまま返す。
		GUIモードで実行しているときのみ動作する。よってvimrcやgvimrcの
		中では使えない。GUIモードが起動した直後にこの関数を呼ぶには、
		自動コマンド|GUIEnter|を使うこと。
		Note GTKのGUIはどんなフォント名でも受け付けてしまうため、名前
		が有効であるかのチェックは機能しない。

getfperm({fname})					*getfperm()*
		{fname}で指定されたファイルの読み込み、書き込み、実行の許可属
		性を示す文字列を返す。
		{fname}が存在しない、またはそのディレクトリが読み込み不可能な
		ときは空文字列を返す。
		戻り値は "rwxrwxrwx" の形で、"rwx" フラグの各グループは順にファ
		イルの所有者、ファイルが所属するグループ、その他のユーザーを表
		す。許可属性が与えられていないフラグは "-" で置き換えられる。
		例: >
			:echo getfperm("/etc/passwd")
			:echo getfperm(expand("~/.vimrc"))
<		この例は、(セキュリティの観点から望ましい設定がされているなら
		ば) "rw-r--r--" あるいは "rw-------" と表示する。

		|method| としても使用できる: >
			GetFilename()->getfperm()
<
		許可属性を設定するには|setfperm()|を使用する。

getfsize({fname})					*getfsize()*
		結果は数値で、{fname}で指定されるファイルのサイズをバイト単位
		で返す。
		{fname}がディレクトリのときは0を返す。
		ファイル{fname}が見つからないときは-1を返す。
		{fname} のサイズが |Number| の範囲外の場合は -2 を返す。

		|method| としても使用できる: >
			GetFilename()->getfsize()

getftime({fname})					*getftime()*
		結果は{fname}で与えられたファイルの、最終更新時間を示す数値。
		1970年1月1日からの経過時間(秒)で、strftime()に渡すことができる
		だろう。|localtime()|と|strftime()|も参照。
		ファイル{fname}が見つからなかった場合には-1を返す。

		|method| としても使用できる: >
			GetFilename()->getftime()

getftype({fname})					*getftype()*
		{fname}で指定されたファイルの種別を示す文字列を返す。
		{fname}が存在しないときは空文字列を返す。
		ファイルの種別とそれらの結果の表を以下に示す:
			通常ファイル		"file"
			ディレクトリ		"dir"
			シンボリックリンク	"link"
			ブロックデバイス	"bdev"
			キャラクタデバイス	"cdev"
			ソケット		"socket"
			FIFO			"fifo"
			それ以外		"other"
		例: >
			getftype("/home")
<		Note "link" などの種別はそれをサポートしているシステムでのみ返
		される。"dir" と "file" しか返らないシステムもある。
		MS-Windowsでは、ディレクトリへのシンボリックリンクは "link" の
		代わりに "dir" を返す。

		|method| としても使用できる: >
			GetFilename()->getftype()

getimstatus()						*getimstatus()*
		結果は数値で、IMEステータスがアクティブの場合は |TRUE| で、そ
		れ以外の場合は |FALSE| である。
		'imstatusfunc' を参照。

getjumplist([{winnr} [, {tabnr}]])			*getjumplist()*
		指定されたウィンドウの |jumplist| を返す。

		引数なしの場合、カレントウィンドウを使用する。
		{winnr} のみの場合、現在のタブページのこのウィンドウを使用す
		る。{winnr} には |window-ID| も使用できる。
		{winnr} と {tabnr} 両方の場合、指定されたタブページのウィンド
		ウを使用する。{winnr} または {tabnr} が無効な場合、空のリスト
		が返される。

		返されるリストは 2 つのエントリを含む: ジャンプ位置のリストと、
		リスト内の最後に使われたジャンプ位置番号。ジャンプ位置リスト内
		のそれぞれの項目は、以下の項目を含む辞書になっている:
			bufnr		バッファ番号
			col		列番号
			coladd		'virtualedit' 用の列のオフセット
			filename	利用可能ならばファイル名
			lnum		行番号

		|method| としても使用できる: >
			GetWinnr()->getjumplist()

<							*getline()*
getline({lnum} [, {end}])
		{end}が指定されない場合は、カレントバッファの{lnum}行目の内容
		を文字列にして返す。例: >
			getline(1)
<		{lnum}が数字ではない文字で始まる文字列であった場合、|line()|に
		よってその文字列が数字に変換される。よって、カーソルのある行の
		文字列を取得するには: >
			getline(".")
<		{lnum}が1より小さいかバッファの行数よりも大きい数値の場合、空
		文字列が返される。

		{end}が指定された場合は、カレントバッファの{lnum}行目から
		{end}行目までを要素とするリスト|List|を返す。
		{end}は{lnum}と同様に解釈される。
		存在しない行は省略され、エラーメッセージは表示されない。
		{end}が{lnum}より前になる場合は空リストを返す。
		例: >
			:let start = line('.')
			:let end = search("^$") - 1
			:let lines = getline(start, end)

<		|method| としても使用できる: >
			ComputeLnum()->getline()

<		他のバッファの行を取得するには |getbufline()| および
		|getbufoneline()| を参照。

getloclist({nr} [, {what}])				*getloclist()*
		ウィンドウ{nr}のlocationリストの全項目からなるリスト |List| を
		返す。{nr} にはウィンドウ番号または |window-ID| が使える。{nr}
		に0を指定するとカレントウィンドウになる。

		locationリストウィンドウに対して使用すると、そこに表示されてい
		るlocationリストが返る。ウィンドウ番号{nr}が無効な場合は、空リ
		ストが返る。それ以外は |getqflist()| と同じ。

		オプションの{what}辞書引数が指定されている場合、{what}にリスト
		されている項目を辞書として返す。{what}のサポートされている項目
		については、|getqflist()|を参照。

		|getqflist()| の{what}でサポートされている項目に加え、
		|getloclist()| では次の項目もサポートされている:

			filewinid	ロケーションリストからファイルを表示す
					るのに使われているウィンドウのID。この
					フィールドはロケーションリストウィンド
					ウから呼び出されたときのみ適用される。
					詳細は |location-list-file-window| を
					参照。

 		ウィンドウ {nr} にlocationリストがないなら、デフォルト値の辞書
 		|Dictionary| を返す。
		ウィンドウが存在しない場合、空の辞書を返す。

		例 (|getqflist-examples| もまた参照): >
			:echo getloclist(3, {'all': 0})
			:echo getloclist(5, {'filewinid': 0})


getmarklist([{buf}])					*getmarklist()*
		{buf} 引数が無い場合は全グローバルマークについての情報のリスト
		を返す。|mark|

		オプショナル引数 {buf} が指定されている場合、{buf} で指定され
		たバッファのローカルマークの値を返す。{buf} の使い方は
		|bufname()| を参照。{buf} が無効な場合、空のリストが返される。

		戻り値のリストの各要素は以下の内容の辞書|Dict|になっている:
		    mark   接頭辞 "'" が付いたマークの名前
		    pos    マークの位置のリスト|List|:
				[bufnum, lnum, col, off]
		       詳細は |getpos()| を参照。
		    file   ファイル名

		特定のマークについて取得した情報の詳細は |getpos()| を参照。

		|method| としても使用できる: >
			GetBufnr()->getmarklist()

getmatches([{win}])					*getmatches()*
		|matchadd()| と |:match| によりカレントウィンドウに定義された
		全てのマッチの |List| を返す。|setmatches()| は |getmatches()|
		で保存されたマッチのリストを復元できるので、|getmatches()| と
		|setmatches()| は組み合わせて使うと便利である。
		{win} が指定されたなら、カレントウィンドウの代わりに指定された
		番号かウィンドウIDのウィンドウを使う。{win} が無効な場合、空の
		リストが返される。
		例: >
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:let m = getmatches()
			:call clearmatches()
			:echo getmatches()
<			[] >
			:call setmatches(m)
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:unlet m
<
getmousepos()						*getmousepos()*
		マウスの最新の位置を示す辞書 |Dictionary| を返す。マウスクリッ
		クのマッピングやポップアップウィンドウのフィルターで使うことが
		できる。辞書の要素は:
			screenrow	画面行
			screencol	画面桁
			winid		クリックされたウィンドウ ID
			winrow		"winid" 内の行
			wincol		"winid" 内の桁
			line		"winid" 内のテキスト行
			column		"winid" 内のテキスト桁
			coladd		クリックされた文字の先頭からのオフセッ
					ト (スクリーン桁)。
		全ての数値は 1 ベースである。

		ウィンドウの上ではない場合、例えばコマンドラインの中などでは
		"screenrow" と "screencol" のみが有効で、残りは 0 になる。

		ウィンドウの下のステータスラインやウィンドウの右の垂直セパレー
		ターの場合、"line" と "column" は 0 になる。

		位置がテキストより後の場合、"column" はテキストのバイト長+1に
		なる。

		マウスがポップアップウィンドウの上の場合、そのウィンドウが使わ
		れる。

		|getchar()| を使ったとき、Vim 変数 |v:mouse_lnum|,
		|v:mouse_col| と |v:mouse_winid| もこれらの値を提供する。

getmouseshape()						*getmouseshape()*
		現在表示されているマウスポインタの名前を返す。 |+mouseshape|
		機能がサポートされていないか、形状が不明な場合は空文字列が返さ
		れる。
		この機能は主にテストを目的としている。

							*getpid()*
getpid()	Vim のプロセス ID を数値で返す。Unix と MS-Windows では Vim が
		終了するまでこれは一意な数値である。

							*getpos()*
getpos({expr})	文字列{expr}の位置を返す。{expr}として指定できる値については
		|line()|を参照。カーソル位置を得るには |getcurpos()| を参照。
		結果は次の4個の要素を持つリスト|List|:
		    [bufnum, lnum, col, off]
		"bufnum" は、'0 や 'A のようなマークが指定されたときは、その
		マークのバッファ番号となる。それ以外では0となる。
		"lnum" と "col" はバッファ中の位置。桁番号は1から始まる。
		"off" の値は、'virtualedit' がオフのときは常に0で、オンのとき
		はその文字の始点からの画面上の桁のオフセットである。つまり、
		カーソルが<Tab>の中や、その行の最後の文字より後にあるとき意味
		を持つ。
		Note: ビジュアルモードの '< と '> について: ビジュアルモードが
		"V" (行選択モード) のとき、'< の桁番号はゼロ、'> の桁番号は大
		きな値として |v:maxcol| と同値になる。
		桁番号は行内のバイト位置のリストとして返される。行内の文字での
		位置を取得するなら、|getcharpos()| を使う。
		桁番号は |v:maxcol| と同値の非常に大きな値になり得る。これは
		"行末の後" を意味する。
		{expr} が無効な場合、すべてがゼロのリストが返される。
		この関数はマークの位置を保存し、復元するために使われる: >
			let save_a_mark = getpos("'a")
			...
			call setpos("'a", save_a_mark)
<		|getcharpos()| と |getcurpos()| そして |setpos()| も参照。

		|method| としても使用できる: >
			GetMark()->getpos()

getqflist([{what}])					*getqflist()*
		現在の全quickfixエラーのリスト |List| を返す。リストの各要素は
		辞書で、以下の要素を持つ:
			bufnr	ファイル名を持つバッファの番号。その名前を取得
				するにはbufname()を使う。
			module	モジュール名
			lnum	バッファ中の行番号(最初の行は1)
			end_lnum
				項目が複数行のときの最後の行番号
			col	桁番号(最初の桁は1)
			end_col	項目が範囲を持つときの最後の桁番号
			vcol	|TRUE|: "col" は画面上の桁
				|FALSE|: "col" はバイトインデックス
			nr	エラー番号
			pattern	エラーの位置を特定するために使う検索パターン
			text	エラーの説明
			type	エラーメッセージの種類。'E', '1' など。
			valid	|TRUE|: エラーメッセージが認識されている
			user_data
				項目に関連付けられたカスタムデータは、任意の型
				にすることができる。

		エラーリストがまったくないか、空であるときは空リストを返す。
		quickfixリストの項目が存在しないバッファ番号とともに返る場合は
		"bufnr" を0にして返される。(Note: いくつかの関数はバッファ番号
		0を代替バッファとして受け付けるので、明確に0チェックを行う必要
		がある)。

		役に立つ応用例: 複数のファイルから正規表現検索を行い、見つかっ
		たものに対してなんらかの操作をする: >
			:vimgrep /theword/jg *.c
			:for d in getqflist()
			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			:endfor
<
		オプションの{what}辞書引数が指定されている場合は、{what}にリス
		トされている項目のみを辞書として返す。{what}では、以下の文字列
		項目がサポートされている:
			changedtick	リストに行われた変更の総数を取得
					|quickfix-changedtick|
			context	|quickfix-context| を取得
			efm	"lines" をパースするときに使われるエラーフォー
				マット。存在しない場合はオプション
				'errorformat' の値が使用される。
			id	|quickfix-ID|に対応するquickfixリストの情報を
				取得。0 は現在のリストもしくは "nr" で指定され
				たリストのidを意味する
			idx	'id' または 'nr' で指定されたquickfixリスト内
				の情報を取得した最後のエントリのインデックス。
				もし0なら、カレントのエントリが使われる。
				|quickfix-index| を参照
			items	quickfixリストのエントリ
			lines	'efm' を使用して行のリストをパースし、結果のエ
				ントリを返す。|List| 型のみを受け付ける。現在
				のquickfixリストは変更を受けない。
				|quickfix-parse|を参照。
			nr	このquickfixリストの情報を取得。0 は現在の
				quickfixリストを意味し、"$" は最後のquickfixリ
				ストを意味する
			qfbufnr quickfixウィンドウに表示されているバッファの番
				号。quickfixバッファが存在しないなら 0 が返る。
				|quickfix-buffer| を参照。
			size	quickfixリスト内のエントリの数
			title	リストタイトルを取得 |quickfix-title|
			winid	quickfixの|window-ID|を取得
			all	上記のquickfixのすべてのプロパティ
		{what} の文字列以外の項目は無視される。特定の項目の値を取得す
		るには 0 を設定する。
		"nr" が存在しない場合、現在のquickfixリストが使用される。"nr"
		と 0 でない "id" が両方とも指定されていた場合、"id" で指定され
		たリストが使用される。
		quickfixスタック内のリストの数を取得するには、{what} 内で "nr"
		に "$" を設定する。返される辞書内の "nr" の値がquickfixスタッ
		クサイズである。
		"lines" が指定された場合、"efm" を除くその他すべての項目は無視
		される。返される辞書は、エントリのリストからなるエントリ
		"items" を含む。

		返される辞書には、次のエントリが含まれる:
			changedtick	リストに行われた変更の総数
					|quickfix-changedtick|
			context	quickfixリストコンテキスト。|quickfix-context|
				を参照。存在しない場合、"" に設定される。
			id	quickfixリストID |quickfix-ID|。存在しない場
				合、0 に設定される。
			idx	リスト内のquickfixのエントリのインデックス。
				存在しない場合、0 に設定される。
			items	quickfixリストのエントリ。存在しない場合、空リ
				ストに設定される。
			nr	quickfixリスト番号。存在しない場合、0 に設定さ
				れる。
			qfbufnr quickfixウィンドウに表示されているバッファの番
				号。存在しない場合、0 に設定される。
			size	quickfixリスト内のエントリの数。存在しない場
				合、0 に設定される。
			title	quickfixリストのタイトルテキスト。存在しない場
				合、"" に設定される。
			winid	quickfixの|window-ID|。存在しない場合、0 に設
				定される。

		例 (|getqflist-examples|も参照): >
			:echo getqflist({'all': 1})
			:echo getqflist({'nr': 2, 'title': 1})
			:echo getqflist({'lines' : ["F1:10:L10"]})
<
getreg([{regname} [, 1 [, {list}]]])			*getreg()*
		レジスタ{regname}の中身を文字列にして返す。例: >
			:let cliptext = getreg('*')
<		レジスタ {regname} がセットされていないときは、結果は空文字列
		となる。
		引数 {regname} は文字列である必要がある。 *E1162*

		getreg('=')は最後に評価した式レジスタの値を返す。(マップの中で
		使用する)。
		getreg('=', 1)はその式そのものを返す。これを使って|setreg()|で
		復元することができる。他のレジスタの場合は、この引数は無視され
		るので、常に指定していても害はない。
		{list} が指定され、その値が|TRUE|のときは、戻り値はリスト
		(|List|) になる。リストの各要素はテキスト 1 行である。これはレ
		ジスタの中に値ゼロのバイトが含まれる場合に使用する。{list} を
		指定しなかった場合は NL 文字と値ゼロのバイトは両方とも NL 文字
		として扱われる (|NL-used-for-Nul| 参照)。
		指定したレジスタがセットされていないときは、空のリストが返され
		る。

		{regname} が "" の場合、無名レジスタ '"' が使われる。
		{regname}を指定しないときは|v:register|が使われる。
		|Vim9-script| では {regname} は1文字でなくてはならない。

		|method| としても使用できる: >
			GetRegname()->getreg()

getregion({pos1}, {pos2} [, {opts}])			*getregion()*
		バッファから、{pos1} から {pos2} までの文字列のリストを返す。

		{pos1} と {pos2} はともに 4 つの整数からなる |List| でな
		ければならない。このリストの形式については |getpos()| を参照。
		他のバッファの位置を指定することができるが、|getregion-notes|
		にある制限に注意すること。

		オプショナル引数の {opts} は以下の項目をサポートする辞書である:

			type		範囲の選択のタイプを指定する (デフォル
					ト: "v"):
			    "v"		|characterwise| モード
			    "V"		|linewise| モード
			    "<CTRL-V>"	|blockwise-visual| モード

			exclusive	|TRUE| の場合、末尾の位置に排他的な選
					択を用いる。
					(デフォルト: 'selection' に従う)

		|visualmode()| で最後の選択のタイプを取得することができる。
		ビジュアルモードがアクティブな場合は、現在のビジュアルモードを
		|mode()| で取得する (例えば、|:vmap| の中)。
		この関数は、|characterwise-visual| 選択のような、始まりと終わ
		りが異なる桁のテキストを取得するのに便利である。

							*getregion-notes*
		Note:
		- {pos1} と {pos2} の順序は重要ではなく、常に左上の位置から右
		  下の位置までの内容を返す。
		- 'virtualedit' が有効で、領域が行末を越える場合、結果の行は空
		  白で埋められる。
		- 領域が矩形単位で、複数セル文字の途中で開始または終了する場
		  合、その文字は含まれないが、その選択された部分は空白で置き換
		  えられる。
		- {pos1} と {pos2} が同じバッファにない場合は、空のリストが返
		  される。
		- {pos1} と {pos2} は必ず |bufloaded()| なバッファ上になければ
		  ならない。
		- これはカレントウィンドウのコンテキストで評価されるので、バッ
		  ファが 'virtualedit' または 'list' の値が異なるウィンドウに
		  表示される場合に違いが生じる。

		例: >
			:xnoremap <CR>
			\ <Cmd>echow getregion(
			\ getpos('v'), getpos('.'), #{ type: mode() })<CR>
<
		|method| としても使用できる: >
			getpos('.')->getregion(getpos("'a"))
<
getreginfo([{regname}])					*getreginfo()*
		レジスタ {regname} についての詳細情報として次の項目を持つ辞書
		を返す:
			regcontents	レジスタ {regname} に格納されている行
					の、|getreg|({regname}, 1, 1) と同様の
					リスト。
			regtype		レジスタ {regname} の |getregtype()|
					相当の種別。
			isunnamed	真偽値フラグ、v:true は現在指している
					レジスタが無名レジスタであることを示
					す。
			points_to	無名レジスタであれば、現在指しているレ
					ジスタを示す単一文字 (|quotequote|を参
					照)。
					例えば、行を `dd` で削除後、このフィー
					ルドは "1" となりそのレジスタには削除
					したテキストが入る。

		引数 {regname} は文字列。{regname} が不正なレジスタ名もしくは
		未設定の場合、空の辞書が返される。{regname} が "" か "@" の場
		合、無名レジスタ '"' が使われる。
		{regname} が未指定の場合、|v:register| が使われる。
		戻り値の辞書は |setreg()| に渡すことができる。
		|Vim9-script| では {regname} は1文字でなくてはならない。

		|method| としても使用できる: >
			GetRegname()->getreginfo()

getregtype([{regname}])					*getregtype()*
		レジスタ{regname}の種類を表す文字列を返す。
		戻り値は次のいずれかとなる:
		    "v"			文字単位|characterwise|の場合
		    "V"			行単位|linewise|の場合
		    "<CTRL-V>{width}"	矩形|blockwise-visual|の場合
		    ""			空、または未知のレジスタの場合
		<CTRL-V>は値0x16の1文字である。
		引数 {regname} は文字列。{regname} が "" の場合、無名レジスタ
		'"' が使われる。{regname}を指定しないときは|v:register|が使わ
		れる。
		|Vim9-script| では {regname} は1文字でなくてはならない。

		|method| としても使用できる: >
			GetRegname()->getregtype()

getscriptinfo([{opts}])					*getscriptinfo()*
		`:scriptnames` が見せるように、読み込まれたすべての Vim script
		に関する情報を読み込まれた順序で |List| として返す。

		オプションの Dict 引数 {opts} は、以下のオプション項目をサポー
		トする:
		    name	スクリプト名の一致パターン。指定され、"sid" が
				指定されていない場合は、パターン "name" に一致
				する名前を持つスクリプトに関する情報が返され
				る。
		    sid		スクリプト ID |<SID>|。指定された場合、ID "sid"
				のスクリプトに関する情報のみが返され、"name"
				は無視される。

		返されたリストの各項目は、以下の項目を持つ |Dict| である:
		    autoload	`import autoload` で使用されたが、実際にはまだ
				読み込まれていないスクリプトには TRUE を設定す
				る (|import-autoload| を参照)。
		    functions   スクリプト内で定義されているスクリプトローカル
				関数名のリスト。特定のスクリプトが {opts} の
				"sid" 項目を使って指定されている場合にのみ表示
				される。
		    name	Vim script ファイル名。
		    sid		スクリプト ID |<SID>|。
		    sourced	このスクリプト名がリンクしている実際に読み込ま
				れたスクリプトが存在する場合はスクリプト ID、
				それ以外の場合はゼロ
		    variables   スクリプトローカル変数を含む辞書。{opts} の
				"sid" 項目を使って特定のスクリプトを指定した場
				合のみ存在する。
				Note これはコピーであり、この辞書を使ってスク
				リプトローカル変数の値を変更することはできない
				ことに注意。
		    version	Vim script バージョン (|scriptversion|)

		例: >
			:echo getscriptinfo({'name': 'myscript'})
			:echo getscriptinfo({'sid': 15}).variables
<
gettabinfo([{tabnr}])					*gettabinfo()*
		{tabnr}を指定しないと、すべてのタブページに関する情報がリスト
		|List| として返される。各リスト項目は辞書 |Dictionary| である。
		それ以外の場合、{tabnr} はタブページ番号を指定し、それに関する
		情報が返される。タブページが存在しない場合、空のリストが返され
		る。

		各リストアイテムは、次のエントリを持つ辞書 |Dictionary| である:
			tabnr		タブページ番号。
			variables	タブページローカル変数の辞書への参照。
			windows		タブページの|window-ID|のリスト。

		|method| としても使用できる: >
			GetTabnr()->gettabinfo()

gettabvar({tabnr}, {varname} [, {def}])				*gettabvar()*
		タブページ {tabnr} のタブローカル変数 {varname} を取得する。
		|t:var|
		タブの番号は 1 から始まる。
		引数 {varname} は文字列。{varname} が空のときは全タブローカル
		変数からなる辞書を返す。
		Note: 指定する変数名は "t:" を除いた名前。
		タブや変数が存在しないときは{def}または空文字列を返し、エラー
		メッセージは表示されない。

		|method| としても使用できる: >
			GetTabnr()->gettabvar(varname)

gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])		*gettabwinvar()*
		タブページ{tabnr}内のウィンドウ{winnr}のウィンドウローカル変数
		{varname}の値を取得する。
		引数 {varname} は文字列。{varname}が空のときは全ウィンドウロー
		カル変数からなる辞書を返す。
		{varname}が "&" と等しい場合はすべてのウィンドウローカルオプ
		ションの値を辞書 |Dictionary| に入れて返す。
		{varname}が文字 "&" で始まるときはウィンドウローカルオプション
		の値を取得する。
		Note {varname}は "w:" をつけずに指定しなければならない。
		タブページ番号は1から始まる。カレントタブページを指定するには
		|getwinvar()|を指定する。
		{winnr} にはウィンドウ番号または|window-ID|が使える。
		{winnr}が0のときはカレントウィンドウとなる。
		グローバルオプション、バッファローカルオプション、ウィンドウ
		ローカルオプションに対しても動作するが、グローバル変数やバッ
		ファローカル変数に対しては動作しない。
		ウィンドウやタブや変数が存在しないときは{def}または空文字列を
		返し、エラーメッセージは表示されない。
		例: >
			:let list_is_on = gettabwinvar(1, 2, '&list')
			:echo "myvar = " .. gettabwinvar(3, 1, 'myvar')
<
		すべてのウィンドウローカル変数を取得するには: >
			gettabwinvar({tabnr}, {winnr}, '&')

<		|method| としても使用できる: >
			GetTabnr()->gettabwinvar(winnr, varname)

gettagstack([{winnr}])					*gettagstack()*
		結果は辞書で、それはウィンドウ{winnr}のタグスタックである。
		{winnr}にはウィンドウ番号または |window-ID| を指定できる。
		{winnr}を指定しない時は、カレントウィンドウが使用される。
		ウィンドウ{winnr}が存在しない場合、空の辞書が返される。

		返される辞書には、次のエントリが含まれる:
			curidx		スタック内の現在のインデックス。スタッ
					クの最上部にあるときは、(length + 1)
					に設定される。スタックの最下部のイン
					デックスは1である。
			items		スタック内の項目のリスト。各項目は、以
					下で説明するエントリを含む辞書である。
			length		スタック内の項目数

		スタック内の各項目は、次のエントリを持つ辞書である:
			bufnr		現在のジャンプのバッファ番号
			from		タグジャンプの前のカーソル位置。返され
					るリストの形式は |getpos()| を参照。
			matchnr		現在の一致するタグ番号。名前に一致する
					複数のタグが見つかった場合に使用され
					る。
			tagname		タグの名前

		タグスタックについての詳細は、|tagstack| を参照。

		|method| としても使用できる: >
			GetWinnr()->gettagstack()


gettext({text})						*gettext()*
		可能であれば文字列 {text} を翻訳する。
		これは主に配布する Vim script で使う。
		メッセージの翻訳を生成するときに {text} が xgettext によって抽
		出され、翻訳者が .po ファイルで翻訳済みメッセージを追加でき
		Vim は gettext() が呼ばれた時に翻訳を検索する。
		{text} はダブルクォートの文字列が望しい、なぜなら xgettext は
		シングルクォートの文字列でのエスケープを理解しないため。


getwininfo([{winid}])					*getwininfo()*
		ウィンドウに関する情報を、辞書のリスト |List| として返す。

		{winid}が与えられた場合、そのIDを持つウィンドウに関する情報が
		リスト |List| として1項目にして返される。ウィンドウが存在しな
		い場合、結果は空のリストになる。

		{winid}がなければすべてのタブページのすべてのウィンドウに関す
		る情報が返される。

		リストの各項目は次のエントリを持つ辞書 |Dictionary| である:
			botline		最下の完全に表示されたバッファ行
			bufnr		ウィンドウ内のバッファ番号
			height		ウィンドウの高さ (winbarを除く)
			loclist		locationリストを表示してる場合は1
					{Vimが|+quickfix|機能付きでコンパイル
					されたときのみ有効}
			quickfix	quickfixまたはlocationリストウィンドウ
					の場合は1
					{Vimが|+quickfix|機能付きでコンパイル
					されたときのみ有効}
			terminal	端末ウィンドウの場合は 1
					{Vimが|+terminal|機能付きでコンパイル
					されたときのみ有効}
			tabnr		タブページ番号
			topline		最上に表示されたバッファ行
			variables	ウィンドウローカル変数の辞書への参照
			width		ウィンドウ幅
			winbar		ウィンドウがツールバーを持っていれば
					1、そうでなければ 0
			wincol		ウィンドウの最も左のスクリーン列、
					|win_screenpos()| の "col"
			textoff		テキストの前の'foldcolumn',
					'signcolumn', 行番号が占める列数
			winid		|window-ID|
			winnr		ウィンドウ番号
			winrow		ウィンドウの最も上のスクリーン行、
					|win_screenpos()| の "row"

		|method| としても使用できる: >
			GetWinnr()->getwininfo()

getwinpos([{timeout}])					*getwinpos()*
		結果は、|getwinposx()| と |getwinposy()| の結果が組み合わされ
		た 2 つの数字のリスト |List|:
			[x-pos, y-pos]
		{timeout} は端末からの応答をどれくらい待つかを、ミリ秒単位で指
		定するのに使われる。省略された場合は 100 ミリ秒が使用される。
		リモート端末にはより長い時間を指定すること。
		10 より小さい値が使用され、かつその時間内に応答を受け取らなかっ
		た場合、利用可能であれば前に報告された位置が返される。これは位
		置をポーリングし、同時に何かを行う場合に使用することができる: >
			while 1
			  let res = getwinpos(1)
			  if res[0] >= 0
			    break
			  endif
			  " Do some work here
			endwhile
<

		|method| としても使用できる: >
			GetTimeout()->getwinpos()
<
							*getwinposx()*
getwinposx()	結果はGUIのVimウィンドウの左端の、デスクトップ上でのX座標値(数
		値)。xtermでも機能する (100 ミリ秒のタイムアウトを使用して)。
		情報が存在しない (例: Wayland バックエンド) 場合は-1となる。
		この値は `:winpos` でも使用される。

							*getwinposy()*
getwinposy()	結果はGUIのVimウィンドウの上端の、デスクトップ上でのY座標値(数
		値)。xtermでも機能する (100 ミリ秒のタイムアウトを使用して)。
		情報が存在しない (例: Wayland バックエンド) 場合は-1となる。
		この値は `:winpos` でも使用される。

getwinvar({winnr}, {varname} [, {def}])				*getwinvar()*
		カレントタブページに対する|gettabwinvar()|と同様。
		例: >
			:let list_is_on = getwinvar(2, '&list')
			:echo "myvar = " .. getwinvar(1, 'myvar')

<		|method| としても使用できる: >
			GetWinnr()->getwinvar(varname)
<
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])		*glob()*
		{expr}内のファイル名のワイルドカードを展開する。特殊文字につい
		ては|wildcards|を参照。

		{nosuf} に|TRUE|を指定しない限り、'suffixes' と 'wildignore'
		が適用される。つまり 'wildignore' のパターンにマッチする名前は
		スキップされ、'suffixes' がマッチの順番に影響を与える。
		'wildignorecase' は常に適用される。

		{list} が指定されその値が|TRUE|なら、マッチしたすべてのファイ
		ルがリスト |List| として返される。リストを使うことで、改行を含
		むファイル名があっても結果を正しく受け取ることができる。
		そうでない場合は結果は文字列で返される。その場合、複数のマッチ
		があるときはそれらは文字 <NL> で区切られる。

		展開が失敗した場合、空の文字列またはリストが返される。

		マッチの数を制限するなど、複雑なことをする必要がある場合にも
		|readdir()| を使用することができる。

		存在しないファイル名は結果に含まれない。シンボリックリンクは、
		それが存在するファイルを指す場合のみ含まれる。
		ただし、{alllinks} 引数が存在し、それが|TRUE|である場合はすべ
		てのシンボリックリンクが含まれる。

		多くのシステムではバッククォート(「`」という文字のこと)を、外
		部コマンドの実行結果からファイル名を取得するために使用できる。
		例: >
			:let tagfiles = glob("`find . -name tags -print`")
			:let &tags = substitute(tagfiles, "\n", ",", "g")
<		バッククォート内のプログラムの実行結果は、一行に一つずつの項目
		が含まれてなければならない。項目内のスペースは許容される。

		特殊なVimの変数を展開するためには|expand()|を参照。外部コマン
		ドの生の出力を得るためには|system()|を参照。

		|method| としても使用できる: >
			GetExpr()->glob()

glob2regpat({string})					 *glob2regpat()*
		glob()に使われるファイルパターンを検索パターンに変換する。
		結果はファイル名の文字列とのマッチに使用できる。例えば、 >
			if filename =~ glob2regpat('Make*.mak')
<		上記は次と同じである: >
			if filename =~ '^Make.*\.mak$'
<		{string}が空文字列の場合、結果は "^$" で、空文字列にマッチす
		る。結果はシステムによって異なることに注意すること。MS-Windows
		では、バックスラッシュは通常、パス区切りを意味する。

		|method| としても使用できる: >
			GetExpr()->glob2regpat()
<								*globpath()*
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
		{path}の中の全ディレクトリで文字列 {expr} に対して|glob()|を実
		行し、結果を連結する。例: >
			:echo globpath(&rtp, "syntax/c.vim")
<
		{path}はコンマ区切りのディレクトリのリスト。各ディレクトリを
		{expr}の前に付加し、glob()と同様にそれを展開する。必要に応じて
		パスの区切り文字が挿入される。
		ディレクトリ名の中にコンマを含めるには、バックスラッシュでエス
		ケープすること。Note MS-Windowsではディレクトリ名の末尾にバッ
		クスラッシュがつくことがある。その後に区切りのコンマを書くとエ
		スケープと見なされてしまうので、バックスラッシュは削除すること。
		どれかのディレクトリに対して展開が失敗してもエラーメッセージは
		表示されない。

		{nosuf} に|TRUE|が指定されない限り、オプション 'wildignore' が
		適用される。つまり、'wildignore' のパターンにマッチする名前は
		スキップされる。

		{list} が指定され、その値が|TRUE|なら、マッチしたすべてのファ
		イルがリスト |List| として返る。リストとして受け取る利点は、改
		行文字を含んだファイル名も正しく扱えることである。{list} を指
		定しなかった場合は、戻り値は文字列であり、マッチした複数のファ
		イル名は <NL> 文字で連結されてしまう。例: >
			:echo globpath(&rtp, "syntax/c.vim", 0, 1)
<
		{alllinks} は|glob()|の場合と同様に扱われる。

		"**" を使ってディレクトリツリーを再帰的に検索することができる。
		例えば、'runtimepath' とそれ以下のディレクトリから全ての
		"README.txt" を探すには次のようにする: >
			:echo globpath(&rtp, "**/README.txt")
<		上向き検索と、"**" の深さの限界はサポートされていない。よって
		オプション 'path' の値をそのまま使うとうまく動かないことが
		ある。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetExpr()->globpath(&rtp)
<
							*has()*
has({feature} [, {check}])
		{check} がない、もしくは0: 結果は機能{feature}がサポートしてい
		る場合1、されない場合0となる。引数{feature}は文字列で大文字/
		小文字の区別が無視される。下記の |feature-list| を参照。

		{check} があり、0でない: 結果は数値で、機能{feature}が既知であ
		る場合1、そうでない場合0となる。これは {feature} の誤字のチェッ
		クとデッドコードの検知に便利。古いバージョンの Vim は後で追加
		される機能のことは知らず、現在のバージョンの Vim は放棄された
		機能のことを知らないということに注意。

		|exists()| と |exists_compiled()| も参照。

		Note ある機能が無い時に文法エラーとなるコードをスキップするた
		めには、Vim は行の残りをスキップし、後続の `endif` を見逃すか
		もしれないことに注意。そのためには、`endif` を独立した行に置く
		: >
			if has('feature')
			  let x = this->breaks->without->the->feature
			endif
<		もし `endif` を2行目に "| endif" として移動させると見付けられ
		なくなる。

has_key({dict}, {key})					*has_key()*
		結果は数値で、辞書|Dictionary| {dict}がキー{key}の要素を持つな
		ら真、持たないなら偽となる。
		引数 {key} は文字列。|Vim9| script では数値も受け入れられる
		(そして文字列に変換される) が、他の型は受け入れられない。
		旧来のスクリプトでは、通常の文字列への自動変換が行われる。

		|method| としても使用できる: >
			mydict->has_key(key)

haslocaldir([{winnr} [, {tabnr}]])			*haslocaldir()*
		結果は数値である:
		    1   ウィンドウが |:lcd| によってローカルディレクトリを設定
			している時
		    2   タブページが |:tcd| によってローカルディレクトリを設定
			している時
		    0   その他

		引数が指定されない場合、現在のウィンドウを対象とする。
		{winnr}が指定された場合、現在のタブページ内の{winnr}のウィンド
		ウを対象とする。
		{winnr}と{tabnr}が指定された場合、{tabnr}のタブページ内の
		{winnr}のウィンドウを対象とする。
		{winnr} にはウィンドウ番号または|window-ID|が使える。
		{winnr}が -1 の場合は無視され、タブページのみが使用される。
		もし引数が不正の場合、0 を返す。

		例: >
			if haslocaldir() == 1
			  " ウィンドウローカルディレクトリの場合
			elseif haslocaldir() == 2
			  " タブページローカルディレクトリの場合
			else
			  " グローバルディレクトリの場合
			endif

			" カレントウィンドウ
			:echo haslocaldir()
			:echo haslocaldir(0)
			:echo haslocaldir(0, 0)
			" カレントタブページのウィンドウn
			:echo haslocaldir(n)
			:echo haslocaldir(n, 0)
			" タブページmのウィンドウn
			:echo haslocaldir(n, m)
			" タブページm
			:echo haslocaldir(-1, m)
<
		|method| としても使用できる: >
			GetWinnr()->haslocaldir()

hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
		結果は数値。右辺側(マップした先)の一部分に{what}を含むマッピン
		グが存在し、それが{mode}で指定されたモードのいずれかで定義され
		ているなら真を返す。
		引数 {what} と {mode} は文字列。
		{abbr}が指定されていて|TRUE|のときはマッピングでなく短縮入力の
		存在を判定する。挿入モードまたはコマンドモードを指定することを
		忘れないように。
		グローバルマップとバッファローカルマップの両方をチェックする。
		マッピングが1個も見つからなかったときは偽を返す。
		{mode}に対しては以下の文字が利用できる:
			n	ノーマルモード
			v	ビジュアルモードおよび選択モード
			x	ビジュアルモード
			s	選択モード
			o	オペレータ待機モード (Operator-pending)
			i	挿入モード
			l	Language-Argumentモード ("r", "f", "t" など)
			c	コマンドラインモード
		{mode}が省略されたときは "nvo" となる。

		この関数はVim scriptの中で、ある関数へのマッピングが既に存在す
		るか判定するために有用である。例: >
			:if !hasmapto('\ABCdoit')
			:   map <Leader>d \ABCdoit
			:endif
<		この例は、"\ABCdoit" へのマッピングが存在しないときだけ
		"\ABCdoit" へのマッピングを作成する。

		|method| としても使用できる: >
			GetRHS()->hasmapto()

histadd({history}, {item})				*histadd()*
		文字列{item}を履歴{history}に追加する。履歴{history}は以下のう
		ちどれか一つから選択:			*hist-names*
			"cmd"	 or ":"	  コマンドライン履歴
			"search" or "/"   検索パターン履歴
			"expr"   or "="   タイプされた式の履歴
			"input"  or "@"	  input()の履歴
			"debug"  or ">"   デバッグコマンドの履歴
		{history} 文字列はフルネームで指定する必要はありません。頭文字
		だけでも構いません。
		{item}が履歴内に既に存在する場合、それが最新の項目の位置へシフ
		トされる。結果は数値:操作が成功した場合真、そうでなければ偽が
		返る。

		例: >
			:call histadd("input", strftime("%Y %b %d"))
			:let date=input("Enter date: ")
<		サンドボックス|sandbox|の中では利用できない。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetHistory()->histadd('search')

histdel({history} [, {item}])				*histdel()*
		{history}の内容を削除する。例えば全てのエントリを消すこともで
		きる。{history}の部分に可能な値は|hist-names|を参照。

		パラメーター{item}が文字列に評価される場合、これは正規表現と
		して扱われる。その表現にマッチする全てのエントリがhistoryから
		削除される(複数あっても)。
		"\c" をつけない場合、大文字・小文字が一致しなければならない。
		|/\c|。
		{item}が数値に評価される場合、インデックスとして解釈される。イ
		ンデックスについては|:history-indexing|を参照。関連するエントリ
		{訳注: The respective entry} も、存在すれば削除される。

		結果は削除に成功すれば真、そうでなければ偽が返る。

		例:
		式レジスタの履歴を削除する: >
			:call histdel("expr")
<
		検索履歴から、"*" で始まるエントリを全て削除する: >
			:call histdel("/", '^\*')
<
		次の3つは等価である: >
			:call histdel("search", histnr("search"))
			:call histdel("search", -1)
			:call histdel("search", '^' .. histget("search", -1) .. '$')
<
		最後の検索パターンを削除し、一つ前のパターンを "n" コマンド(次
		のマッチへ移動)と 'hlsearch' の為に設定する: >
			:call histdel("search", -1)
			:let @/ = histget("search", -1)
<
		|method| としても使用できる: >
			GetHistory()->histdel()

histget({history} [, {index}])				*histget()*
		結果は{history}の第{index}エントリを表わす文字列。{history} の
		部分に可能な値は|hist-names|を、{index}については
		|:history-indexing|を参照。指定されたエントリが存在しない場合
		は空文字列が返される。{index}が省略された場合には、履歴中の最
		新のエントリが戻り値として使用される。

		例:
		2つ前に行われた検索をやり直す: >
			:execute '/' .. histget("search", -2)

<		|:history|によって出力される{num}番目のエントリを、再度実行す
		るための ":H {num}" というコマンドを定義する。 >
			:command -nargs=1 H execute histget("cmd",0+<args>)
<
		|method| としても使用できる: >
			GetHistory()->histget()

histnr({history})					*histnr()*
		結果は数値で{history}の現在のエントリ数。{history}の部分に可能
		な値は|hist-names|を参照。エラーが起こった場合、-1が返される。

		例: >
			:let inp_index = histnr("expr")

<		|method| としても使用できる: >
			GetHistory()->histnr()
<
hlexists({name})					*hlexists()*
		結果は数値で、{name}という名のハイライトグループが存在すれば、
		真が返される。これはなんらかの方法でそのグループが既に定義され
		ている時にのみ起こる。これの為に実際に何らかのハイライティング
		アイテムが設定されている必要はなく、単に構文アイテムとしても使
		われるだろう。
							*highlight_exists()*
		以前の名前: highlight_exists().

		|method| としても使用できる: >
			GetName()->hlexists()
<
hlget([{name} [, {resolve}]])				*hlget()*
		ハイライトグループの全属性のリストを返す。省略可能な引数 {name}
		を指定したときは、指定したハイライトグループの属性だけのリスト
		を返す。ハイライトグループの {name} が無いときは空のリストを返
		す。

		省略可能な引数 {resolve} が v:true に設定され、ハイライトグルー
		プの {name} が他のグループにリンクしているなら、リンクを再帰的
		に解決して解決したハイライトグループの属性を返す。

		返されるリストの各要素は、以下を含む辞書になる:
			cleared	真偽値フラグ、ハイライトグループがクリアされて
				いたら v:true に設定され設定があればそうではな
				い。|highlight-clear| を参照
			cterm	cterm 属性。|highlight-cterm| を参照。
			ctermbg	cterm の背景色。|highlight-ctermbg| を参照。
			ctermfg	cterm の前面色。|highlight-ctermfg| を参照。
			ctermul	cterm の下線色。|highlight-ctermul| を参照。
			default 真偽値フラグ、ハイライトグループのリンクがデ
				フォルトへのリンクだと v:true。
				|highlight-default| を参照。
			font	ハイライトグループのフォント。
				|highlight-font| を参照。
			gui	gui 属性。|highlight-gui| を参照。
			guibg	gui の背景色。|highlight-guibg| を参照。
			guifg	gui の前面色。|highlight-guifg| を参照。
			guisp	gui の特殊色。|highlight-guisp| を参照。
			id	ハイライトグループの ID。
			linksto	リンクしているハイライトグループ名。
				|:highlight-link| を参照。
			name	ハイライトグループ名。|group-name| を参照。
			start	ターミナルの開始コード。|highlight-start| を参
				照。
			stop	ターミナルの終了コード。|highlight-stop| を参
				照。
			term	term 属性。|highlight-term| を参照。

		上記の辞書の要素 'term', 'cterm', 'gui' の値は以下の省略可能な
		真偽値の要素を持つ辞書: 'bold', 'standout', 'underline',
		'undercurl', 'italic', 'reverse', 'inverse', 'strikethrough'。

		例: >
			:echo hlget()
			:echo hlget('ModeMsg')
			:echo hlget('Number', v:true)
<
		|method| としても使用できる: >
			GetName()->hlget()
<
hlset({list})						*hlset()*
		ハイライトグループのリストの属性を作成もしくは変更する。{list}
		の各要素はハイライトグループの属性を持つ辞書。この辞書内でサ
		ポートされる要素のリストは |hlget()| を参照。

		|hlget()| で説明されている要素に追加して、以下の追加の要素が辞
		書内でサポートされる:

			force		既存の属性のあるハイライトグループへの
					リンクを強制的に作成する真偽値。

		ハイライトグループは 'name' 要素によって識別され、'id' 要素
		(提供されていれば) は無視される。ハイライトグループの指定した
		名前が存在しない場合は、作成される。そうでなければ既存のハイラ
		イトグループの属性を変更する。

		'term', 'cterm', 'gui' の項については空の辞書が値として使え、
		一致する属性の値をクリアする。'cleared' 要素に v:true を設定し
		た場合、ハイライトグループのすべての属性をクリアする。

		'linksto' 要素はハイライトグループを他のハイライトグループへリ
		ンクさせることができる、|:highlight-link| を参照。

		成功で0を返し、失敗で-1を返す。

		例: >
			" Visual ハイライトグループに太字属性を追加する
			:call hlset([#{name: 'Visual',
					\ term: #{reverse: 1 , bold: 1}}])
			:call hlset([#{name: 'Type', guifg: 'DarkGreen'}])
			:let l = hlget()
			:call hlset(l)
			" Search ハイライトグループをクリアする
			:call hlset([#{name: 'Search', cleared: v:true}])
			" ハイライトグループの 'term' 属性をクリアする
			:call hlset([#{name: 'Title', term: {}}])
			" DiffAdd にリンクした MyHlg グループを作る
			:call hlset([#{name: 'MyHlg', linksto: 'DiffAdd'}])
			" MyHlg グループのリンクを削除する
			:call hlset([#{name: 'MyHlg', linksto: 'NONE'}])
			" 属性とリンクをクリアする
			:call hlset([#{name: 'MyHlg', cleared: v:true,
					\ linksto: 'NONE'}])
<
		 |method| としても使用できる: >
			GetAttrList()->hlset()
<
							*hlID()*
hlID({name})	結果は数値で、{name}という名前のハイライトグループのID番号。そ
		のハイライトグループが存在しない場合は0が返される。
		これはハイライトグループについての情報を獲得するために使用され
		る。例えば "Comment" グループの背景色を取得するにはこのように
		する: >
	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
<							*highlightID()*
		以前の名前: highlightID()

		|method| としても使用できる: >
			GetName()->hlID()

hostname()						*hostname()*
		結果は文字列で、現在Vimが実行されているマシンの名前。名前が256
		文字を超える場合、超えた部分は切り捨てられる。

iconv({string}, {from}, {to})				*iconv()*
		文字列{string}をエンコーディング{from}からエンコーディング{to}
		に変換した文字列を返す。
		変換が完全に失敗したときは空文字列を返す。一部の文字が変換でき
		なかった場合、その文字は "?" に置き換わる。
		エンコーディング名はライブラリ関数iconv()が受け付けるものなら
		なんでもよい。":!man 3 iconv" を参照。
		ほとんどの変換は、Vimが|+iconv|機能つきでコンパイルされている
		ときのみ利用可能。|+iconv|つきでないときもUTF-8からlatin1への
		変換とその逆は行える。
		オプション 'encoding' の値に関係なく、特殊な文字を含むメッセー
		ジを表示するために使える。UTF-8でエンコードされたメッセージを
		表示するには次のようにする: >
			echo iconv(utf8_str, "utf-8", &enc)
<		Note Vimは全てのUnicodeエンコーディングに対してUTF-8を使う。
		UCS-2との変換を行おうとしても、自動的にUTF-8との変換に変更され
		る。いずれにせよ、UCS-2はNULバイトを含むため、文字列にUCS-2を
		使うことはできない。

		|method| としても使用できる: >
			GetText()->iconv('latin1', 'utf-8')
<
							*indent()*
indent({lnum})	カレントバッファの{lnum}行目のインデント量を数値で返す。この
		インデント量はスペース単位で数えられ、'tabstop' の値が関係する。
		{lnum}は|getline()|の場合と同様に扱われる。
		{lnum}が無効なときは-1を返す。|Vim9| script ではエラーになる。

		|method| としても使用できる: >
			GetLnum()->indent()

index({object}, {expr} [, {start} [, {ic}]])			*index()*
		{object} から {expr} を探し、そのインデックスを返す。ラムダを
		使って項目を選択する方法については |indexof()| を参照。

		{object}が |List| の場合は、{expr}に等しい要素の最小のインデッ
		クスを返す。自動的な変換は行われないので、文字列の "4" は数値
		の 4 とは異なると判定される。そして数値の 4 は浮動小数点数の
		4.0 とも異なる。'ignorecase' の値はここでは使用されない。大文
		字・小文字は引数 {ic} で示されているように区別される。

		{object}が |Blob| の場合は、{expr}に等しいバイト値の最小のイン
		デックスを返す。

		{start}が指定された場合はインデックス{start}から要素の検索を始
		める(負数を指定すると末尾からの相対位置となる)。

		{ic}に|TRUE|が指定された場合、大文字・小文字は区別されない。
		そうでない場合は区別される。

		{object}の中に{expr}が見つからない場合は-1を返す。
		例: >
			:let idx = index(words, "the")
			:if index(numbers, 123) >= 0

<		|method| としても使用できる: >
			GetObject()->index(what)

indexof({object}, {expr} [, {opts}])			*indexof()*
		{expr} が v:true である {object} 内の項目のインデックスを返す。
		{object} は |List| または |Blob| でなければならない。

		{object} が |List| の場合、式が v:true になるまでリスト内の各
		項目で {expr} を評価し、この項目のインデックスを返す。

		{object} が |Blob| の場合、式が v:true になるまで Blob 内の各
		バイトで {expr} を評価し、このバイトのインデックスを返す。

		{expr} は |string| または |Funcref| でなければならない。

		{expr} が |string| の場合: {object} が |List| であれば、{expr}
		の内部では |v:key| は現在のリスト項目のインデックスを持ち、
		|v:val| はその項目の値を持つ。{object} が |Blob| の場合、{expr}
		の内部では |v:key| は現在のバイトのインデックスを持ち、|v:val|
		は項目の値を持つ。

		{expr} が |Funcref| の場合は引数を 2 つ取らなければならない:
			1. 現在の項目のキーまたはインデックス。
			2. 現在の項目の値。
		この関数は、項目が見つかれば |TRUE| を返し、検索を停止しなけれ
		ばならない。

		オプションの引数 {opts} は辞書で、以下の項目をサポートしている:
		    startidx	このインデックスの項目から {expr} の評価を開
				始する。末尾に相対する項目は負であってもよい。
		すべての項目で {expr} が v:false と評価されたときに -1 を返す。
		例: >
			:let l = [#{n: 10}, #{n: 20}, #{n: 30}]
			:echo indexof(l, "v:val.n == 20")
			:echo indexof(l, {i, v -> v.n == 30})
			:echo indexof(l, "v:val.n == 20", #{startidx: 1})

<		|method| としても使用できる: >
			mylist->indexof(expr)

input({prompt} [, {text} [, {completion}]])		*input()*
		結果は文字列で、ユーザーがコマンドラインに入力したものが返され
		る。引数 {prompt} にはプロンプト文字列か空文字列を指定する。空
		文字列の場合はプロンプトなしになる。'\n' を使ってプロンプトに
		改行を含めることができる。
		|:echohl|によるハイライトの設定がプロンプトに適用される。
		入力はコマンドラインと同様に行え、同じ編集コマンドやキーマップ
		が使用できる。input()に入力された文字列には、他の履歴とは独立
		した履歴が与えられる。
		例: >
			:if input("Coffee or beer? ") == "beer"
			:  echo "Cheers!"
			:endif
<
		省略可能な引数{text}が与えられ、空でないならば、それが入力の初
		期値として、ユーザーが入力したのと同じ様に表示される。例: >
			:let color = input("Color? ", "white")

<		省略可能な引数{completion}はこの入力において利用できる補完の種
		類を指定する。この引数がないときは補完は行われない。対応してい
		る補完の種類は、ユーザー定義コマンドにおいて引数 "-complete="
		で指定するものと同じである。詳しくは|:command-completion|を参
		照。
		例: >
			let fname = input("File: ", "", "file")
<
		NOTE: この関数はGUIモードしか持たないバージョン(例、Win32 GUI)
		のVimでは、スタートアップファイルの中で使用することはできな
		い。
		NOTE: マッピングの中からinput()を呼ぶと、そのマッピングの残り
		の文字が消費される。マッピングは、その文字が入力されたときと同
		じように処理されるためである。
		これを避けるには、input()の前に|inputsave()|を呼び、input()の
		後に|inputrestore()|を呼ぶ。もう1つの対策は、|:execute|や
		|:normal|を使うなどして、そのマッピングでそれ以上文字を続けな
		いようにすることである。

		マッピングと同時に使う例: >
			:nmap \x :call GetFoo()<CR>:exe "/" .. Foo<CR>
			:function GetFoo()
			:  call inputsave()
			:  let g:Foo = input("enter search pattern: ")
			:  call inputrestore()
			:endfunction

<		|method| としても使用できる: >
			GetPrompt()->input()

inputdialog({prompt} [, {text} [, {cancelreturn}]])		*inputdialog()*
		|input()|と同様。GUIで動作していて、テキストダイアログがサポー
		トされている場合はダイアログを表示してテキストを入力させる。
		例: >
		   :let n = inputdialog("value for shiftwidth", shiftwidth())
		   :if n != ""
		   :  let &sw = n
		   :endif
<		ダイアログがキャンセルされたときは{cancelreturn}を返す。
		{cancelreturn}が省略されているときは空文字列を返す。
		<Enter>を押すとOKボタンを押すのと同じ動作になる。<Esc>を押すと
		キャンセルボタンを押すのと同じ動作になる。
		NOTE: コマンドライン補完は対応していない。

		|method| としても使用できる: >
			GetPrompt()->inputdialog()

inputlist({textlist})					*inputlist()*
		{textlist}は文字列のリスト|List|でなければならない。1行につき
		リストの要素を1個表示し、ユーザーに数字を入力するよう促す。入
		力された数字を返す。
		ユーザーは、もしマウスがコマンドラインで有効なら ('mouse' が
		"a" であるか "c" を含む)、マウスで文字列をクリックすることでも
		選択できる。最初の文字列を選択すると0が返る。最初の文字列より
		上をクリックすると負数が返る。プロンプト自身をクリックすると
		{textlist}の長さ+1 が返る。
		{textlist}の要素数はオプション 'lines' の値より少なくなければ
		ならない。そうでないと動作しない。最初の要素にメッセージを書
		き、各文字列の先頭に番号をつけておくとよい。
		例: >
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])

<		|method| としても使用できる: >
			GetChoices()->inputlist()

inputrestore()						*inputrestore()*
		前回の|inputsave()|で保存しておいた先行入力を復元する。
		inputsave()と同じ回数だけ呼ぶようにしなければならない。しかし
		多く呼びすぎても害はない。復元するものがなければ真を、そうでな
		ければ偽を返す。

inputsave()						*inputsave()*
		先行入力(マッピングにより入力された文字も含む)を保存し、クリア
		することにより、これ以降のプロンプトがユーザーからの入力を得る
		ようにする。プロンプトの後で、対応するinputrestore()を呼び出さ
		ねばならない。複数回呼ぶこともできる。ただしその場合は同じ回数
		だけinputrestore()を呼ばなくてはならない。
		メモリ不足のときは真を、そうでなければ偽を返す。

inputsecret({prompt} [, {text}])			*inputsecret()*
		|input()|とほぼ同じだが、以下の2点が異なる:
		a) ユーザーの入力をアスタリスク("*")の列として表示し、入力内容
		を読めないようにする。
		b) ユーザーの入力が入力履歴|history|に残らない。
		ユーザーの入力内容を文字列として返す。
		NOTE: コマンドライン補完には対応していない。

		|method| としても使用できる: >
			GetPrompt()->inputsecret()

insert({object}, {item} [, {idx}])			*insert()*
		{object}が |List| か |Blob| の場合、それの先頭に{item}を挿入す
		る。

		{idx}が指定されたときはインデックス{idx}の要素の前に{item}を挿
		入する。{idx}が0のときは{idx}を省略した場合と同じ様に最初の要
		素の前に挿入する。{idx}は負数でもよい(|list-index|参照)。-1を
		指定すると最後の要素の前に挿入する。

		挿入した結果の |List| か |Blob| を返す。例: >
			:let mylist = insert([2, 3, 5], 1)
			:call insert(mylist, 4, -1)
			:call insert(mylist, 6, len(mylist))
<		最後の例は|add()|を使うともっと簡単に書ける。
		Note {item}がリストの場合は、1個の要素として追加される。リスト
		を連結するには|extend()|を使うこと。

		|method| としても使用できる: >
			mylist->insert(item)
<
					*instanceof()* *E614* *E616* *E693*
instanceof({object}, {class})
		結果は数値で、{object} 引数が {class} で指定された |Class|,
		|Interface|, または、クラスの |:type| エイリアスの直接または間
		接インスタンスである場合に |TRUE| となる。
		{class} が可変長引数の場合、{object} が指定されたクラスのいず
		れかのインスタンスであるとき、この関数は |TRUE| を返す。
		例: >
			instanceof(animal, Dog, Cat)

<		|method| としても使用できる: >
			myobj->instanceof(mytype)

interrupt()						*interrupt()*
		スクリプトの実行を中断する。これは多かれ少なかれ、ユーザーが
		CTRL-C をタイプしたように動作する。多くのコマンドが実行されず、
		制御がユーザーに戻される。これは、自動コマンドの中など下位から
		実行を中断するのに有用である。例: >
		:function s:check_typoname(file)
		:   if fnamemodify(a:file, ':t') == '['
		:       echomsg 'Maybe typo'
		:       call interrupt()
		:   endif
		:endfunction
		:au BufWritePre * call s:check_typoname(expand('<amatch>'))

invert({expr})						*invert()*
		ビット反転。引数は数値に変換される。リスト、辞書、浮動小数点数
		を指定するとエラーになる。例: >
			:let bits = invert(bits)
<		|method| としても使用できる: >
			:let bits = bits->invert()

isabsolutepath({path})					*isabsolutepath()*
		結果は数値で、{path} が絶対パスであれば |TRUE| となる。
		Unix では、'/' から開始するパスが絶対パスと考えられる。
		MS-Windows では、ドライブのプリフィックスから開始し '\' か '/'
		が続くパスが絶対パスと考えられる。UNC パスは常に絶対パスであ
		る。
		例: >
			echo isabsolutepath('/usr/share/')	" 1
			echo isabsolutepath('./foobar')		" 0
			echo isabsolutepath('C:\Windows')	" 1
			echo isabsolutepath('foobar')		" 0
			echo isabsolutepath('\\remote\file')	" 1
<
		|method| としても使用できる: >
			GetName()->isabsolutepath()


isdirectory({directory})				*isdirectory()*
		結果は数値で、{directory}という名前のディレクトリが存在すれば
		|TRUE|となる。{directory}が存在しないか、存在したとしても
		ディレクトリではなかった場合には、|FALSE|が返される。文字列と
		して解釈できるのならば{directory}の表現はどのようなもので
		あってもかまわない。

		|method| としても使用できる: >
			GetName()->isdirectory()

isinf({expr})						*isinf()*
		{expr}が正の無限大の場合は1、負の無限大の場合は-1を返し、それ
		以外の場合は0を返す。 >
			:echo isinf(1.0 / 0.0)
<			1 >
			:echo isinf(-1.0 / 0.0)
<			-1

		|method| としても使用できる: >
			Compute()->isinf()

islocked({expr})					*islocked()* *E786*
		結果は数値で、{expr} がロックされている変数の名前ならば|TRUE|
		を返す。
		文字列の引数 {expr} は変数の名前、リスト |List| の要素、辞書
		|Dictionary| の要素のいずれかでなければならない。変数そのもの
		を指定しないように注意。
		例: >
			:let alist = [0, ['a', 'b'], 2, 3]
			:lockvar 1 alist
			:echo islocked('alist')		" 1
			:echo islocked('alist[1]')	" 0

<		{expr} が存在しない変数のときは-1を返す。
		{expr} が範囲のある、リストか辞書でインデックスが範囲外か要素
		が存在しないならエラーメッセージが表示される。変数の存在を確認
		するには |exists()| を使う。
		Vim9 script ではローカル関数変数に対しては動作しない。

		|method| としても使用できる: >
			GetName()->islocked()

isnan({expr})						*isnan()*
		{expr} が NaN の値を持つ浮動小数点数ならば |TRUE| を返す。 >
			echo isnan(0.0 / 0.0)
<			1

		|method| としても使用できる: >
			Compute()->isnan()

items({dict})						*items()*
		{dict}の全要素のキー・値のペアからなるリストを返す。戻り値の各
		要素はリストであり、キーと値の2個の要素を持つ。戻り値のリスト
		の要素の順序は不定である。|keys()| と |values()| も参照。
		例: >
			for [key, value] in items(mydict)
			   echo key .. ': ' .. value
			endfor
<
		リストまたは文字列引数もサポートされている。このようなケースで
		は、items() はインデックスとインデックスの値を含むリストを返
		す。

		|method| としても使用できる: >
			mydict->items()

job_ 関数群はここに文書化されている: |job-functions-details|

join({list} [, {sep}])					*join()*
		リスト{list}の要素を連結し、1個の文字列にして返す。
		{sep}が指定されたときは、要素の間にそれを挿入する。{sep}が指定
		されなかったときは1個のスペースが使われる。
		Note 末尾には{sep}がつかない。末尾にもつけたければ以下のように
		する: >
			let lines = join(mylist, "\n") .. "\n"
<		{list}の要素が文字列なら、そのまま使われる。リストと辞書は
		|string()|を使ったときと同じようにして文字列に変換される。
		この逆を行う関数は|split()|である。

		|method| としても使用できる: >
			mylist->join()

js_decode({string})					*js_decode()*
		|json_decode()| に似ているが以下が異なる:
		- オブジェクトのキー名はクォートされてなくてもよい。
		- 文字列はシングルクォートでくくることができる。
		- 配列内の(2つのコンマで区切られた)空アイテムが許可され結果と
		  して v:none のアイテムとなる。

		|method| としても使用できる: >
			ReadObject()->js_decode()

js_encode({expr})					*js_encode()*
		|json_encode()| に似ているが以下が異なる:
		- オブジェクトのキー名がクォートされない
		- 配列の中のアイテム v:none はコンマで区切られた空のアイテムに
		  なる。
		例えば Vim オブジェクト:
			[1,v:none,{"one":1},v:none] ~
		は以下にエンコードされ:
			[1,,{one:1},,] ~
		json_encode() であれば以下にエンコードされる:
			[1,null,{"one":1},null] ~
		このエンコードは JavaScript では妥当である。特に配列内でオプ
		ショナルアイテムを扱う場合には JSON より能率的である。

		|method| としても使用できる: >
			GetObject()->js_encode()

json_decode({string})				*json_decode()* *E491*
		これはJSONフォーマットの文字列を解析し、それと同等のVimの値を
		返す。JSONとVimの値の関係は|json_encode()|を参照。
		デコードは寛容である:
		- 配列やオブジェクトの末尾コンマは無視される、例えば
		  "[1, 2, ]" と "[1, 2]" は同じである。
		- 整数のキーはオブジェクト内で受け入れられる。例えば、{1:2} は
		  {"1":2} と同じである。
		- 多くの浮動小数点数を認識する。例えば "1." は "1.0" となり、
		  "001.2" は "1.2" となる。特別な浮動小数点の値、"Infinity",
		  "-Infinity" および "NaN" (大文字は無視される) は受け付けられ
		  る。
		- 整数値の先頭に付く 0 は無視される、例えば "012" は "12" とな
		  り、"-012" は "-12" となる。
		- null、true および false の大文字は無視される、例えば "NULL"
		  は "null" となり、"True" は "true" となる。
		- 文字列中でエスケープされない U+0000 から U+001F の制御文字は
		  受け付けられる、例えば "	" (文字列中のタブ文字) は "\t"
		  となる。
		- 空のJSON式、またはスペースのみで構成されているものは受け入れ
		  られ、v:none になる。
		- 無効な 2 文字のシーケンスエスケープ中のバックスラッシュは無
		  視される、例えば "\a" は "a" と解釈される。
		- JSON 文字列中の正しいサロゲートペアは、通常 "\uD834\uDD1E"
		  のような連続した 12 文字でなければならないが、json_decode()
		  は、"\uD834" や "\uD834\u" のような途切れたサロゲートペアを
		  黙って受け付ける。
								*E938*
		結果は Vim の有効な型でなければならないため、rfc7159 では有効
		なオブジェクト内の重複キーは、json_decode() では受け付けられな
		い、例えばこれは失敗する: {"a":"b", "a":"c"}

		|method| としても使用できる: >
			ReadObject()->json_decode()

json_encode({expr})					*json_encode()*
		{expr}をJSONフォーマットの文字列にエンコードし、この文字列を返
		す。
		このエンコード方式の詳細はここに記載されている:
		https://tools.ietf.org/html/rfc7159.html
		Vimの値は以下の通りに変換される: *E1161*
		   数値 |Number|	10進数
		   浮動小数点数 |Float|	浮動小数点数
		   浮動小数点数 nan	"NaN"
		   浮動小数点数 inf	"Infinity"
		   浮動小数点数 -inf	"-Infinity"
		   文字列 |String|	ダブルクォートで括られた文字列(null可)
		   |Funcref|		不可、エラー
		   リスト |List|	配列(null可)
					再帰的に使用された場合: []
		   辞書 |Dict|		オブジェクト(null可)
					再帰的に使用された場合: {}
		   |Blob|		個々のバイト配列
		   v:false		"false"
		   v:true		"true"
		   v:none		"null"
		   v:null		"null"
		NaNとInfinityは値として渡されることに注意すること。これはJSON
		標準には存在しないが、いくつかの実装でそれが可能である。そうで
		ない場合、エラーが発生する。
		非対応の文字を含む文字列の場合、0xfffd を使って文字が置換され
		る。

		|method| としても使用できる: >
			GetObject()->json_encode()

keys({dict})						*keys()*
		{dict}の全キーからなるリスト |List| を返す。リストの順序は不定
		である。|items()| と |values()| も参照。

		|method| としても使用できる: >
			mydict->keys()

keytrans({string})					*keytrans()*
		キーの内部バイト表現を |:map| に使用できる形式に変換する。例: >
			:let xx = "\<C-Home>"
			:echo keytrans(xx)
<			<C-Home>

		|method| としても使用できる: >
			"\<C-Home>"->keytrans()

<							*len()* *E701*
len({expr})	結果は数値で、引数{expr}の長さ。{expr}が文字列または数値のとき
		は|strlen()|と同じようにバイト単位での長さを返す。
		{expr}がリスト |List| のときは要素数を返す。
		{expr}が |Blob| の場合、バイト数を返す。
		{expr}が辞書 |Dictionary| のときは要素数を返す。
		{expr}が |Object| のときは、オブジェクトの len() メソッドを
		(存在する場合) 呼び出して長さを取得する (|object-len()|)。それ
		以外のときはゼロを返す。

		|method| としても使用できる: >
			mylist->len()

<						*libcall()* *E364* *E368*
libcall({libname}, {funcname}, {argument})
		ランタイムライブラリ{libname}の関数{funcname}を、単一の引数
		{argument}で呼び出す。
		Vimで使うように特別に作ったライブラリの関数を呼ぶために使われ
		る。引数は1個しか指定できないため、普通のライブラリ関数を呼ぶ
		にはかなり制限がある。
		結果には、呼び出した関数から返された文字列が返される。呼び出し
		た関数がNULLを返した場合には、Vimには空文字列 "" が戻される。
		関数の戻り値が数値である場合には|libcallnr()|を使うこと。
		もしも引数が数値ならば、関数にはint型の引数が1つ渡される。引数
		が文字列の場合には、関数にはヌル終端記号を持つ文字列が引数とし
		て渡される。
		|restricted-mode|の中で呼ぶと失敗する。

		libcall()によってVimを再コンパイルすることなく 'plug-in' と呼
		ばれる独自の拡張を行うことができるようになる。それは (直接) シ
		ステムの関数を呼ぶ、ということではない。システム関数を呼ぶとお
		そらくVimがクラッシュするだろう。

		Win32では、あなたが書いた関数をDLLに置かなければならず、また通
		常のC呼出し規約を使用しなければならない(WindowsのシステムDLLが
		使うPascalではない)。関数は正確に1つのパラメーター、char型ポイ
		ンタもしくはint型を取らなければならず、戻り値としてchar型ポイ
		ンタかNULLを返さなければならない。返されるchar型ポインタは、関
		数終了後も有効なポインタ(例えばDLL内の静的なデータ)を指さなけ
		ればならない。(malloc等で)割り当てられたメモリを保持していた場
		合、それはリークしてしまう。DLL内のスタティックバッファを用い
		る方法は動くかもしれないが、使用済みDLLがメモリから削除される
		と同時に解放されてしまう。

		警告: もしも関数が有効ではないポインタを返すと、Vimはクラッ
		シュしてしまう。関数が数値を返してしまった場合、Vimはそれをポ
		インタとして扱ってしまうので、やはりクラッシュが起こる。
		Win32のシステムでは、{libname}はDLLのファイル名の拡張子 ".DLL"
		を付けてはならない。通常の(パスの通った)場所にDLLがない場合に
		は、フルパスで指定する必要がある。
		Unixでは、独自のプラグインをコンパイルするときはオブジェクト
		コードを位置独立('PIC')としてコンパイルしなければならない。
		{Win32 といくつかの Unix で、|+libcall| 機能が有効になっている
		ときのみ利用可能}
		例: >
			:echo libcall("libc.so", "getenv", "HOME")

<		|method| としても使用でき、ベースは第3引数として渡される: >
			GetValue()->libcall("libc.so", "getenv")
<
							*libcallnr()*
libcallnr({libname}, {funcname}, {argument})
		|libcall()|とほぼ同様だが、文字列でなくintを返す関数に使う。
		{Win32と、|+libcall|機能が有効になっているUnixでのみ利用可能}
		例: >
			:echo libcallnr("/usr/lib/libc.so", "getpid", "")
			:call libcallnr("libc.so", "printf", "Hello World!\n")
			:call libcallnr("libc.so", "sleep", 10)
<
		|method| としても使用でき、ベースは第3引数として渡される: >
			GetValue()->libcallnr("libc.so", "printf")
<

line({expr} [, {winid}])				*line()*
		結果は数値で、{expr}で与えられた位置のファイル内での行番号。引
		数 {expr} は文字列。受け付けられる位置指定は次の通り:	*E1209*
		    .	    カーソルの位置
		    $	    現在のバッファの最後の行
		    'x	    マークxの位置(マークが設定されていない場合、0が返
			    る)
		    w0	    カレントウィンドウの最上行 (サイレント Ex モードの
			    ように、画面が更新されない場合は 1)
		    w$	    カレントウィンドウの最下行 (行が表示されていない場
			    合は "w0" より 1 小さい)
		    v	    ビジュアルモードでは: ビジュアル選択領域の開始位置
			    (カーソルが終了位置)。ビジュアルモード以外ではカー
			    ソル位置を返す。すぐに更新される点が |'<| と違う。
		Note 他のファイルのマークも使える。その場合、戻り値はそのファ
		イルの行番号となる。
		桁番号を取得するには|col()|を使う。両方を取得するには
		|getpos()|を使う。
		オプションの {winid} 引数を使用すると、カレントウィンドウの代
		わりにそのウィンドウの値が取得される。
		{expr} と {winid} が無効な値の場合は 0 を返す。
		例: >
			line(".")		カーソルの行番号
			line(".", winid)	ウィンドウ "winid" で同上
			line("'t")		マークtの位置の行番号
			line("'" .. marker)	マークmarkerの位置の行番号
<
		ファイルを開くときに最後の既知の位置にジャンプするには、
		|last-position-jump| を参照。

		|method| としても使用できる: >
			GetValue()->line()

line2byte({lnum})					*line2byte()*
		バッファの先頭から、{lnum}行目までのバイト数を返す。これには現
		在のバッファのオプション 'fileformat' に従った、end-of-line(行
		終端)文字も含まれている。最初の行においては1が返る。バイト数は
		'encoding' に基づく。'fileencoding' は無視される。
		次のようにすることで最終行を含むバイトサイズを獲得することがで
		きる: >
			line2byte(line("$") + 1)
<		これはバッファの大きさプラス1になる。もし 'fileencoding' が空
		ならその値はファイルの大きさプラス1に等しい。{lnum} は
		|getline()| と同様に扱われる。{lnum} が無効であるか、
		|+byte_offset| 機能がコンパイル時に無効にされている場合、-1が
		返される。
		|byte2line()|、|go|及び|:goto|も参照。

		|method| としても使用できる: >
			GetLnum()->line2byte()

lispindent({lnum})					*lispindent()*
		'lisp' をオンにしたときと同じlisp用のインデント規則に従った場
		合の{lnum}行目のインデント量を返す。
		インデント量はスペースで数えられ、'tabstop' の値は関係ない。
		{lnum}は|getline()|の場合と同様に扱われる。
		{lnum} が無効な場合は -1 が返される。|Vim9| script ではエラー
		になる。

		|method| としても使用できる: >
			GetLnum()->lispindent()

list2blob({list})					*list2blob()*
		Return a Blob concatenating all the number values in {list}.
		{list} にある数値全てを連結したBlobを返す。
		例: >
			list2blob([1, 2, 3, 4])	returns 0z01020304
			list2blob([])		returns 0z
<		エラーの時は空のBlobを返す。1つ以上の数値が負数や255を越えてい
		るときは *E1239* エラーが発生する。

		|blob2list()| は反対のことをする。

		|method| としても使用できる: >
			GetList()->list2blob()

list2str({list} [, {utf8}])				*list2str()*
		{list}の各数値を文字列に変換し、それらすべてを連結する。例: >
			list2str([32])		returns " "
			list2str([65, 66, 67])	returns "ABC"
<		以下で同様のことが(遅く)おこなえる: >
			join(map(list, {nr, val -> nr2char(val)}), '')
<		|str2list()| は反対のことをする。

		{utf8}が省略されているかゼロの場合、現在の 'encoding'が使用さ
		れる。{utf8}が真の場合は、常にUTF-8文字列を返す。
		UTF-8の合成文字は期待通りに動作する: >
			list2str([97, 769])	returns "á"
<
		エラー時は空文字列を返す。

		|method| としても使用できる: >
			GetList()->list2str()

listener_add({callback} [, {buf}])			*listener_add()*
		バッファ {buf} に変更が加えられたときに呼び出されるコールバッ
		ク関数を追加する。
		{buf} はバッファ名またはバッファ番号を参照する。許容値について
		は、|bufname()| を参照。{buf}を省略すると、現在のバッファが使
		用される。
		|listener_remove()| に渡すことができる一意のIDを返す。

		{callback} は 5 つの引数で呼び出される:
		    bufnr	変更されたバッファ
		    start	最初に変更された行番号
		    end		変更された下の最初の行番号
		    added	追加された行数。行が削除された場合は負値
		    changes	変更についての詳細を含む項目のリスト

		例: >
	    func Listener(bufnr, start, end, added, changes)
	      echo 'lines ' .. a:start .. ' until ' .. a:end .. ' changed'
	    endfunc
	    call listener_add('Listener', bufnr)

<		リストは変更できない。"changes" の各項目は、次のエントリを持つ
		辞書である:
		    lnum	変更の最初の行番号
		    end		変更された行の下の行
		    added	追加された行数。行が削除された場合は負値
		    col		変更の影響を受けた "lnum" の最初の桁。不明な場
				合、または行全体が影響を受けた場合は 1。これは
				バイトインデックスである。最初の文字の値は 1
				である。
		行が挿入されたとき (挿入モードで CR を入力するなどして行が分割
		された場合は除く) の値は次のとおり:
		    lnum	上に新しい行が追加される行番号
		    end		"lnum" と同じ
		    added	挿入された行数
		    col		1
		行が削除されたときの値は次のとおり:
		    lnum	最初に削除された行番号
		    end		削除が行われる前の、最初に削除された行の下の行
		    added	負値。削除された行数
		    col		1
		行が変更されたときの値は次のとおり:
		    lnum	最初の変更行
		    end		最後に変更された行の下の行
		    added	0
		    col		変更した最初の桁または 1

		エントリは変更が行われた順になっているため、最新の変更は最後に
		なる。行番号はコールバックが呼び出されたときに有効だが、後の変
		更はそれらを無効にするかもしれない。したがって、後のためにコ
		ピーを保持しても機能しないかもしれない。

		{callback} は、|listener_flush()| が呼び出されたとき、または、
		行数を変更するような変更が行われ、変更リストの行番号が無効に
		なったときに、画面が更新される直前に呼び出される。

		{callback} はテキストをロックした状態で呼び出される。
		|textlock| を参照。バッファを変更する必要がある場合は、後でこ
		れを実行するためのタイマー |timer_start()| を使用すること。

		バッファが最初にロードされた時には {callback} は呼び出されな
		い。|BufReadPost| 自動コマンドイベントを使用して、バッファの初
		期テキストを処理する。
		{callback} はバッファがアンロードされたときにも呼び出されない。
		そのためには |BufUnload| 自動コマンドイベントを使用すること。

		{callback} または {buf} が無効な場合はゼロを返す。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetBuffer()->listener_add(callback)

listener_flush([{buf}])					*listener_flush()*
		バッファ {buf} のリスナーコールバックを呼び出す。保留中の変更
		がない場合は、コールバックは呼び出されない。

		{buf} はバッファ名またはバッファ番号を表す。許容値については、
		|bufname()| を参照。{buf} を省略すると、カレントバッファが使用
		される。

		|method| としても使用できる: >
			GetBuffer()->listener_flush()

listener_remove({id})					*listener_remove()*
		以前に listener_add() で追加されたリスナーを削除する。
		{id} が見つからなかった場合は偽、{id} が削除された場合は真を返
		す。

		|method| としても使用できる: >
			GetListenerId()->listener_remove()

localtime()						*localtime()*
		現在の時刻、1970年1月1日からの経過秒数を返す。|strftime()|,
		|strptime()| と |getftime()| も参照。


log({expr})						*log()*
		{expr} の自然対数 (底e) を浮動小数点数 (|Float|) で返す。
		{expr} は (0, inf] の範囲の浮動小数点数 (|Float|) か数値
		(|Number|) でなければならない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo log(10)
<			2.302585 >
			:echo log(exp(5))
<			5.0

		|method| としても使用できる: >
			Compute()->log()


log10({expr})						*log10()*
		浮動小数点数 {expr} の 10 を底とする対数を |Float| で返す。
		{expr} は |Float| または |Number| に評価されなければならな
		い。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo log10(1000)
<			3.0 >
			:echo log10(0.01)
<			-2.0

		|method| としても使用できる: >
			Compute()->log10()

luaeval({expr} [, {expr}])					*luaeval()*
		Lua の式 {expr} を評価し、その結果を Vim のデータ構造に変換し
		たものを返す。2番目の {expr} は、最初の {expr} の中では _A と
		してアクセスできる追加の引数を保持する。
		文字列はそのまま返される。
		ブーリアンオブジェクトは数値に変換される。
		数値は、|Float| 値に変換される。
		vim.eval() で取得される辞書とリストはそのまま返される。
		それ以外のオブジェクトは 0 が返され、エラーにはならない。
		詳細は |lua-luaeval| を参照。
		Note `:def` 関数にあるローカル変数は {expr} からは見えない。

		|method| としても使用できる: >
			GetExpr()->luaeval()

<		{|+lua| 機能つきでコンパイルされたときのみ有効}

map({expr1}, {expr2})					*map()*
		{expr1} はリスト |List|、文字列 |String|、|Blob|または辞書
		|Dictionary|。
		{expr1}がリスト|List| もしくは 辞書|Dictionary| なら、{expr1}
		の各要素を、{expr2}を評価した結果で置き換える。
		|Blob| の場合、各バイトを置き換える。
		文字列 |String| の場合、合成文字を含む各文字を置き換える。
		要素の型を変更したい場合は、|mapnew()| を使って新しいリストか
		辞書を作る。これは、Vim9 script を使用する場合に必要である。

		{expr2}は文字列|String|または関数参照|Funcref|でなければならな
		い。

		{expr2}が文字列 |String| の場合、{expr2}の内部では|v:val|が現
		在の要素の値を保持している。辞書の場合は|v:key|が現在の要素の
		キーを保持している。リストの場合は|v:key|が現在の要素のインデッ
		クスを保持している。|Blob| の場合は |v:key| が現在のバイトのイ
		ンデックスを保持している。
		例: >
			:call map(mylist, '"> " .. v:val .. " <"')
<		これは "mylist" の各要素の前に "> " をつけ、後に " <" をつける。
		Note {expr2}は式を表す文字列である。バックスラッシュを二重に
		しなくても済むように|literal-string|を使うとよいだろう。ただし
		その場合はシングルクォートを二重にしなければならない。

		{expr2}が|Funcref|の場合は、2つの引数で呼び出される:
			1. 現在の要素のキーまたはインデックス。
			2. 現在の要素の値。
		旧来のスクリプトのラムダでは引数を 1 つだけ受け入れてもエラー
		は発生しないが、Vim9 ラムダでは "E1106: One argument too many"
		というメッセージが表示され、引数の数は一致する必要がある。

		関数は、その要素の新しい値を返さなければならない。それぞれの値
		を "key-value" に置き換える例: >
			func KeyValue(key, val)
			  return a:key .. '-' .. a:val
			endfunc
			call map(myDict, function('KeyValue'))
<		|lambda| を使えばより短く書ける: >
			call map(myDict, {key, val -> key .. '-' .. val})
<		"val" を使わない場合は省略できる: >
			call map(myDict, {key -> 'item: ' .. key})
<		"key" を使用しない場合は、短い名前が使用できる: >
			call map(myDict, {_, val -> 'item: ' .. val})
<
		この操作はリスト |List| と辞書 |Dictionary| の場合その場で
		(in-place)行われる。リストや辞書を変更したくない場合は最初にコ
		ピーを作ること: >
			:let tlist = map(copy(mylist), ' v:val .. "\t"')

<		{expr1}が式を適用した結果のリストまたは辞書、もしくは新規の
		|Blob| か文字列を返す。
		{expr2}を評価している最中にエラーが発生した場合は、{expr1}内の
		それ以降の要素の処理は行われない。
		{expr2}が関数参照の場合、関数が "abort" フラグつきで定義されて
		いない限り、関数内のエラーは無視される。

		|method| としても使用できる: >
			mylist->map(expr2)


maparg({name} [, {mode} [, {abbr} [, {dict}]]])			*maparg()*
		{dict}が省略されたかゼロのとき: モード{mode}におけるキーマップ
		{name}のrhsを返す。結果の文字列内の特殊文字は、":map" コマンド
		でリスト表示した時のように変換される。
		{dict} が TRUE の場合は辞書が返される。以下を参照。全マッピン
		グのリストを取得するのは |maplist()| を参照。

		{name} というキーマップが存在しない場合、{dict} が FALSE の場
		合は空文字列が返され、それ以外の場合は空の辞書が返される。
		{name} というキーマップが空の場合、"<Nop>" が返される。

		{name}には ":map" コマンドで使用可能な、特殊なキー名が指定でき
		る。

		{mode}には次の文字が使用可能:
			"n"	ノーマル
			"v"	ビジュアル (選択含む)
			"o"	オペレータ待機 (Operator-pending)
			"i"	挿入
			"c"	コマンドライン
			"s"	選択
			"x"	ビジュアル
			"l"	langmap |language-mapping|
			"t"	端末ジョブ
			""	ノーマル、ビジュアル、及びオペレータ待機
		{mode}が省略された場合、"" が使用される。

		{abbr}が指定され、|TRUE|の場合はマッピングでなく短縮入力を対象
		とする。

		{dict} に|TRUE|が指定されたときはマッピングのすべての情報を含
		んだ辞書が返る:				*mapping-dict*
		  "lhs"		マッピングの {lhs} (入力されたまま)
		  "lhsraw"	マッピングの {lhs} (生のバイト値)
		  "lhsrawalt"	マッピングの {lhs} (生のバイト値の代替形式、
				"lhsraw" と違う場合のみ存在)
		  "rhs"		マッピングの {rhs} (入力されたまま)
		  "silent"	|:map-silent| マッピングなら 1。そうでなければ
				0。
		  "noremap"	マッピングの {rhs} が再マップ可能でないなら 1。
		  "script"	マッピングが <script> でなされていたら 1。
		  "expr"	式マッピング (|:map-<expr>|) なら 1。
		  "buffer"	バッファローカルマッピング (|:map-local|) なら
				1。
		  "mode"	マッピングが定義されているモード。上述のモードに
				加え、次の文字が使用される:
				" "     ノーマル、ビジュアル、オペレータ待機
				"!"     挿入、コマンドラインモード
					(|mapmode-ic|)
		  "sid"		<sid> マッピングで使用されるスクリプトローカル
				ID (|<SID>|)。特殊なコンテキストの場合は負値。
		  "scriptversion"  スクリプトのバージョン番号。999999 は |Vim9|
				   script を表す。
		  "lnum"	"sid" 内の行番号。不明の場合はゼロ。
		  "nowait"	他の長いマッピングを待たない。
				(|:map-<nowait>|)。
		  "abbr"     これが短縮入力 |abbreviations| の場合は真。
		  "mode_bits" "mode" の Vim の内部バイナリ表現。|maplist()| は
			     これを無視する。"mode" のみが使用される。使用例に
			     ついては、|maplist()| を参照。値は src/vim.h から
			     のもので、将来変更される可能性がある。

		この辞書は |mapset()| でマッピングを復元するのに使える。

		まずカレントバッファにローカルなマッピングを探し、次のグローバ
		ルマッピングを探す。
		この関数を使うと、あるキーに対して既にマップがされているとき、
		その動作を行いつつ、再マップすることができる。概要: >
			exe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')

<		|method| としても使用できる: >
			GetKey()->maparg('n')

mapcheck({name} [, {mode} [, {abbr}]])			*mapcheck()*
		モード{mode}におけるキーマップ{name}が存在するかチェックする。
		{name}に指定できる特殊文字は|maparg()|を参照。
		{abbr}が指定され、|TRUE|の場合はマッピングでなく短縮入力を対象
		とする。
		マッピングが{name}で始まるとき、またはマッピングが{name}のはじ
		めに等しいときマッチすると見なされる。

			マッチするか    "a"     "ab"    "abc" ~
		   mapcheck("a")	yes	yes	 yes
		   mapcheck("abc")	yes	yes	 yes
		   mapcheck("ax")	yes	no	 no
		   mapcheck("b")	no	no	 no

		maparg()との違いは、mapcheck()は{name}にマッチするマップを見つ
		けるが、maparg()はぴったり{name}に一致するマッピングのみを見つ
		ける。
		{name}にマッチするキーマップが存在しない時には、空文字列が返さ
		れる。結果が一つならばマップされたRHSが返される。{name} で始ま
		るマッピングが複数見つかった場合には、それらのうちどれか一つの
		RHSが返される。RHS が空の場合は "<Nop>" となる。
		まずカレントバッファにローカルなマッピングを探し、次のグローバ
		ルマッピングを探す。
		この関数はマッピングが曖昧にならないかチェックするために使うこ
		とができる。例: >
	:if mapcheck("_vv") == ""
	:   map _vv :set guifont=7x13<CR>
	:endif
<		これは、"_vv" というマッピングが "_v" とか "_vvv" といったマッ
		ピングと衝突しないように事前にチェックしている。

		|method| としても使用できる: >
			GetKey()->mapcheck('n')


maplist([{abbr}])					*maplist()*
		全マッピングの |List| を返す。各リストの項目は |Dict| で、
		|maparg()| で返すものと同じになる。|mapping-dict| を参照。
		{abbr} が存在し |TRUE| であれば、マッピングの代わりに短縮入力
		を使う。

		'MultiMatch' が rhs に含まれる全マッピングを表示する例: >
			vim9script
			echo maplist()->filter(
				(_, m) => match(m.rhs, 'MultiMatch') >= 0)
<		特定の |:map-modes| のマッピングを見つけるのは難しい場合がある。
		|mapping-dict| の "mode_bits" を使用するとこれを簡素化できる。
		例えば、ノーマル、挿入、またはコマンドラインモードの mode_bits
		は 0x19 である。これらのモードで使用可能なすべてのマッピングを
		見つけるには、以下を実行できる: >
			vim9script
			var saved_maps = []
			for m in maplist()
			    if and(m.mode_bits, 0x19) != 0
				saved_maps->add(m)
			    endif
			endfor
			echo saved_maps->mapnew((_, m) => m.lhs)
<		mode_bits の値は Vim の src/vim.h ファイルで定義されており、
		|:map-commands| と "maplist()" を使って実行時に見つけることが
		できる。例: >
			vim9script
			omap xyzzy <Nop>
			var op_bit = maplist()->filter(
			    (_, m) => m.lhs == 'xyzzy')[0].mode_bits
			ounmap xyzzy
			echo printf("Operator-pending mode bit: 0x%x", op_bit)


mapnew({expr1}, {expr2})					*mapnew()*
		|map()| と同様だが、{expr1} の要素を置き換える代わりに、新しい
		リストまたは辞書が作成されて返される。{expr1} は変更されない。
		要素は引き続き {expr2} で変更できるが、そうしたくないなら最初
		に |deepcopy()| を利用すること。

mapset({mode}, {abbr}, {dict})					*mapset()*
mapset({dict})
		|maparg()| または |maplist()| によって返される可能性のある辞書
		からマッピングを復元する。dict.buffer が真の場合、バッファの
		マッピングはカレントバッファに設定される。意図したバッファがカ
		レントバッファであることを確認するのは呼び出し元の責任である。
		この機能を使用すると、あるバッファから別のバッファにマッピング
		をコピーできる。
		dict.mode 値は、'!'、' '、'nox'、'v' のモード値のように、複数
		のモードをカバーする 1 つのマッピングを復元することができる。
		*E1276*

		最初の形式では、{mode} と {abbr} は |maparg()| の呼び出しと同
		じである必要がある。 *E460*
		{mode} はマッピングをセットするモードを定義するのに使い、{dict}
		の "mode" エントリは使われない。
		マッピングの保存と復元の例: >
			let save_map = maparg('K', 'n', 0, 1)
			nnoremap K somethingelse
			...
			call mapset('n', 0, save_map)
<		Note いくつかのモードのマップを置き換えようとする場合の注意、
		例えば `:map!` とともに実施するとき、違いがある可能性があるの
		で、全部のマッピングを保存/復元する必要がある。

		2 番目の形式では、{dict} を唯一の引数として、mode と abbr が
		dict から取得される。
		例: >
			vim9script
			var save_maps = maplist()->filter(
						(_, m) => m.lhs == 'K')
			nnoremap K somethingelse
			cnoremap K somethingelse2
			# ...
			unmap K
			for d in save_maps
			    mapset(d)
			endfor


match({expr}, {pat} [, {start} [, {count}]])			*match()*
		{expr}がリストの場合は、{pat}にマッチする最初の要素のインデッ
		クスを返す。各要素は文字列として扱われる。リストと辞書はechoし
		たときと同じように文字列表現に変換される。

		それ以外の場合は、{expr}は文字列として扱われる。{expr}の中で
		{pat}にマッチするインデックス(バイト単位のオフセット)を表す数
		値を返す。

		最初の文字またはリストの最初の要素にマッチしたときは0を返す。
		マッチがないときは-1を返す。

		サブマッチを取得するには |matchlist()| を参照。
		例: >
			:echo match("testing", "ing")	" 結果は 4
			:echo match([1, 'x'], '\a')	" 結果は 1
<		{pat}の扱われ方については|string-match|を参照。
								*strpbrk()*
		strpbrk()に相当する関数はVimに存在しない。しかし同じことを次の
		ようにしてできる: >
			:let sepidx = match(line, '[.,;: \t]')
<								*strcasestr()*
		strcasestr()に相当する関数はVimに存在しない。しかし正規表現に
		"\c" をつければ大文字・小文字の違いを無視できる: >
			:let idx = match(haystack, '\cneedle')
<
		{start}が指定されたときは、文字列のバイトインデックス{start}の
		位置、またはリストの{start}の要素から検索を始める。
		その場合も戻り値は最初の文字/要素から数えたインデックスである
		ことに注意。例: >
			:echo match("testing", "ing", 2)
<		の結果は "4"。 >
			:echo match("testing", "ing", 4)
<		の結果は "4"。 >
			:echo match("testing", "t", 2)
<		の結果は "3"。
		文字列の場合、{start} > 0のときは、その文字列が{start}バイト後
		から始まるかのように扱われる。そのため、"^" は{start}の位置に
		マッチする。ただし{count}が指定されたときは、{start}より前にお
		けるマッチを無視しているかのように振る舞う(これは後方互換性を
		保つのを少々複雑にしている)。
		文字列の場合、{start} < 0のときは{start}に0をセットする。リス
		トの場合は、末尾からインデックスを数えるという意味になる。
		{start}が範囲外の場合(文字列で{start} > strlen({expr})となった
		場合、リストで{start} > len({expr})となった場合)は-1を返す。

		{count}が指定されたときは{count}番目のマッチ位置を返す。文字列
		でマッチが見つかったとき、次のマッチングは1文字先から行われる。
		よって次の例は1を返す: >
			echo match("testing", "..", 0, 2)
<		リストの場合は次の要素から検索を続ける。
		Note {count}を指定すると、{start}の扱い方が変わってしまう。
		前の段落を参照。

						*match-pattern*
		受け付ける正規表現については|pattern|を参照。
		オプション 'ignorecase' により、大文字・小文字を区別するかどう
		かを設定できる。'smartcase' は適用されない。マッチングは常に
		'magic' をオン、'cpoptions' を空にした状態で行われる。
		Note マッチの開始が一致することが望しく、パターンで "*" (任意
		の数のマッチ) を使う場合、テキストにある次のマッチ数ではなく、
		0になる傾向があるので注意。

		|method| としても使用できる: >
			GetText()->match('word')
			GetList()->match('word')
<
				*matchadd()* *E290* *E798* *E799* *E801* *E957*
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
		カレントウィンドウで強調表示するパターンを定義する。このパター
		ンのことを「マッチ」と呼ぶ。構文グループ {group}で強調する。戻
		り値は、マッチを識別する ID である。この ID はウィンドウに紐付
		けられている。|matchdelete()| でこの ID を指定してマッチを削除
		することができる。この ID はウィンドウパターンは大文字小文字を
		区別し、magic (|/magic|) として解釈される ({pattern} の中で明
		示的に変更しない限り)。オプションの 'magic'、'smartcase'、
		'ignorecase' は使用されない。
		Concealは特別であり、マッチを隠す作用がある。

		省略可能な引数 {priority} はマッチの優先度を指定する。優先度が
		高いマッチは、より低いマッチの強調を上書きする。優先度は整数で
		指定する(負の数も可能)。{priority} が指定されない場合は既定の
		優先度 10 となる。'hlsearch' の優先度はゼロで、したがってゼロ
		より大きい優先度のマッチはすべてそれを上書きする。構文ハイライ
		ト('syntax' を参照)は独立したメカニズムであり、優先度がいくつ
		であろうとマッチは構文ハイライトより優先する。

		{id} は特定のマッチ ID を返すことを要求する。指定された ID が
		すでに使われていたら、エラーメッセージが表示され、そのマッチは
		登録されない。ID は正の整数を指定する(ゼロは除く)。ID 1, 2, 3
		は |:match|, |:2match|, |:3match| 用に予約されている。3 は
		|matchparen| プラグインが使うために予約されている。
		引数 {id} が指定されていないか -1 の場合、|matchadd()| は、1000
		以上の空いている ID を自動的に選択する。

		省略可能な引数 {dict} はより一層カスタマイズ可能な値を許す。
		現在、これは|hl-Conceal|でハイライトされたマッチをconceal文字で
		表示されるのを明示するために使われる。
		この辞書は下記のメンバを持つことができる:

			conceal	    マッチ(|hl-Conceal|のためだけにハイライトさ
				    れたマッチ、|:syn-cchar|を参照)の代わりに
				    表示する特別な文字
			window	    現在のウィンドウの代わりに、この番号もしく
				    はウィンドウ ID のウィンドウを使用する

		コマンド |:match| と異なり、マッチの個数に上限はない。

		エラー時は -1 を返す。

		例: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchadd("MyGroup", "TODO")
<		このパターンを削除するには: >
			:call matchdelete(m)

<		|matchadd()| と |:match| で定義したマッチのリストは
		|getmatches()| で取得できる。全てのマッチを削除するのは
		|clearmatches()| 一発でできる。

		|method| としても使用できる: >
			GetGroup()->matchadd('TODO')
<
							*matchaddpos()*
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
		|matchadd()| と同じだが、パターンを指定するのではなく、位置の
		リスト {pos} を指定する。このコマンドは正規表現を扱う必要もな
		く、画面更新のためにバッファ行の境界を設定するため、
		|matchadd()| よりも速い。これは、例えば括弧の対応を強調表示す
		るような、マッチの追加と削除を高速に実行したい状況を想定してい
		る。

		{pos} は位置のリストである。各位置は以下のいずれかである:
		- 数値。指定した行全体が強調表示される。最初の行の行番号は 1
		  である。
		- 数値を 1 つ持ったリスト。例 [23]。指定した行全体が強調表示さ
		  れる。
		- 数値を 2 つ持ったリスト。例 [23, 11]。最初の数値は行番号、2
		  番目の数値は列番号である (最初の列は 1 である。値は |col()|
		  の戻り値と同じようにバイト単位である)。指定した位置の文字が
		  強調表示される。
		- 数値を 3 つ持ったリスト。例 [23, 11, 3]。数値 2 つの場合と同
		  じだが、3 つ目に強調表示する文字の長さ (バイト単位) を指定す
		  る。

		エラー時は -1 を返す。

		例: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchaddpos("MyGroup", [[23, 24], 34])
<		パターンの削除: >
			:call matchdelete(m)

<		|matchaddpos()| で追加されたマッチは |getmatches()| で取得でき
		る。

		|method| としても使用できる: >
			GetGroup()->matchaddpos([23, 11])

matcharg({nr})							*matcharg()*
		|:match|、|:2match|、|:3match|によって設定されているマッチパター
		ンの情報を返す。{nr}が1のときは|:match|の情報、2のときは
		|:2match|の情報、3のときは|:3match|の情報を返す。
		戻り値は次の2個の要素を持つリストである:
			引数で指定したハイライトグループ名
			引数で指定した検索パターン
		{nr}が1、2、3のどれでもないときは空リストを返す。
		マッチパターンがセットされていないときは['', '']を返す。
		|:match| を保存し、復元するのに便利である。
		|:match| を使った強調は 3 個までに限られている。
		|matchadd()| にはこの制限はない。

		|method| としても使用できる: >
			GetMatch()->matcharg()
<
							*matchbufline()*
matchbufline({buf}, {pat}, {lnum}, {end}, [, {dict}])
		バッファ {buf} 内の {lnum} から {end} までの行で、{pat} がマッ
		チした行の |List| を返す。

		{lnum} と {end} には、行番号または {buf} の最後の行を参照する
		文字列 "$" を指定できる。

		{dict} 引数は次の項目をサポートする:
		    submatches	サブマッチ情報を含める (|/\(|)

		マッチごとに、次の項目を含む |Dict| が返される:
		    byteidx	マッチの開始バイトインデックス
		    lnum	マッチする行番号
		    text	マッチした文字列
		Note 単一行に複数のマッチが存在する可能性があることに注意。

		この関数はロードされたバッファに対してのみ機能する。必要であれ
		ば、最初に |bufload()| を呼び出す。

		パターンに対するいくつかのオプション設定の影響については
		|match-pattern| を参照。

		{buf} が有効なバッファでない場合、バッファがロードされていない
		場合、{lnum} または {end} が有効でない場合は、エラー発生し、空
		の |List| が返される。

		例: >
		    " バッファ 5 の 3 行目に "a" が含まれていると仮定
		    :echo matchbufline(5, '\<\k\+\>', 3, 3)
		    [{'lnum': 3, 'byteidx': 0, 'text': 'a'}]
		    " バッファ 10 の 4 行目に "tik tok" が含まれていると仮定
		    :echo matchbufline(10, '\<\k\+\>', 1, 4)
		    [{'lnum': 4, 'byteidx': 0, 'text': 'tik'}, {'lnum': 4, 'byteidx': 4, 'text': 'tok'}]
<
		{submatch} が存在し、v:true の場合、"\1"、"\2" 等のサブマッチ
		も返される。例: >
		    " バッファ 2 の 2 行目に "acd" が含まれていると仮定
		    :echo matchbufline(2, '\(a\)\?\(b\)\?\(c\)\?\(.*\)', 2, 2
						\ {'submatches': v:true})
		    [{'lnum': 2, 'byteidx': 0, 'text': 'acd', 'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]
<		"submatches" リストには常に 9 個のアイテムが含まれる。サブマッ
		チが見つからない場合、そのサブマッチに対しては空文字列が返され
		る。

		|method| としても使用できる: >
			GetBuffer()->matchbufline('mypat', 1, '$')

matchdelete({id}, [, {win}])		       *matchdelete()* *E802* *E803*
		|matchadd()| または |:match| で定義したマッチの中で ID が {id}
		であるものを削除する。成功したときは 0、失敗したときは
		-1 を返す。|matchadd()| の例を参照。すべてのマッチを削除するの
		は |clearmatches()| 一発でできる。
		{win} が指定されれば、カレントウィンドウではなく指定されたウィ
		ンドウあるいはウィンドウID を対象にする。

		|method| としても使用できる: >
			GetMatch()->matchdelete()

matchend({expr}, {pat} [, {start} [, {count}]])			*matchend()*
		|match()|と同じだが、返されるのはマッチした部分文字列の終了後の
		インデックスである。例: >
			:echo matchend("testing", "ing")
<		結果は "7"。
							*strspn()* *strcspn()*
		Vimにはstrspn()やstrcspn()に相当する関数はないが、matchend()を
		使えば同じことができる: >
			:let span = matchend(line, '[a-zA-Z]')
			:let span = matchend(line, '[^a-zA-Z]')
<		ただしマッチがないときには-1を返すところが異なる。

		{start}は|match()|の場合と同じ意味を持つ。 >
			:echo matchend("testing", "ing", 2)
<		結果は "7"。 >
			:echo matchend("testing", "ing", 5)
<		結果は "-1"。
		{expr}がリストの場合、戻り値は |match()| と等しくなる。

		|method| としても使用できる: >
			GetText()->matchend('word')


matchfuzzy({list}, {str} [, {dict}])			*matchfuzzy()*
		{list} が文字列のリストの場合、{list} 内のすべての文字列につい
		て {str} でファジーマッチしたリスト |List| を返す。返したリス
		トの文字列はマッチのスコアを基準としてソートされる。

		オプションの {dict} 引数では常に以下の項目がサポートされる:
		    matchseq	この項目が存在する場合、指定されたシーケンスの
				{str} 内の文字を含むマッチのみを返す。
		    limit	返される {list} 内のマッチの最大数。ゼロは制限
				がないことを意味する。

		{list} が辞書のリストなら、オプションの {dict} 引数では追加で
		以下の項目がサポートされる:
		    key		{str} でファジーマッチする対象となる項目の
				キー。この項目の値は文字列でなくてはならない。
		    text_cb	{list} 内でファジーマッチしたテキストの各項目
				ごとに |Funcref| が呼ばれる。
				これは辞書の項目が引数となり、返すテキストがそ
				の項目のファジーマッチの結果として受け付ける。

		{str} はリテラルの文字列として扱われ、マッチ用の正規表現はサ
		ポートされない。{str} の長さは最大256までサポートされる。

		{str} が空白で区切られた複数の単語の場合、返すリストはそれらの
		単語すべてを含む文字列になる。

		マッチする文字列がないかエラーとなった場合、空のリストが返され
		る。{str} の長さが256かそれ以上であるなら、空のリストを返す。

		{limit} が与えられた場合、matchfuzzy() はその数を上限として
		{list} 内でマッチするかを探し、その結果をソートして返す。

		文字列へのファジーマッチについての詳細は |fuzzy-matching| を参
		照。

		例: >
		   :echo matchfuzzy(["clay", "crow"], "cay")
<		["clay"]を返す。 >
		   :echo getbufinfo()->map({_, v -> v.name})->matchfuzzy("ndl")
<		結果は "ndl" とファジーマッチしたバッファ名のリストになる。 >
		   :echo getbufinfo()->matchfuzzy("ndl", {'key' : 'name'})
<		結果は "ndl" とファジーマッチしたバッファ名をもつバッファ情報
		の辞書のリストになる。 >
		   :echo getbufinfo()->matchfuzzy("spl",
						\ {'text_cb' : {v -> v.name}})
<		結果は "spl" とファジーマッチしたバッファ名をもつバッファ情報
		の辞書のリストになる。 >
		   :echo v:oldfiles->matchfuzzy("test")
<		結果は "test" とファジーマッチしたファイル名のリストになる。 >
		   :let l = readfile("buffer.c")->matchfuzzy("str")
<		結果は "str" とファジーマッチした "buffer.c" 内の行のリストになる。 >
		   :echo ['one two', 'two one']->matchfuzzy('two one')
<		結果は ['two one', 'one two'] になる。 >
		   :echo ['one two', 'two one']->matchfuzzy('two one',
						\ {'matchseq': 1})
<		結果は ['two one'] になる。

matchfuzzypos({list}, {str} [, {dict}])			*matchfuzzypos()*
		|matchfuzzy()| と同様だが、マッチした文字列のリスト、{str} と
		マッチした文字列内の文字の位置のリストとマッチのスコアのリスト
		を返す。|byteidx()| を使うことで文字位置からバイト位置へ変換で
		きる。

		文字列内で {str} が複数回マッチしたときは、最良のマッチとなっ
		た位置だけを返す。

		もし文字列にマッチしないもしくはエラーとなったときは、3つの空
		のリストを項目とするリストを返す。

		例: >
			:echo matchfuzzypos(['testing'], 'tsg')
<		結果は [['testing'], [[0, 2, 6]], [99]] になる。 >
			:echo matchfuzzypos(['clay', 'lacy'], 'la')
<		結果は [['lacy', 'clay'], [[0, 1], [1, 2]], [153, 133]] にな
		る。 >
			:echo [{'text': 'hello', 'id' : 10}]->matchfuzzypos('ll', {'key' : 'text'})
<		結果は [[{'id': 10, 'text': 'hello'}], [[2, 3]], [127]] にな
		る。

matchlist({expr}, {pat} [, {start} [, {count}]])		*matchlist()*
		|match()| と同じだがリストを返す。リストの最初の要素は、
		matchstr()が返すのと同じマッチした文字列。それ以降の要素は
		|:substitute|における "\1"、"\2" のようなサブマッチである。\1
		から\9までの間で、指定されなかったものは空文字列となる。例: >
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		結果は['acd', 'a', '', 'c', 'd', '', '', '', '', '']となる。
		マッチしなかったときは空リストを返す。

                リストを渡すことはできるが、あまり役に立たない。

		|method| としても使用できる: >
			GetText()->matchlist('word')
<
						*matchstrlist()*
matchstrlist({list}, {pat} [, {dict}])
		{pat} がマッチする {list} 内のマッチの |List| を返す。
		{list} は文字列の |List| である。{list} 内の各文字列に対して
		{pat} がマッチする。

		{dict} 引数は次の項目をサポートする:
		    submatches	サブマッチ情報を含める (|/\(|)

		マッチごとに、次の項目を含む |Dict| が返される:
		    byteidx	マッチの開始バイトインデックス。
		    idx		{list} 内のマッチのインデックス。
		    text	マッチした文字列
		    submatches	サブマッチのリスト。{dict} で "submatches" が
				v:true に設定されている場合にのみ存在する。

		パターンに対するいくつかのオプション設定の影響については
		|match-pattern| を参照。

		例: >
		    :echo matchstrlist(['tik tok'], '\<\k\+\>')
		    [{'idx': 0, 'byteidx': 0, 'text': 'tik'}, {'idx': 0, 'byteidx': 4, 'text': 'tok'}]
		    :echo matchstrlist(['a', 'b'], '\<\k\+\>')
		    [{'idx': 0, 'byteidx': 0, 'text': 'a'}, {'idx': 1, 'byteidx': 0, 'text': 'b'}]
<
		"submatch" が存在し、v:true の場合、"\1"、"\2" 等のサブマッチ
		も返される。例: >
		    :echo matchstrlist(['acd'], '\(a\)\?\(b\)\?\(c\)\?\(.*\)',
						\ #{submatches: v:true})
		    [{'idx': 0, 'byteidx': 0, 'text': 'acd', 'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]
<		"submatches" リストには常に 9 個のアイテムが含まれる。サブマッ
		チが見つからない場合、そのサブマッチに対しては空文字列が返され
		る。

		|method| としても使用できる: >
			GetListOfStrings()->matchstrlist('mypat')

matchstr({expr}, {pat} [, {start} [, {count}]])			*matchstr()*
		|match()| と同じだが、マッチした文字列を返す。例: >
			:echo matchstr("testing", "ing")
<		結果は "ing"。
		マッチしなかったときは "" を返す。
		{start}の意味は |match()| の場合と同じ。 >
			:echo matchstr("testing", "ing", 2)
<		結果は "ing"。 >
			:echo matchstr("testing", "ing", 5)
<		結果は ""。
		{expr}がリストのときはマッチした要素を返す。
		その要素の型は変換されないため、必ずしも文字列であるとは限らな
		い。

		|method| としても使用できる: >
			GetText()->matchstr('word')

matchstrpos({expr}, {pat} [, {start} [, {count}]])		*matchstrpos()*
		|matchstr()| と同じだがマッチした文字列とマッチした開始位置と
		終了位置を返す。例: >
			:echo matchstrpos("testing", "ing")
<		結果は ["ing", 4, 7] である。
		マッチが無い場合は ["", -1, -1] が返る。
		{start} が指定されている場合は |match()| と同じ意味になる。 >
			:echo matchstrpos("testing", "ing", 2)
<		結果は ["ing", 4, 7] である。 >
			:echo matchstrpos("testing", "ing", 5)
<		結果は ["", -1, -1] である。
		{expr} が |List| の場合、マッチしたアイテム、{pat} でマッチし
		た最初のインデックス、マッチの開始位置と終了位置が返る。 >
			:echo matchstrpos([1, '__x'], '\a')
<		結果は ["x", 1, 2, 3] である。
		型は変更されない。必ずしも文字列である必要はない。

		|method| としても使用できる: >
			GetText()->matchstrpos('word')
<

							*max()*
max({expr})	{expr}の全要素の値の最大値を返す。例: >
			echo max([apples, pears, oranges])

<		{expr}はリスト |List| か辞書 |Dictionary| である。辞書の場合、
		辞書に含まれるすべての値の最大値を返す。
		{expr}がリストでも辞書でもなかったり、要素のどれかが数値に変換
		できない場合はエラーとなる。
		空のリストまたは辞書の場合は0を返す。

		|method| としても使用できる: >
			mylist->max()


menu_info({name} [, {mode}])				*menu_info()*
		{mode} モードのときのメニュー {name} についての情報を返す。メ
		ニュー名はショートカット文字 ('&') を除いたもの。
		{name} が "" の場合、最上位のメニュー名を返す。

		{mode} は以下の文字の1つを指定できる:
			"n"	ノーマル
			"v"	ビジュアル (選択含む)
			"o"	オペレータ待機
			"i"	挿入
			"c"	コマンドライン
			"s"	選択
			"x"	ビジュアル
			"t"	端末ジョブ
			""	ノーマル、ビジュアル、オペレータ待機
			"!"	挿入、コマンドライン
		{mode} を指定していないときは、モードとして "" が使用される。

		戻り値の辞書|Dictionary| は以下の項目が含まれる:
		  accel		メニュー項目のアクセラレータテキスト |menu-text|
		  display	表示名 ('&' を含まない)
		  enabled	v:true ならメニュー項目が有効
				|:menu-enable| を参照
		  icon		アイコンファイル名 (ツールバー向け)
				|toolbar-icon|
		  iconidx	組み込みアイコンのインデックス
		  modes		メニューを定義しているモード。上で示している
				モードに追加して、次の文字が使われる:
				" "	ノーマル、ビジュアル、オペレータ待機
		  name		メニュー項目名。
		  noremenu	v:true ならメニュー項目の {rhs} が再マップ可能
				でなく、そうでないなら v:false。
		  priority	メニューの順序優先度 |menu-priority|
		  rhs		メニュー項目の右辺値。":menu" コマンドが出力す
				る中にあるように変換された特別な文字を持つ文字
				列を返す。
				メニュー項目の {rhs} が空の場合、"<Nop>" を返
				す。
		  script	{rhs} がスクリプトローカルの再マップができるな
				ら v:true、そうでないなら v:false。
				|:menu-script| を参照。
		  shortcut	ショートカットキー (メニュー項目名の '&' 後に
				ある文字) |menu-shortcut|
		  silent	メニュー項目が <silent> 付きで作られていたら
				v:true |:menu-silent|
		  submenus	名前のあるサブメニューすべてが含まれたリスト
				|List|。メニュー項目がサブメニューを持つ場合
				のみ存在する。

		メニュー項目が見付からない場合は空の辞書を返す。

		例: >
			:echo menu_info('Edit.Cut')
			:echo menu_info('File.Save', 'n')

			" メニュー階層全体をバッファに表示する
			func ShowMenu(name, pfx)
			  let m = menu_info(a:name)
			  call append(line('$'), a:pfx .. m.display)
			  for child in m->get('submenus', [])
			    call ShowMenu(a:name .. '.' .. escape(child, '.'),
							\ a:pfx .. '    ')
			  endfor
			endfunc
			new
			for topmenu in menu_info('').submenus
			  call ShowMenu(topmenu, '')
			endfor
<
		|method| としても使用できる: >
			GetMenuName()->menu_info('v')


<							*min()*
min({expr})	{expr}の全要素の値の最小値を返す。例: >
			echo min([apples, pears, oranges])

<		{expr}はリスト |List| か辞書 |Dictionary| である。辞書の場合、
		辞書に含まれるすべての値の最小値を返す。
		{expr}がリストでも辞書でもなかったり、要素のどれかが数値に変換
		できない場合はエラーとなる。
		空のリストまたは辞書の場合は0を返す。

		|method| としても使用できる: >
			mylist->min()

<							*mkdir()* *E739*
mkdir({name} [, {flags} [, {prot}]])
		ディレクトリ{name}を作成する。

		{flags} が存在する場合、それは文字列である必要がある。空文字列
		は効果がない。

		{flags} に "p" が含まれている場合、必要に応じて中間ディレクト
		リが作成される。

		{flags} に "D" が含まれている場合、現在の関数の最後で、次のよ
		うに {name} が削除される: >
			defer delete({name}, 'd')
<
		{flags} に "R" が含まれている場合、現在の関数の最後で、次のよ
		うに {name} が再帰的に削除される: >
			defer delete({name}, 'rf')
<		Note {name} に複数の部分があり、"p" が使用されている場合、一部
		のディレクトリがすでに存在している可能性があることに注意。最初
		に作成されたものとその内容のみが削除されるようにスケジュールさ
		れている。
		使用例: >
			call mkdir('subdir/tmp/autoload', 'pR')
<		"subdir" がすでに存在する場合、次のように "subdir/tmp" の削除
		がスケジュールされる: >
			defer delete('subdir/tmp', 'rf')
<		Note defer のスケジュール設定が失敗した場合、ディレクトリは削
		除されないことに注意。これはメモリ不足の場合にのみ発生する。

		{prot}は作成するディレクトリの保護ビット。デフォルトは0o755
		(rwxr-xr-x: 所有者は読み書き可能、他の人は読み込み可能)。
		他の人が読み込めないようにするには0o700とすること。{prot} は
		{name} の最後の部分にのみ適用される。なので、/tmp/foo/bar
		を作成すると /tmp/foo は 0o755 で作成される。
		例: >
			:call mkdir($HOME .. "/tmp/foo/bar", "p", 0o700)

<		|sandbox|の中ではこの関数は使用できない。

		ディレクトリが既に存在して、かつフラグ "p" が渡された場合エラー
		は発生しない (パッチ 8.0.1708 より)。ただし、"p" オプション未
		指定だと、呼び出しは失敗する。

		関数の結果は数値である。呼び出しが成功した場合は真、ディレクト
		リの作成に失敗したか部分的に失敗した場合は偽である。

		システムによっては利用できない場合がある。これを確認するには次
		のようにする: >
			:if exists("*mkdir")

<		|method| としても使用できる: >
			GetName()->mkdir()
<
							*mode()*
mode([expr])	現在のモードを示す文字列を返す。
		[expr] に 0 でない数値か空でない文字列 (|non-zero-arg|) を指定
		した場合、フルモードが返される。それ以外の場合は最初の一文字だ
		けが返される。
		|state()| も参照。

		   n	    ノーマル
		   no	    オペレータ待機
		   nov	    オペレータ待機 (強制文字単位 |o_v|)
		   noV	    オペレータ待機 (強制行単位 |o_V|)
		   noCTRL-V オペレータ待機 (強制ブロック単位 |o_CTRL-V|);
				CTRL-V は1文字である
		   niI	    |Insert-mode| で |i_CTRL-O| を使用したノーマル
		   niR	    |Replace-mode| で |i_CTRL-O| を使用したノーマル
		   niV	    |Virtual-Replace-mode| で |i_CTRL-O| を使用したノー
			    マル
		   nt	    端末ノーマル (挿入により端末ジョブモードになる)
		   v	    文字単位ビジュアル
		   vs	    選択モードで |v_CTRL-O| を利用した時の文字単位ビ
			    ジュアル
		   V	    行単位ビジュアル
		   Vs	    選択モードで |v_CTRL-O| を利用した時の行単位ビジュ
			    アル
		   CTRL-V   矩形ビジュアル
		   CTRL-Vs  選択モードで |v_CTRL-O| を利用した時の矩形ビジュア
			    ル
		   s	    文字単位選択
		   S	    行単位選択
		   CTRL-S   矩形選択
		   i	    挿入
		   ic	    挿入モード補完 |compl-generic|
		   ix	    挿入モード |i_CTRL-X| 補完
		   R	    置換 |R|
		   Rc	    置換モード補完 |compl-generic|
		   Rx	    置換モード |i_CTRL-X| 補完
		   Rv	    仮想置換 |gR|
		   Rvc	    補完での仮想置換モード |compl-generic|
		   Rvx	    |i_CTRL-X| 補完での仮想置換モード
		   c	    コマンドライン編集
		   ct	    端末ジョブモードでのコマンドライン編集
		   cr	    コマンドライン編集上書きモード |c_<Insert>|
		   cv	    Vim Ex モード |gQ|
		   cvr	    Vim Ex モード中の上書きモード |c_<Insert>|
		   ce	    ノーマル Ex モード |Q|
		   r	    Hit-enter プロンプト
		   rm	    -- more -- プロンプト
		   r?	    ある種の |:confirm| 問い合わせ
		   !	    シェルまたは外部コマンド実行中
		   t	    端末ジョブモード: キー入力がジョブに行く

		これらはオプション 'statusline' の中や、|remote_expr()| といっ
		しょに使うと便利である。他のほとんどの場所では "c" または "n"
		しか返さない。
		Note: 将来的により多くのモードやより詳細なモードが追加される可
		能性がある。文字列全体を比較するのではなく、先頭の文字だけを比
		較したほうがよい。
		|visualmode()| も参照。

		|method| としても使用できる: >
			DoFull()->mode()

mzeval({expr})							*mzeval()*
		MzScheme の式 {expr} を評価してその結果を Vim の変数に変換した
		結果を返す。
		数値と文字列はそのまま返る。
		ペア (リストと不適切なリスト (improper list) を含む) とベクタ
		は Vim のリスト (|Lists|) に変換される。
		ハッシュテーブルは Vim の辞書 (|Dictionary|) に変換され、その
		キーは文字列に変換される。
		その他のすべての型は display 関数を使って文字列に変換される。
		例: >
		    :mz (define l (list 1 2 3))
		    :mz (define h (make-hash)) (hash-set! h "list" l)
		    :echo mzeval("l")
		    :echo mzeval("h")
<
		Note `:def` 関数にあるローカル変数は {expr} からは見えない。

		|method| としても使用できる: >
			GetExpr()->mzeval()
<
		{|+mzscheme| 機能を有効にしてコンパイルしたときのみ有効}

nextnonblank({lnum})					*nextnonblank()*
		{lnum}行以降({lnum}行を含む)の最初の非空行の行番号を返す。
		例: >
			if getline(nextnonblank(1)) =~ "Java"
<		{lnum}が無効なときや、それ以降に非空行がないときは0を返す。
		{lnum}は|getline()|と同様に扱われる。
		|prevnonblank()|も参照。

		|method| としても使用できる: >
			GetLnum()->nextnonblank()

nr2char({expr} [, {utf8}])				*nr2char()*
		コード{expr}で表される1文字からなる文字列を返す。例: >
			nr2char(64)		"@"を返す
			nr2char(32)		" "を返す
<		{utf8} を省略、またはゼロを指定すると、現在の 'encoding' が適
		用される。"utf-8" の場合の例: >
			nr2char(300)		短音記号つきのIを返す
<		{utf8} が真のとき、常に UTF-8 文字が返る。
		Note Vim内部では、ファイル中のNUL文字を改行文字(0x0A)に変換し
		て保持している。そのため、nr2char(10)とすればNUL文字を指定でき
		る。nr2char(0)は真のNUL文字(文字列の終端)となるので、空文字列
		を返す。
		文字の数値のリストを文字列に変換するには: >
		    let list = [65, 66, 67]
		    let str = join(map(list, {_, val -> nr2char(val)}), '')
<		結果: "ABC"

		|method| としても使用できる: >
			GetNumber()->nr2char()

or({expr}, {expr})					*or()*
		二つの引数のビット論理和。引数は数値に変換される。リスト、辞
		書、浮動小数点数を指定するとエラーになる。
		`and()` および `xor()` も参照。
		例: >
			:let bits = or(bits, 0x80)

<		|method| としても使用できる: >
			:let bits = bits->or(0x80)

<		理論的根拠: これが関数であり、多くの言語のように "|" 文字を使
		わないのは、Vi が常に "|" をコマンドの区切りに使ってきたからで
		ある。多くの場所では、"|" が演算子なのかコマンドの区切りなのか
		はっきりしない。

pathshorten({path} [, {len}])				*pathshorten()*
		パス{path}におけるディレクトリ名を短縮して返す。拡張子、ファイ
		ル名はそのまま保たれる。パスのその他の構成要素は要素内での長さ
		が {len}文字 に縮められる。{len} が省略された場合もしくは1以下
		のときは1文字が使われる。1文字目の '~' と '.' はそのまま保たれ
		る。例: >
			:echo pathshorten('~/.vim/autoload/myfile.vim')
<			~/.v/a/myfile.vim ~
>
			:echo pathshorten('~/.vim/autoload/myfile.vim', 2)
<			~/.vi/au/myfile.vim ~
		パスが実際に存在するかどうかは関係ない。
		エラー時には空の文字列を返す。

		|method| としても使用できる: >
			GetDirectories()->pathshorten()

perleval({expr})					*perleval()*
		Perl の式 {expr} をスカラーコンテキストで評価して、結果をVimの
		データ形式にして返す。
		もし値が変換できない場合、Perlにおける文字列として返される。
		Note: もし配列かハッシュが必要ならば、{expr}ではそれらへの参照
		を返す必要がある。
		例: >
			:echo perleval('[1 .. 4]')
<			[1, 2, 3, 4]

		Note `:def` 関数にあるローカル変数は {expr} からは見えない。

		|method| としても使用できる: >
			GetExpr()->perleval()

<		{|+perl| 機能付きでコンパイルされたときのみ利用可能}

popup_ 関数群はここに文書化されている: |popup-functions|

pow({x}, {y})						*pow()*
		{x} の {y} 乗を |Float| で返す。{x} と {y} は |Float| または
		|Number| に評価されなければならない。
		{x} または {y} が |Float| または |Number| でない場合は 0.0 を
		返す。
		例: >
			:echo pow(3, 3)
<			27.0 >
			:echo pow(2, 16)
<			65536.0 >
			:echo pow(32, 0.20)
<			2.0

		|method| としても使用できる: >
			Compute()->pow(3)

prevnonblank({lnum})					*prevnonblank()*
		{lnum}行以前({lnum}行を含む)の最初の非空行の行番号を返す。
		例: >
			let ind = indent(prevnonblank(v:lnum - 1))
<		{lnum}が無効なときや、それ以前に非空行がないときは0を返す。
		{lnum}は|getline()|と同様に扱われる。
		|nextnonblank()|も参照。

		|method| としても使用できる: >
			GetLnum()->prevnonblank()

printf({fmt}, {expr1} ...)				*printf()*
		{fmt}にしたがって組み立てた文字列を返す。{fmt}中の "%" 変換指
		示子は、対応する引数の値で置き換えられる。例: >
			printf("%4d: E%d %.30s", lnum, errno, msg)
<		結果は次のような形になる:
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		|method| としても使用でき、ベースは第2引数として渡される: >
			Compute()->printf("result: %d")
<
		`call()` を使うことで、要素をリストとして渡せる。

		よく使われる変換指示子は次の通り:
		  %s	文字列
		  %6S	6表示幅で右揃えした文字列
		  %6s	6バイトで右揃えした文字列
		  %.9s	9バイトに切り詰めた文字列
		  %c	1バイト
		  %d	10進数値
		  %5d	スペースで埋めて5文字にした10進数値
		  %x	16進数値
		  %04x	0で埋めて少なくとも4文字にした16進数値
		  %X	16進数値(大文字)
		  %o	8進数値
		  %08b	最低8文字の0埋めされた2進数
		  %f	浮動小数点数。12.23, inf, -inf, nan
		  %F	浮動小数点数。12.23, INF, -INF, NAN
		  %e	浮動小数点数。1.23e3, inf, -inf, nan
		  %E	浮動小数点数。1.23E3, INF, -INF, NAN
		  %g	浮動小数点数。値によって %f または %e となる
		  %G	浮動小数点数。値によって %F または %E となる
		  %%    文字 % そのもの

		変換指示子は '%' で始まり、変換文字で終わる。それ以外の全ての
		文字はそのままになる。

		"%" は変換指示子の開始を意味する。以下の順序で引数を指定できる:

			% [位置引数] [フラグ] [フィールド幅] [.精度] 型

		位置引数
			最大 1 つの位置引数指定子。これらは {n$} の形式を取り、
			n は >= 1 である。

		フラグ
			0個以上の以下のフラグを指定できる

		    #	      値を「代替形式」に変換する。変換指示子c, d, sに
			      対してはこのオプションは効果を持たない。変換指示
			      子oに対しては数値の精度を上げ、出力文字列の最初
			      の文字が0になる。(明示的な精度0で値0が表示される
			      ときを除く)
			      変換指示子bとBに対しては、値が0でない場合、文字
			      列 "0b" (変換子Bの場合は "0B")を前につける。
			      変換指示子xとXに対しては、値が0でない場合、文字
			      列 "0x" (変換子Xの場合は "0X")を前につける。

		    0 (zero)  ゼロパディングする。全ての変換に対し、変換された
			      値の左側を空白でなく0で埋める。数値変換(d, b, B,
			      o, x, X)に対して精度が指定されている場合はフラグ
			      0は無視される。

		    -	      負のフィールド幅を示す。変換値がフィールド境界に
			      左揃えされる。変換値の左に空白や0がつくのではな
			      く、変換値の右に空白がつく。
			      -と0を両方指定した場合は-が有効になる。

		    ' ' (space)  空白。符号付き変換(d)で作成される正の数値の前
			      に空白が残る。

		    +	      +文字。符号付き変換で作成される数値の前に常に符
			      号を付ける。+と' '(space)を両方指定した場合は+が
			      有効になる。

		フィールド幅
			10進数文字列(省略可)。最低フィールド幅を指定する。変換
			値のバイト数がこのフィールド幅より少ない場合、左に空白
			がついて(左揃えフラグを指定した場合は右に空白がついて)
			フィールドの幅に合わせられる。S変換指示子の個数は表示
			幅単位である。

		.精度
			ピリオド '.' の次に数字文字列がつづく形式の精度(省略
			可)。数字文字列を省略した場合、精度は0になる。
			d, o, x, X変換における最低表示桁数、s変換における文字
			列表示の最大バイト数、またはS変換における文字列表示の
			最大表示幅数を指定する。
			浮動小数点数の場合は小数点以下の桁数。

		型
			変換の型を指定する1文字。下記を参照。

		フィールド幅と精度には、数字文字列の代わりにアスタリスク '*'
		を指定できる。その場合、対応する数値の引数がフィールド幅または
		精度となる。負のフィールド幅を指定すると、絶対値がフィールド幅
		となり、左揃えフラグがオンになる。負の精度を指定すると、完全に
		無視される。例: >
			:echo printf("%d: %.*s", nr, width, line)
<		この例は、テキスト "line" の長さを "width" バイトに制限する。

		整形される引数が位置引数指定子を使って指定され、'*' が幅または
		精度を指定するために数値引数が使われることを示すために使われる
		場合、使われる引数も{n$} 位置引数指定子を使って指定されなけれ
		ばならない。|printf-$| を参照。

		変換指示子の意味は以下の通り:

				*printf-d* *printf-b* *printf-B* *printf-o*
				*printf-x* *printf-X*
		dbBoxX	数値の引数を符号付き10進数(d)、符号なし2進数(bまたは
			B)、符号なし8進数(o)、符号なし16進数(xまたはX)の書式に
			変換する。xの場合は "abcdef" と小文字を使い、Xの場合は
			"ABCDEF" と大文字を使う。
			精度が指定されていれば出力する最小桁数を意味する。変換
			された値を出力するのにそれ以下しか必要としない場合は、
			左側にゼロを加えて埋める。
			フィールド幅が存在しない場合や小さすぎる場合でも、数値
			の幅を切り詰めることは決してない。変換結果がフィールド
			幅より多くの桁を必要とする場合は、十分な幅に広げられる。
			モディファイア 'h' は引数が16ビット引数である事を示す。
			モディファイア 'l' 修飾子は、引数が長整数であることを
			示す。サイズはプラットフォームによって 32 ビットか 64
			ビットになる。
			モディファイア "ll" 修飾子は、引数が 64 ビットであるこ
			とを示す。
			b と B 変換指定子は幅修飾子を取らず、常に引数が 64 ビッ
			ト整数であると仮定する。
			一般的にモディファイアは便利ではない。引数から型が分か
			る時には無視されてしまう。

		i	d のエイリアス
		D	ld のエイリアス
		U	lu のエイリアス
		O	lo のエイリアス

							*printf-c*
		c	引数の数値を1バイトに変換し、結果の文字列を書き出す。

							*printf-s*
		s	引数の文字列を出力する。精度を指定した場合、その数値以
			下のバイト数のみを書き出す。
			引数が文字列型ではない場合、":echo" と同じ形式のテキス
			トに自動的に変換される。
							*printf-S*
		S	引数の文字列を出力する。精度を指定した場合、その数値以
			下の表示幅のみを書き出す。

							*printf-f* *E807*
		f F	Float の引数を 123.456 の形式の文字列に変換する。精度
			は小数点以下の桁数を指定する。精度が 0 のときは小数点
			以下は省略される。精度を指定しないときは 6 桁となる。
			とてつもなく大きい数(範囲外またはゼロによる除算)のとき
			は %f の場合 "inf" または "-inf" となる (%F の場合は
			"INF" または "-INF")。"0.0 / 0.0" は %f の場合 "nan"
			になる (%F の場合は "NAN")。
			例: >
				echo printf("%.2f", 12.115)
<				12.12
			丸めはシステムのライブラリに依存する。心配なときは
			|round()| を使うこと。

							*printf-e* *printf-E*
		e E	Float の引数を 1.234e+03 という形式('E' のときは
			1.234E+03)の文字列に変換する。精度は 'f' の場合と同じ
			く小数点以下の桁数を指定する。

							*printf-g* *printf-G*
		g G	0.001(を含む)から10000000.0(を除く)の間の場合は 'f' の
			形式で変換し、この間にない場合は 'g' は 'e'、'G' は 'E'
			の形式によって変換する。精度が指定されないときは余分な
			ゼロ(小数点の直後のゼロ以外)と '+' 記号は省かれる。よっ
			て 10000000.0 は 1.0e7 になる。

							*printf-%*
		%	単一の '%' を書き出す。引数は変換しない。完全な変換指
			定は "%%" となる。

		数値の引数を受け取る変換指示子には文字列を与えることもできる。
		変換は自動的に行われる。
		浮動小数点数または文字列の引数を受け取る変換指示子には、数値を
		与えることもできる。変換は自動的に行われる。
		それ以外の型の引数を与えるとエラーメッセージが表示される。

							*E766* *E767*
		{expr1}以降の引数の数と "%" 変換指示子の個数がちょうど一致しな
		ければならない。そうでない場合はエラーとなる。引数は最大18個ま
		で使える。

							*printf-$*
		特定の言語では、単語の順序が英語の対応するメッセージと異なる場
		合、エラー メッセージや情報メッセージが読みやすくなる。語順が
		異なる翻訳に対応するために、位置引数を使用してこれを示すことが
		できる。例えば: >

		    #, c-format
		    msgid "%s returning %s"
		    msgstr "waarde %2$s komt terug van %1$s"
<
		この例では、2 つの文字列引数を逆にした文が出力されている。 >

		    echo printf(
			"In The Netherlands, vim's creator's name is: %1$s %2$s",
			"Bram", "Moolenaar")
<		    オランダ語では、vim's creator's name is: Bram Moolenaar >

		    echo printf(
			"In Belgium, vim's creator's name is: %2$s %1$s",
			"Bram", "Moolenaar")
<		    ベルギー語では、vim's creator's name is: Moolenaar Bram

		幅 (および精度) は、'*' 指定子を使用して指定できる。この場合、
		引数リストでフィールド幅の位置を指定する必要がある。 >

		    echo printf("%1$*2$.*3$d", 1, 2, 3)
<		    001 >
		    echo printf("%2$*3$.*1$d", 1, 2, 3)
<		      2 >
		    echo printf("%3$*1$.*2$d", 1, 2, 3)
<		    03 >
		    echo printf("%1$*2$.*3$g", 1.4142, 2, 3)
<		    1.414

		幅や精度を直接指定することと、位置引数を介して指定することを組
		み合わせることができる: >

		    echo printf("%1$4.*2$f", 1.4142135, 6)
<		    1.414214 >
		    echo printf("%1$*2$.4f", 1.4142135, 6)
<		    1.4142 >
		    echo printf("%1$*2$.*3$f", 1.4142135, 6, 2)
<		      1.41

		フィールド幅もしくは精度が 6400 文字より長い文字列になる場合
		は、オーバーフローエラー |E1510| を得るだろう。

							*E1500*
		位置引数と非位置引数を混在させることはできない: >
		    echo printf("%s%1$s", "One", "Two")
<		    E1500: Cannot mix positional and non-positional arguments:
		    %s%1$s

							*E1501*
		フォーマット文字列内の位置引数をスキップすることはできない: >
		    echo printf("%3$s%1$s", "One", "Two", "Three")
<		    E1501: format argument 2 unused in $-style format:
		    %3$s%1$s

							*E1502*
		[field-width] (または [precision]) 引数を再利用できる: >
		    echo printf("%1$d at width %2$d is: %01$*2$d", 1, 2)
<		    1 at width 2 is: 01

		ただし、別の型として使用することはできない: >
		    echo printf("%1$d at width %2$ld is: %01$*2$d", 1, 2)
<		    E1502: Positional argument 2 used as field width reused as
		    different type: long int/int

							*E1503*
		位置引数が使用されているが、正しい数値または引数が指定されてい
		ない場合、エラーが発生する: >
		    echo printf("%1$d at width %2$d is: %01$*2$.*3$d", 1, 2)
<		    E1503: Positional argument 3 out of bounds: %1$d at width
		    %2$d is: %01$*2$.*3$d

		最初のエラーだけが報告される: >
		    echo printf("%01$*2$.*3$d %4$d", 1, 2)
<		    E1503: Positional argument 3 out of bounds: %01$*2$.*3$d
		    %4$d

							*E1504*
		位置引数は複数回使用できる: >
		    echo printf("%1$s %2$s %1$s", "One", "Two")
<		    One Two One

		ただし、2 回目には別の型を使用することはできない: >
		    echo printf("%1$s %2$s %1$d", "One", "Two")
<		    E1504: Positional argument 1 type used inconsistently:
		    int/string

							*E1505*
		フォーマット文字列が誤ってフォーマットされることにつながる他の
		さまざまなエラーは、以下のようなものである: >
		    echo printf("%1$d at width %2$d is: %01$*2$.3$d", 1, 2)
<		    E1505: Invalid format specifier: %1$d at width %2$d is:
		    %01$*2$.3$d

							*E1507*
		この内部エラーは、位置形式引数を解析するロジックで、他の方法で
		は報告できない問題が発生したことを示す。この問題が発生した場合
		は、使用された正確なフォーマット文字列とパラメータをコピーし
		て、Vim に対してバグを報告すること。


prompt_getprompt({buf})					*prompt_getprompt()*
		バッファ {buf} で使われているプロンプトテキストを返す。{buf}
		はバッファ名もしくは番号が使える。|prompt-buffer| を参照。

		バッファが存在しないもしくはプロンプトがバッファにないなら、空
		文字列を返す。

		|method| としても使用できる: >
			GetBuffer()->prompt_getprompt()

<		{|+channel| 機能つきでコンパイルされたときのみ存在する}


prompt_setcallback({buf}, {expr})			*prompt_setcallback()*
		バッファ {buf} のプロンプトコールバックを {expr} に設定する。
		{expr} が空文字列の場合、コールバックは取り除かれる。これは
		{buf} の 'buftype' が "prompt" に設定されている場合のみ有効で
		ある。

		このコールバックは Enter を押したときに呼び出される。カレント
		バッファは必ずプロンプトバッファである。コールバックの呼び出し
		の前に次のプロンプト用の新しい行が追加されるので、コールバック
		が呼び出されたプロンプトは最後から 2 番目の行になる。
		コールバックがバッファにテキストを追加する場合、最後の行は現在
		のプロンプトであるため、その上に追加しなければならない。これは
		非同期に行われる可能性がある。
		コールバックは、プロンプトに入力されたテキストを唯一の引数とし
		て呼び出される。ユーザーが Enter のみをタイプした場合は空文字
		となる。
		例: >
		   func s:TextEntered(text)
		     if a:text == 'exit' || a:text == 'quit'
		       stopinsert
		       " バッファをクローズできるように 'modified' をリセット
		       " する。保存すべき有用なものは何もないと仮定する。
		       set nomodified
		       close
		     else
		       " "a:text" を使って何か役に立つことをしてみよう。この例
		       " では、それを繰り返すだけである。
		       call append(line('$') - 1, 'Entered: "' .. a:text .. '"')
		     endif
		   endfunc
		   call prompt_setcallback(bufnr(), function('s:TextEntered'))

<		|method| としても使用できる: >
			GetBuffer()->prompt_setcallback(callback)

<		{|+channel| 機能つきでコンパイルされたときのみ存在する}

prompt_setinterrupt({buf}, {expr})			*prompt_setinterrupt()*
		バッファ {buf} のコールバックを {expr} に設定する。{expr} が空
		文字列の場合、コールバックは取り除かれる。これは {buf} の
		'buftype' が "prompt" に設定されている場合のみ有効である。

		このコールバックは、挿入モードにおいて CTRL-C を押したときに呼
		び出される。コールバックを設定していない場合、Vim は他のバッ
		ファと同様に挿入モードを終了する。

		|method| としても使用できる: >
			GetBuffer()->prompt_setinterrupt(callback)

<		{|+channel| 機能つきでコンパイルされたときのみ存在する}

prompt_setprompt({buf}, {text})				*prompt_setprompt()*
		バッファ {buf} のプロンプトを {text} に設定する。大抵の場合、
		{text} が空白で終わるようにしたいと考えるだろう。
		{buf} の 'buftype' が "prompt" に設定されている場合のみ結果が
		見える。例: >
			call prompt_setprompt(bufnr(), 'command: ')
<
		|method| としても使用できる: >
			GetBuffer()->prompt_setprompt('command: ')

<		{|+channel| 機能つきでコンパイルされたときのみ存在する}

prop_ 関数群はここに文書化されている: |text-prop-functions|

pum_getpos()						*pum_getpos()*
		ポップアップメニュー(|ins-completion-menu| を参照)が表示されな
		い場合、空の |Dictionary| を返す。それ以外の場合、以下のキーを
		使用した |Dictionary| を返す。
			height		見えている項目数
			width		画面セル数
			row		最上位の画面行(最初の行は 0)
			col		左端の画面桁(最初の桁は 0)
			size		総項目数
			scrollbar	スクロールバーが表示されていれば |TRUE|

		値は |CompleteChanged| 中の |v:event| と同じである。

pumvisible()						*pumvisible()*
		ポップアップメニューが表示されているときには非0を返す。表示さ
		れていないときは0を返す。|ins-completion-menu|を参照。
		ポップアップメニューを消してしまうような操作を避けるために使わ
		れる。

py3eval({expr})						*py3eval()*
		Python の式 {expr} を評価して、結果を Vim のデータ形式にして返
		す。
		数値と文字列はそのまま返る (ただし文字列はコピーされ、Unicode
		から 'encoding' に変換される)。
		リストは Vim の |List| 型に変換される。
		辞書は Vim の |Dictionary| 型に変換される。辞書のキーは文字列
		に変換される。
		Note `:def` 関数にあるローカル変数は {expr} からは見えない。

		|method| としても使用できる: >
			GetExpr()->py3eval()

<		{|+python3| 機能付きでコンパイルされたときのみ利用可能}

							*E858* *E859*
pyeval({expr})						*pyeval()*
		Python の式 {expr} を評価して、結果を Vim のデータ形式にして返
		す。
		数値と文字列はそのまま返る (ただし文字列はコピーされる)。
		リストは Vim の |List| 型に変換される。
		辞書は Vim の |Dictionary| 型に変換される。文字列ではない辞書
		のキーはエラーになる。
		Note `:def` 関数にあるローカル変数は {expr} からは見えない。

		|method| としても使用できる: >
			GetExpr()->pyeval()

<		{|+python| 機能付きでコンパイルされたときのみ利用可能}

pyxeval({expr})						*pyxeval()*
		Python の式 {expr} を評価して、結果を Vim のデータ形式にして返
		す。
		Python 2 または 3 を使用する。|python_x| と 'pyxversion' を参
		照。
		|pyeval()|, |py3eval()| も参照。

		|method| としても使用できる: >
			GetExpr()->pyxeval()

<		{|+python| または |+python3| 機能付きでコンパイルされたときの
		み利用可能}

rand([{expr}])						*rand()* *random*
		種 {expr} を使い、xoshiro128** アルゴリズムで生成された疑似乱
		数を返す。返される数値は一貫性のため、64 ビットシステム上であ
		っても 32 ビットである。
		{expr} は |srand()| で初期化することができ、rand() で更新され
		る。{expr} が省略されたときは内部的な種の値が用いられ、更新さ
		れる。
		{expr} が無効な場合は -1 を返す。

		例: >
			:echo rand()
			:let seed = srand()
			:echo rand(seed)
			:echo rand(seed) % 16  " random number 0 - 15
<

							*E726* *E727*
range({expr} [, {max} [, {stride}]])				*range()*
		以下のような数値のリスト|List|を返す。
		- {expr}のみを指定したときは:  [0, 1, ..., {expr} - 1]
		- {max}を指定したときは: [{expr}, {expr} + 1, ..., {max}]
		- {stride}を指定したときは: [{expr}, {expr} + {stride}, ...,
		  {max}] ({max}を超えないように{expr}を{stride}ずつ増加させる)
		最大値が開始位置より1だけ前のときは空リストを返す。最大値が開
		始位置より1以上前のときはエラーになる。
		例: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" エラー!
<
		|method| としても使用できる: >
			GetExpr()->range()
<

readblob({fname} [, {offset} [, {size}]])			*readblob()*
		ファイル {fname} をバイナリモードで読み |Blob| を返す。
		{offset} が指定されている場合は、指定されたオフセットからファ
		イルを読み取る。負の値の場合、ファイルの終わりからのオフセット
		として使用される。例えば、最後の 12 バイトを読み取るには: >
			readblob('file.bin', -12)
<		{size} を指定すると、指定したサイズだけが読み込まれる。
		例えば、ファイルの最初の 100 バイトを読み取るには: >
			readblob('file.bin', 0, 100)
<		{size} が -1 または省略された場合は、{offset} から始まるデータ
		全体が読み込まる。
		これは、{size} が明示的に設定されている場合に、Unix 上のキャラ
		クターデバイスからデータを読み取るために使用することもできる。
		デバイスが {offset} のシークをサポートしている場合にのみ使用で
		きる。それ以外の場合はゼロにする必要がある。例えば、シリアルコ
		ンソールから 10 バイトを読み取るには: >
			readblob('/dev/ttyS0', 0, 10)
<		ファイルを開けない場合はエラーメッセージが表示され、結果は空の
		|Blob| になる。
		オフセットがファイルの末尾を超えている場合、結果は空の Blob に
		なる。
		利用可能なバイト数を超えるバイトを読み取ろうとすると、結果は切
		り捨てられる。
		|readfile()| と |writefile()| も参照。


readdir({directory} [, {expr} [, {dict}]])			*readdir()*
		{directory}内のファイル名とディレクトリ名のリストを返す。
		一致数を制限するなど、複雑なことをする必要がない場合は、
		|glob()| を使用することもできる。
		リストはソートされるが (大文字/小文字区別有り)、ソート順序を変
		更するには以下の {dict} 引数を参照すること。

		{expr}が省略されるとすべてのエントリが含まれる。
		{expr}が与えられると、それは何をすべきかをチェックするために評
		価される:
			{expr}の結果が -1 の場合、それ以上のエントリは処理され
			ない。
			{expr}の結果が 0 の場合、このエントリはリストに追加さ
			れない。
			{expr}の結果が 1 の場合、このエントリはリストに追加さ
			れる。
		"." と ".." のエントリは常に除かれる。
		{expr}が評価されるたびに "v:val" がエントリ名に設定される。
		{expr}が関数の場合、名前は引数として渡される。例えば、".txt"
		で終わるファイルのリストを取得するには、次のようにする: >
		  readdir(dirname, {n -> n =~ '.txt$'})
<		隠しファイルとバックアップファイルをスキップするには: >
		  readdir(dirname, {n -> n !~ '^\.\|\~$'})
<								*E857*
		オプションの {dict} 引数で値をよりカスタムできる。
		現時点では、実行時にソートするか、するならどのような仕方かを指
		定できる。辞書は以下のメンバーを保持できる:

		    sort    システムから返された結果をどのようにソートするか。
			    有効な値:
				"none"	    ソートしない (最速の方法)
				"case"	    大文字小文字を区別してソート (各文
					    字のバイト値、技術的には、strcmp()
					    を使用) (デフォルト)
				"icase"	    大文字小文字を区別せずソート (技術
					    的には strcasecmp() を使用)
				"collate"   "POSIX" もしくは "C" ロケール
					    |locale| の照合順序を使用してソー
					    ト
					    (技術的には strcoll() を使用)
			    他の値は警告なく無視する。

		例として、現在のディレクトリからすべてのファイルのリストを各エ
		ントリをソートせずに取得する: >
		  readdir('.', '1', #{sort: 'none'})
<		ディレクトリツリーを取得したい場合は: >
		  function! s:tree(dir)
		      return {a:dir : map(readdir(a:dir),
		      \ {_, x -> isdirectory(x) ?
		      \		 {x : s:tree(a:dir .. '/' .. x)} : x})}
		  endfunction
		  echo s:tree(".")
<
		エラー時は空のリストを返す。

		|method| としても使用できる: >
			GetDirName()->readdir()
<
readdirex({directory} [, {expr} [, {dict}]])			*readdirex()*
		|readdir()| の拡張バージョン。
		{directory} にあるファイルとディレクトリの情報を持つ辞書のリス
		トを返す。
		これはディレクトリ内のファイルとディレクトリの属性をリストアッ
		プ時に同時に取得したい時に便利である。
		これは |readdir()| を呼んだあと、各ファイルとディレクトリに対
		して |getfperm()|, |getfsize()|, |getftime()|, |getftype()|
		を呼ぶより特に MS-Windows で速い。
		このリストはデフォルトでは名前でソートされ (大文字/小文字区別
		有り)、ソートはオプションの {dict} 引数により変化する、
		|readdir()| を参照。

		ファイルとディレクトリの情報の辞書は以下の項目を持つ:
			group	エントリのグループ名。 (Unix のみ)
			name	エントリの名前。
			perm	エントリの許可属性。|getfperm()| を参照。
			size	エントリのサイズ。|getfsize()| を参照。
			time	エントリの最終更新時間。|getftime()| を参照。
			type	エントリの種別。
				Unix では、以下を除いてほぼ |getftype()| と
				同じ:
				    ディレクトリへのシンボリックリンク
							"linkd"
				    それ以外のシンボリックリンク
							"link"
				MS-Windows では:
				    通常のファイル	"file"
				    ディレクトリ	"dir"
				    ジャンクション	"junction"
				    ディレクトリへのシンボリックリンク
							"linkd"
				    それ以外のシンボリックリンク
							"link"
				    それ以外のリパースポイント
							"reparse"
			user	エントリの所有者のユーザー名。 (Unix のみ)
		Unix では、もしエントリがシンボリックリンクなら、リンク先対象
		の情報を辞書に含む(ただし、"type" 項目は除く)。
		MS-Windows では、パフォーマンス上の理由によりシンボリックリン
		ク自身の情報を含む。

		{expr}が省略されるとすべてのエントリが含まれる。
		{expr}が与えられると、それは何をすべきかをチェックするために評
		価される:
			{expr}の結果が -1 の場合、それ以上のエントリは処理され
			ない。
			{expr}の結果が 0 の場合、このエントリはリストに追加さ
			れない。
			{expr}の結果が 1 の場合、このエントリはリストに追加さ
			れる。
		"." と ".." のエントリは常に除かれる。
		{expr} を評価するごとに、|v:val| にそのエントリの辞書
		|Dictionary| を設定する。
		{expr} が関数の場合はエントリが引数として与えられる。例え
		ば、".txt" で終わるファイルのリストを取得するには、次のように
		する: >
		  readdirex(dirname, {e -> e.name =~ '.txt$'})
<
		例として、現在のディレクトリからすべてのファイルのリストを各エ
		ントリをソートせずに取得する: >
		  readdirex(dirname, '1', #{sort: 'none'})
<
		|method| としても使用できる: >
			GetDirName()->readdirex()
<

							*readfile()*
readfile({fname} [, {type} [, {max}]])
		ファイル{fname}を読み込み、各行を要素とするリスト|List|を返す。
		行はNL文字で終わるものとする。改行文字がCRであるMacintoshのファ
		イルは単一の長い行となる(どこかにNLが現れない限り)。
		すべての NUL 文字は NL 文字に置換される。
		{type}が "b" を含む場合、次のようにバイナリモードになる:
		- 最後の行がNLで終わるときは、リストの末尾に余分な空文字列が追
		  加される。
		- CR文字を除去しない。
		その他の場合:
		- NLの前に現れるCR文字を除去する。
		- 最後の行がNLで終わるかどうかは関係ない。
		- 'encoding' がUnicodeのときは UTF-8 のバイトオーダーマークは
		  取り除かれる。
		{max}を指定すると、読み込む行数の最大値となる。ファイルの最初
		の10行をチェックするときに役に立つ: >
			:for line in readfile(fname, '', 10)
			:  if line =~ 'Date' | echo line | endif
			:endfor
<		{max}が負の場合は、ファイルの最後から-{max}行を読み込んで返す。
		ファイルが{max}行以下の場合は全行を返す。
		{max}が0の場合は空リストを返す。
		Note {max}を指定しない場合はファイル全体をメモリに読み込む。エ
		ンコーディング判定も行わないことに注意。必要ならバッファに読み
		込むこと。
		非推奨 (代替として |readblob()| を使う): {type}が "B" を含む場
		合、ファイルのバイナリデータは変更せずに |Blob| が返される。
		ファイルを開けないときはエラーメッセージを表示し、空リストを返
		す。
		|writefile()|も参照。

		|method| としても使用できる: >
			GetFileName()->readfile()

reduce({object}, {func} [, {initial}])			*reduce()* *E998*
		文字列 |String|、リスト |List| もしくは |Blob| である {object}
		の各要素ごとに {func} を呼ぶ。{func} は2つの引数で呼ばれる: こ
		れまでの結果と現在の要素。全要素処理後は結果を返す。*E1132*

		{initial} は初期結果値。もし無いなら、最初の {object} の要素を
		使い {func} の最初の呼び出しは2つ目の要素から行う。{initial}
		が与えられず {object} が空の場合、結果が計算できずエラー E998
		となる。

		例: >
			echo reduce([1, 3, 5], { acc, val -> acc + val })
			echo reduce(['x', 'y'], { acc, val -> acc .. val }, 'a')
			echo reduce(0z1122, { acc, val -> 2 * acc + val })
			echo reduce('xyz', { acc, val -> acc .. ',' .. val })
<
		|method| としても使用できる: >
			echo mylist->reduce({ acc, val -> acc + val }, 0)


reg_executing()						*reg_executing()*
		実行されているレジスタの名前を 1 文字で返す。レジスタが実行さ
		れていない場合は空文字列を返す。|@| を参照。

reg_recording()						*reg_recording()*
		記録されているレジスタの名前を 1 文字で返す。記録が行われてい
		ない場合は空文字列を返す。|q| を参照。

reltime()
reltime({start})
reltime({start}, {end})					*reltime()*
		時刻値を表す値を返す。この値はリストで項目の形式はシステムに依
		存する。Vim 9 script では list<any> 型が使われる。
		この値を |reltimestr()| に渡すと文字列に変換でき、
		|reltimefloat()| に渡すと浮動小数点数に変換できる。例えば、関
		数 Work() に費やされた時間を確認するには: >
			var startTime = reltime()
			Work()
			echo startTime->reltime()->reltimestr()
<
		引数がない場合、reltime() は現在時刻を返す (表現はシステム依存
		で、壁時計の時刻としては使えない。これについては |localtime()|
		を参照)。

		1個の引数を指定すると、その引数で指定された時刻からの経過時間
		を返す。
		2個の引数を指定すると、{start}と{end}の間の経過時間を返す。

		{start}と{end}はreltime()で返される値でなければならない。旧来
		の Vim script ではエラーがあると空のリストを返すが、Vim9 script
		ではエラーとなる。

		|method| としても使用できる: >
			GetStart()->reltime()
<
		{|+reltime| 機能付きでコンパイルされたときのみ利用可能}

reltimefloat({time})				*reltimefloat()*
		{time} の値を代わりに浮動小数点で返す。
		例: >
			let start = reltime()
			call MyFunction()
			let seconds = reltimefloat(reltime(start))
<		オーバーヘッドについては reltimestr() の note を参照。
		|profiling|も参照。
		旧来の Vim script ではエラーがあると0.0を返すが、Vim9 script
		ではエラーとなる。

		|method| としても使用できる: >
			reltime(start)->reltimefloat()

<		{|+reltime| 機能付きでコンパイルされたときのみ利用可能}

reltimestr({time})				*reltimestr()*
		時刻値{time}を表現する文字列を返す。秒、ドット、マイクロ秒とい
		う形式になる。例: >
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
<		Note このコマンドにかかるオーバーヘッドがこの時間に加算される。
		精度はシステムに依存する。最高の精度 (システムによってはナノ秒)
		を得るには、reltimefloat() を使用すること。
		文字列をきれいに揃えるために、先頭にスペースが挿入される。この
		スペースを取り除くにはsplit()を使えばよい。 >
			echo split(reltimestr(reltime(start)))[0]
<		|profiling|も参照。
		旧来の Vim script ではエラーがあると空文字列を返すが、Vim9
		script ではエラーとなる。

		|method| としても使用できる: >
			reltime(start)->reltimestr()

<		{|+reltime| 機能付きでコンパイルされたときのみ利用可能}

							*remote_expr()* *E449*
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
		{string} を {server} に送信する。引数 {server} は文字列。
		|{server}| も参照。

		{string} は式と見なされ、評価した結果が返ってくる。戻り値は文
		字列かリスト |List| でなければならない。リストの場合は要素を連
		結して文字列に変換される。要素間の区切りは改行文字となる
		(join(expr, "\n")と同様)。

		空でない {idvar} が渡された場合は変数名と見なされ、後で
		|remote_read()| で使われる {serverid} がその変数に保存される。

		{timeout} が与えられた場合、読み込みはその数秒後にタイムアウト
		する。それ以外ではタイムアウトとして 600 秒が使用される。

		|clientserver| と |RemoteReply| も参照。
		|sandbox| の中ではこの関数は利用できない。
		{|+clientserver| 機能付きでコンパイルされたときのみ利用可能}
		Note: なんらかのエラーが発生した場合は、ローカルでエラーメッ
		セージが表示され、戻り値は空文字列となる。

		変数は、現在アクティブな関数とは無関係にグローバル名前空間で評
		価される。デバッグモードを除いて、関数のローカル変数および引数
		は評価されることができる。

		例: >
			:echo remote_expr("gvim", "2+2")
			:echo remote_expr("gvim1", "b:current_syntax")
<
		|method| としても使用できる: >
			ServerName()->remote_expr(expr)

remote_foreground({server})				*remote_foreground()*
		サーバー名 {server} のVimをフォアグラウンドに移動させる。
 		引数 {server} は文字列。|{server}| も参照。
		次を実行するのと同様である: >
			remote_expr({server}, "foreground()")
<		ただし、次の点が異なる: Win32では、OSが必ずしもサーバーが自分
		自身をフォアグラウンドにすることを許可しないので、対応策として
		クライアントが仕事を行う。
		Note: foreground()と違い、最小化されていたウィンドウを復元しな
		い。
		|sandbox|の中ではこの関数は利用できない。

		|method| としても使用できる: >
			ServerName()->remote_foreground()

<		{VimのWin32, Motif, GTKのGUI版とWin32コンソール版でのみ利用可
		能}


remote_peek({serverid} [, {retvar}])		*remote_peek()*
		{serverid}から文字列を取得可能ならば正の数値を返す。変数
		{retvar}に返信文字列をコピーする。{retvar}は変数の名前を示す文
		字列でなければならない。
		取得できないならば0を返す。
		なんらかの異状のときは-1を返す。
		|clientserver|も参照。
		|sandbox|の中ではこの関数は利用できない。
		{|+clientserver|機能付きでコンパイルされたときのみ利用可能}
		例: >
		    :let repl = ""
		    :echo "PEEK: " .. remote_peek(id, "repl") .. ": " .. repl

<		|method| としても使用できる: >
			ServerId()->remote_peek()

remote_read({serverid}, [{timeout}])			*remote_read()*
		{serverid}からの返信の中で最も古いものを取り出して返す。取り出
		した返信はキューから取り除かれる。キューに返信が入っていないと
		きは、{timeout} (秒単位) が与えられていない限り返信を取り出せ
		るようになるまで待機する。応答が利用できない場合、またはエラー
		時は空の文字列を返す。
		|clientserver|も参照。
		|sandbox|の中ではこの関数は利用できない。
		{|+clientserver|機能付きでコンパイルされたときのみ利用可能}
		例: >
			:echo remote_read(id)

<		|method| としても使用できる: >
			ServerId()->remote_read()
<
							*remote_send()* *E241*
remote_send({server}, {string} [, {idvar}])
		{string} を {server} に送信する。引数 {server} は文字列。
		|{server}| も参照。

		{string} はキー入力として解釈され、この関数の呼び出しは即座に
		戻ってくる。Vimサーバーにおいて、受け取ったキー入力はマッピン
		グ展開されない。|:map|

		{idvar} には変数名を指定する。後でremote_read()で使われる
		{serverid} がその変数に保存される。

		|clientserver| と |RemoteReply| も参照。
		|sandbox| の中ではこの関数は利用できない。
		{|+clientserver| 機能付きでコンパイルされたときのみ利用可能}

		Note: なんらかのエラーが発生すると、サーバー側で報告され、表示
		が乱れてしまうかもしれない。
		例: >
		:echo remote_send("gvim", ":DropAndReply " .. file, "serverid") ..
		 \ remote_read(serverid)

		:autocmd NONE RemoteReply *
		 \ echo remote_read(expand("<amatch>"))
		:echo remote_send("gvim", ":sleep 10 | echo " ..
		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
<
		|method| としても使用できる: >
			ServerName()->remote_send(keys)
<
					*remote_startserver()* *E941* *E942*
remote_startserver({name})
		サーバー {name} になる。{name} は空ではない文字列である必要が
		ある。すでにサーバーとして起動しており、|v:servername| が空で
		ない場合は失敗する。

		|method| としても使用できる: >
			ServerName()->remote_startserver()

<		{|+clientserver| 機能付きでコンパイルされたときのみ利用可能}

remove({list}, {idx})
remove({list}, {idx}, {end})				*remove()*
		{end}を指定しなかった場合: リスト |List| {list}から{idx}位置の
		要素を削除し、その要素を返す。
		{end}を指定した場合: {idx}から{end}まで(両端を含む)の要素を削
		除し、それらの要素からなるリスト |List| を返す。{idx}と{end}が
		同じ要素を指す場合、1個の要素からなるリストが返る。{end}が{idx}
		より前になる場合、エラーとなる。
		{idx}と{end}として指定できる値については|list-index|を参照。
		エラー時はゼロを返す。
		例: >
			:echo "last item: " .. remove(mylist, -1)
			:call remove(mylist, 0, 9)
<
		ファイルを削除するには |delete()| を使う。

		|method| としても使用できる: >
			mylist->remove(idx)

remove({blob}, {idx})
remove({blob}, {idx}, {end})
		{end}を指定しなかった場合: |Blob| {blob}から{idx}位置のバイト
		を削除し、そのバイトを返す。
		{end}を指定した場合: {idx}から{end}まで(両端を含む)のバイトを
		削除し、それらのバイトを |Blob| で返す。{idx}と{end}が同じバイ
		トを指す場合、1個のバイトからなる |Blob| が返る。
		{end}が{idx}より前になる場合、エラーとなる。
		エラー時はゼロを返す。
		例: >
			:echo "last byte: " .. remove(myblob, -1)
			:call remove(mylist, 0, 9)

remove({dict}, {key})
		{dict}からキー{key}を持つ要素を削除し、それを返す。例: >
			:echo "removed " .. remove(dict, "one")
<		{dict}に{key}がない場合はエラーになる。
		エラー時はゼロを返す。

rename({from}, {to})					*rename()*
		ファイルの名前を{from}から{to}へ変える。ファイルシステムを越え
		てファイルを移動するのにも使用できる。結果は数値で、成功すれば
		0、失敗すれば非ゼロになる。
		NOTE: ファイル {to} がすでに存在する場合、警告なしに上書きされ
		る。
		|sandbox|の中ではこの関数は利用できない。

		|method| としても使用できる: >
			GetOldName()->rename(newname)

repeat({expr}, {count})					*repeat()*
		{expr}を{count}回繰り返し、連結して返す。例: >
			:let separator = repeat('-', 80)
<		{count}が0または負のときは空文字列を返す。{expr}がリスト
		|List| または |Blob| の場合は{count}回連結した結果を返す。例: >
			:let longlist = repeat(['a', 'b'], 3)
<		結果は['a', 'b', 'a', 'b', 'a', 'b']となる。

		|method| としても使用できる: >
			mylist->repeat(count)


resolve({filename})					*resolve()* *E655*
		MS-Windowsでは{filename}がショートカット(.lnkファイル)ならばそ
		の指す先を単純化した形式で返す。
		{filename}がシンボリックリンクまたはジャンクションポイントの場
		合は、ターゲットへのフルパスを返す。ジャンクションのターゲット
		が削除されたら、{filename}を返す。
		Unixではパス{filename}の中の全てのシンボリックリンクを解決し、
		単純化して返す。循環リンクがある場合に備えて、シンボリックリン
		クの解決は100回までに制限されている。
		その他のシステムでは{filename}を単純化して返す。
		単純化の手順は|simplify()|と同じである。
		resolve()は(結果も相対パスであるならば)カレントディレクトリを
		表す先頭のパスコンポーネントと、末尾のパス区切り文字をそのまま
		にする。

		|method| としても使用できる: >
			GetName()->resolve()

reverse({object})					*reverse()*
		{object} 内の項目の順序を逆にする。{object} は |List|、|Blob|、
		または |String| にすることができる。リストと Blob の場合、項目
		はその場で反転され、{object} が返される。
		文字列の場合は、新しい文字列が返される。
		{object} がリスト、Blob、または文字列でない場合は、ゼロを返す。
		リストまたは Blob を変更せずに残しておきたい場合は、まずコピー
		を作成する: >
			:let revlist = reverse(copy(mylist))
<		|method| としても使用できる: >
			mylist->reverse()

round({expr})							*round()*
		{expr} を最も近い整数に丸め、|Float| を返す。{expr} が二つの整
		数の真ん中にある場合、大きい方(0 から遠い方)になる。
		{訳注: つまり四捨五入になる}
		{expr} は |Float| または |Number| に評価されなければならない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			echo round(0.456)
<			0.0  >
			echo round(4.5)
<			5.0 >
			echo round(-4.5)
<			-5.0

		|method| としても使用できる: >
			Compute()->round()

rubyeval({expr})					*rubyeval()*
		Rubyの式 {expr} を評価し、その結果を Vim のデータ構造に変換し
		たものを返す。
		数値、浮動小数点数、文字列はそのまま返される (文字列はコピーさ
		れる)。
		配列は Vim の |List| 型に変換される。
		ハッシュは Vim の |Dictionary| 型に変換される。
		それ以外のオブジェクトは "Object#to_s" メソッドの結果の文字列
		として表現される。
		Note `:def` 関数にあるローカル変数は {expr} からは見えない。

		|method| としても使用できる: >
			GetRubyExpr()->rubyeval()

<		{|+ruby| 機能つきでコンパイルされたときのみ有効}

screenattr({row}, {col})					*screenattr()*
		|screenchar()| と同様だが、属性を返す。これは他の位置の属性と
		比較するのに利用できるだけの適当な数値である。
		行または桁が範囲外の場合は -1 を返す。

		|method| としても使用できる: >
			GetRow()->screenattr(col)

screenchar({row}, {col})					*screenchar()*
		スクリーン上の位置 [row, col] の文字を数値で返す。これは全ての
		スクリーン位置、ステータスライン、ウィンドウセパレータ、コマン
		ドラインで機能する。左上の位置は行番号が1、列番号が1である。文
		字は合成文字を除く。2バイトのエンコーディングでは最初のバイト
		だけであるかもしれない。
		この関数は主にテスト用に使われる。
		row か col が範囲外である場合は -1 を返す。

		|method| としても使用できる: >
			GetRow()->screenchar(col)

screenchars({row}, {col})					*screenchars()*
		結果は数値のリスト |List|。最初の数値は |screenchar()| が返す
		数値と同一。それ以降の数値は基底文字に続く合成文字の数値。
		この関数は主にテスト用。
		row や col が範囲外である場合は空のリストを返す。

		|method| としても使用できる: >
			GetRow()->screenchars(col)

screencol()							*screencol()*
		現在のカーソルのスクリーン列を数値で返す。一番左の列番号は 1。
		この関数は主にテスト用。

		Note: 常に現在のスクリーン列を返す。したがって、コマンドで使わ
		れた場合 (例えば ":echo screencol()") は、コマンドライン内の列
		を返す (つまりコマンドが実行されたときその値は 1)。ファイル内
		でのカーソル位置を取得するには次のようなマップを使用する: >
			nnoremap <expr> GG ":echom " .. screencol() .. "\n"
			nnoremap <silent> GG :echom screencol()<CR>
			nnoremap GG <Cmd>echom screencol()<CR>
<
screenpos({winid}, {lnum}, {col})				*screenpos()*
		結果はウィンドウ {winid} のテキスト行のバッファ位置 {lnum} 及
		び列 {col} の画面位置を含む辞書。{col} は1ベースのバイトイン
		デックス。
		その辞書はこれらのメンバーを持つ:
			row 番号行
			col 最初の画面列
			endcol 最後の画面列
			curscol カーソル画面列
		指定された位置が表示されない場合、全ての値は0。
		文字が複数の画面セルを占める場合、"endcol" は "col"とは異な
		る。例えば、タブの "col" は1で "endcol" は8。
		"curscol" は、カーソルが置かれる場所。タブの場合は "endcol" と
		同じになるが、倍幅文字の場合は "col" と同じになる。
		|conceal| 機能はここでは無視され、列の数字は 'conceallevel' が
		0のときと同じになる。カーソルを正しい位置に設定して
		|screencol()| を使うことで |conceal| を考慮した値を取得できる。
		位置が閉じた折り畳みの中である場合、最初の文字の画面上の位置が
		返され、{col} は使用されない。
		{winid} が無効な場合は空の辞書を返す。

		|method| としても使用できる: >
			GetWinid()->screenpos(lnum, col)

screenrow()							*screenrow()*
		現在のカーソルのスクリーン行を数値で返す。一番上の行番号は 1。
		この関数は主にテスト用。
		代用として |winline()| を使う事ができる。

		Note: |screencol()| と同様の制約あり。

screenstring({row}, {col})					*screenstring()*
		結果は文字列で、スクリーンの位置 [row, col] の基底文字と合成文
		字全てを含む。
		|screenchars()| と似ているが文字を文字列として返す。
		この関数は主にテスト用。
		row や col が範囲外である場合は空文字列を返す。

		|method| としても使用できる: >
			GetRow()->screenstring(col)
<
								*search()*
search({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
		正規表現パターン{pattern}を検索する。検索はカーソル位置から開
		始する(検索位置を指定するには|cursor()|を使えばよい)。

		マッチが見つかった場合はその行番号を返す。
		マッチがない場合は0を返し、カーソルは移動しない。エラーメッ
		セージは表示されない。
		マッチした文字列を得るには、|matchbufline()| を使う。

		{flags} は以下のフラグ文字からなる文字列
		'b'	後方(上方)に検索する
		'c'	カーソル位置のマッチを受け入れる
		'e'	マッチの末尾へ移動する
		'n'	カーソルを移動させない
		'p'	部分パターン(後述)のマッチの番号を返す
		's'	以前のカーソル位置をマーク ' に記録する
		'w'	ファイルの末尾で循環する
		'W'	ファイルの末尾で循環しない
		'z'	0桁目からではなく、カーソル位置の桁から検索を開始する
		'w' と 'W' の両方とも指定されない場合は 'wrapscan' が適用され
		る。

		フラグ 's' が指定された場合、カーソルが移動したときのみマーク'
		が設定される。フラグ 's' は 'n' と組み合わせることはできない。

		'ignorecase', 'smartcase', 'magic' が適用される。

		フラグ 'z' が指定されない場合、常に0列目から開始して前方検索
		し、そしてカーソルの前にあるマッチはスキップされる。'cpo' 内
		に 'c' フラグが存在する場合、次の検索はそのマッチの後から始ま
		る。
		'cpo' 内に 'c' フラグが存在しない場合、次の検索は現在のカー
		ソル位置から1桁進んで始まる。この検索はオーバーラップしてマッ
		チする。'c' フラグが存在しない場合、次の検索はマッチの開始から
		1 桁後に開始される。これは重複する一致の場合に重要である。
		|cpo-c| を参照。"\ze" を挿入してマッチの終了位置を変更すること
		もできる。|/\ze| を参照。

		後方検索でフラグ 'z' が指定されている場合、検索は0列目から始ま
		るので、現在行で見付かってもマッチしない(ただしファイルの末
		尾でラップしない場合)。

		引数{stopline}が指定されたときはこの行を検索した後で検索を停止
		する。これは検索する行を制限するために有用である。例: >
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		{stopline}に0でない値が指定されたときは、暗黙にファイルの末尾
		で循環しなくなる。
		0 の値は、引数を省略したときと同じになる。
				*E1285* *E1286* *E1287* *E1288* *E1289*
		{timeout} が指定された場合、そのミリ秒が経過したところで検索が
		停止する。つまり、{timeout} が 500 なら検索は 500 ミリ秒で停止
		する。
		この値は負であってはならない。0 の値は、引数を省略したときと同
		じになる。
		{|+reltime| 機能つきでコンパイルされたときのみ有効}

		{skip} 式が与えられたなら、カーソルがマッチの最初に位置した状
		態で評価される。評価結果が非0ならマッチがスキップされる。これ
		は例えば、コメントや文字列でマッチをスキップするのに使う。
		{skip} は、式として評価される文字列か、関数参照もしくはラムダ
		の式が使える。
		{skip} が無いもしくは空のとき、すべてのマッチを受け入れる。
		{skip} の評価においてエラーとなった時は検索を中断し -1 を返す。
							*search()-sub-match*
		フラグ 'p' を指定すると、戻り値は \(\) によるグループ化のうち
		最初にマッチしたものの番号プラス 1 となる。パターン全体はマッ
		チしたがどのグループもマッチしなかったときは 1 を返す。
		桁番号を取得するには|searchpos()|を使う。

		フラグ 'n' が指定されていない場合、マッチ位置にカーソルが移動
		する。

		例 (引数リストの全ファイルにわたって検索して置換する): >
		    :let n = 1
		    :while n <= argc()   " arglist中の全ファイルに対してループ
		    :  exe "argument " .. n
		    :  " ファイルの最後の文字から開始し、循環してファイルの
		    :  " 最初から検索する
		    :  normal G$
		    :  let flags = "w"
		    :  while search("foo", flags) > 0
		    :    s/foo/bar/g
		    :	 let flags = "W"
		    :  endwhile
		    :  update	    " 修正されていればファイルを保存する
		    :  let n = n + 1
		    :endwhile
<
		フラグの使い方の例: >
		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
<		このコマンドは、カーソル下の文字以降からキーワード "if",
		"else", "endif" のいずれかを検索する。フラグ 'p' により、どの
		キーワードが見つかったかに応じて1,2,3を返す。見つからなかった
		ときは0を返す。次の行の最初の単語にカーソルをおいて上のコマン
		ドを実行すると:
		    if (foo == 0) | let foo = foo + 1 | endif ~
		1が返る。フラグ 'c' を外すと "endif" にマッチし3を返すようにな
		る。カーソルを "if" の "f" の上におき、フラグ 'e' を外して実行
		しても同じく3が返る。フラグ 'n' によりカーソルは移動しない。

		|method| としても使用できる: >
			GetPattern()->search()

searchcount([{options}])					*searchcount()*
		最後の検索数の取得もしくは更新をする。'shortmess' で "S" 無し
		で表示されるのと同等の結果が得られる。'shortmess' で "S" あり
		の場合でも動作する。

		辞書 |Dictionary| を返す。この辞書は前の{訳註:検索}パターンが
		設定されてなく、{訳註:オプショナル引数の辞書の} "pattern" が指
		定されてないと空になる。

		  キー		型		意味 ~
		  current	|Number|	マッチの現在の位置; カーソル位
						置が最初のマッチより前にあると0
		  exact_match	|Boolean|	"current" が "pos" でマッチし
						ているなら1、そうでないなら0
		  total		|Number|	見付けたマッチのトータル数
		  incomplete	|Number|	0: 検索が完了した
						1: 再計算がタイムアウトした
						2: 最大数を超えた

		{options} についてはさらに以下を参照。

		|n| や |N| を押下したときの最後の検索カウントを取るには、この
		関数を `recompute: 0` で呼ぶ。|n| と |N| の最大カウントが 99
		であるため、時として正しくない情報を返すことがある。もし 99 を
		超える時は結果が最大カウント+1(100)でなくてはならない。もし正
		しい情報を取得したいのであれば、`recompute: 1` を指定する: >

			" 多量にマッチする場合、 result == maxcount + 1 (100)
			" になる
			let result = searchcount(#{recompute: 0})

			" 以下は正しい結果を返す(recompute はデフォルトで 1)
			let result = searchcount()
<
		この関数は 'statusline' にカウントを追加するのに便利である: >
			function! LastSearchCount() abort
			  let result = searchcount(#{recompute: 0})
			  if empty(result)
			    return ''
			  endif
			  if result.incomplete ==# 1     " タイムアウト
			    return printf(' /%s [?/??]', @/)
			  elseif result.incomplete ==# 2 " 最大数を超過
			    if result.total > result.maxcount &&
			    \  result.current > result.maxcount
			      return printf(' /%s [>%d/>%d]', @/,
			      \		    result.current, result.total)
			    elseif result.total > result.maxcount
			      return printf(' /%s [%d/>%d]', @/,
			      \		    result.current, result.total)
			    endif
			  endif
			  return printf(' /%s [%d/%d]', @/,
			  \		result.current, result.total)
			endfunction
			let &statusline ..= '%{LastSearchCount()}'

			" もしくは 'hlsearch' がオンのときのみカウントを表示し
			" たいのであれば
			" let &statusline ..=
			" \   '%{v:hlsearch ? LastSearchCount() : ""}'
<
		もし検索カウントの更新もしたいのであれば、|CursorMoved| か
		|CursorMovedI| の自動コマンドを使うのが便利である: >

			autocmd CursorMoved,CursorMovedI *
			  \ let s:searchcount_timer = timer_start(
			  \   200, function('s:update_searchcount'))
			function! s:update_searchcount(timer) abort
			  if a:timer ==# s:searchcount_timer
			    call searchcount(#{
			    \ recompute: 1, maxcount: 0, timeout: 100})
			    redrawstatus
			  endif
			endfunction
<
		また、カレントバッファで "pattern" を使い指定パターンにマッチ
		したテキストのカウントを使いたいのならば:  >

			" このバッファでの '\<foo\>' のカウント
			" (Note 検索カウントもまた更新される)
			let result = searchcount(#{pattern: '\<foo\>'})

			" 古いパターンの古い検索カウントに戻すには再度検索する
			call searchcount()
<
		{options} は辞書 |Dictionary| でなくてはならない。これらを含め
		られる:
		  キー		型		意味 ~
		  recompute	|Boolean|	もし |TRUE| なら、|n| か |N|
						を実行されたかのようにカウント
						を再計算する。
						そうでないなら、最後に計算した
						結果を返す (|n| か |N| を
						'shortmess' に "S" を入れない
						で実行、もしくはこの関数を呼ん
						だ時)
						(デフォルト: |TRUE|)
		  pattern	|String|	|@/| と違う値が与えられたとき
						に再計算される。これは以下のコ
						マンドをこの関数の呼び出し前に
						実行したのと同じ動作になる >
						  let @/ = pattern
<						(デフォルト: |@/|)
		  timeout	|Number|	0 か負数の場合タイムアウトしな
						い。再計算でのmsecのタイムアウ
						ト値
						(デフォルト: 0)
		  maxcount	|Number|	0 もしくは負数で制限なし。
						結果の再計算におけるマッチの最
						大カウント。
						もし検索の総計カウントが到達し
						たら "total" の値が maxcount +
						1 になる
						(デフォルト: 99)
		  pos		|List|		`[lnum, col, off]` 値
						再計算の値。
						"current" の結果の値を更新する。
						|cursor()|、 |getpos()| を参照
						(デフォルト: カーソルの位置)

		|method| としても使用できる: >
			GetSearchOpts()->searchcount()
<
searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
		{name}の宣言を検索する。

		{global}が0でないときは|gD|と同じようにファイル中の最初のマッ
		チを探す。そうでないときは|gd|と同じ動作になり、現在の関数内か
		ら最初のマッチを探す。

		{thisblock}が0でないときはカーソル位置より前の位置で閉じている
		{}ブロックを無視し、そのスコープ内でだけ有効な変数宣言にマッチ
		しないようになる。

		マッチを見つけるとその位置へカーソルを移動する。
		成功すると0を返し、失敗すると非0を返す。
		例: >
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<
		|method| としても使用できる: >
			GetName()->searchdecl()
<
							*searchpair()*
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		ネストしたstart・endのペアを検索する。これを使うと、"if" に対
		応する "endif" を見つけることができる。それらの間にある他のif・
		endifのペアは無視される。
		検索はカーソル位置から開始する。デフォルトでは下方に検索する。
		{flags}に 'b' が含まれていると上方に検索する。
		マッチが見つかると、その位置へカーソルを移動し、行番号を返す。
		マッチが見つからなかったときは0または-1を返し、カーソルは移動
		しない。エラーメッセージは表示されない。

		{start}、{middle}、{end}は正規表現である。|pattern|を参照。こ
		の正規表現に \( \) のペアを含めてはならない。\%( \) は含めても
		よい。{middle}はネストしたstart・endペアの中にないときのみマッ
		チする。典型的な使用例: >
			searchpair('\<if\>', '\<else\>', '\<endif\>')
<		ここで{middle}を空にすると "else" をスキップするようになる。

		{flags}には|search()|と同様に 'b', 'c', 'n', 's', 'w', 'W' が
		使える。それに加えて以下のフラグが利用できる。
		'r'	それ以上マッチが見つからなくなるまで繰り返す。つまり最
			も外側のペアを探す。'W' も自動的にオンになる。
		'm'	マッチ位置の行番号でなくマッチの個数を返す。'r' を使っ
			ているときは > 1 となる。
		Note: ほとんど常に 'W' を使ってファイルの末尾で循環しないよう
		にするのがよい考えである。

		{start}、{middle}、{end}のマッチが見つかると、マッチの開始位置
		にカーソルを移動し、式{skip}を評価する。このマッチがコメントや
		文字列の内側にある場合など、無視したいものであれば式{skip}が
		非0を返すようにする。
		{skip}を省略した、または空のときはどのマッチも無視しない。
		{skip}を評価している最中にエラーが発生すると、検索は異常終了し
		-1を返す。
		{skip} は、文字列、ラムダ、関数参照もしくは部分適用のいずれか
		である。それ以外の場合、関数は失敗する。
		`:def` 関数内では引数 {skip} が文字列定数の場合、命令の中にコ
		ンパイルされる。

		{stopline} と {timeout} については|search()|を参照。

		'ignorecase' の値が適用される。'magic' の値は無視され、オンの
		ときと同じ様に動作する。

		検索はカーソル位置から開始する。検索方向の次の文字における
		{start}、{middle}、{end}のマッチが最初に見つかる。例: >
			if 1
			  if 2
			  endif 2
			endif 1
<		カーソルが "if 2" の "i" の上にある状態から下方に検索を開始す
		ると "endif 2" にマッチする。"if 2" の直前の文字の上から検索を
		開始すると "endif 1" にマッチする。これは、"if 2" が最初に見つ
		かり、"if 2" から "endif 2" までがネストしたペアと見なされるた
		めである。上方検索で、{end}が2文字以上であるときはパターンの最
		後に "\zs" をつけるとよいかもしれない。するとカーソルがendの
		マッチの内側にあるとき、対応するstartを見つけるようになる。

		例: Vim script の "endif" コマンドを見つけるには: >

	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

<		これを使うには、マッチを見つけたい "if" の上、またはそれ以降に
		カーソルを置くこと。Note バックスラッシュを二重にしなくてもよ
		いようにシングルクォート文字列を使っている。式skipにより、コメ
		ントだけの行を無視するようにしている。コマンドの後のコメントは
		無視していない。また、行の途中の "en" や "if" という単語にマッ
		チしてしまう。
		もう1つの例: "}" に対応する "{" を検索する: >

	:echo searchpair('{', '', '}', 'bW')

<		これを使うには、マッチを見つけたい "}" の上、または前にカーソ
		ルを置くこと。構文ハイライトにより文字列と見なされるマッチを無
		視するには次のようにする: >

	:echo searchpair('{', '', '}', 'bW',
	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<
							*searchpairpos()*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		|searchpair()|と同様だが、マッチの行番号と桁番号からなるリスト
		|List|を返す。このリストの最初の要素は行番号で、次の要素はマッ
		チの桁位置のバイトインデックスである。マッチが見つからなかった
		場合は[0, 0]を返す。 >

			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		より大規模で役に立つ例に関しては|match-parens|を参照。

							*searchpos()*
searchpos({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
		|search()|と同様だが、マッチの行番号と桁番号からなるリスト
		|List|を返す。このリストの最初の要素は行番号で、次の要素はマッ
		チの桁位置のバイトインデックスである。マッチが見つからなかった
		場合は[0, 0]を返す。
		例: >
	:let [lnum, col] = searchpos('mypattern', 'n')

<		フラグ 'p' を指定すると、戻り値にサブパターンのマッチ番号を示
		す要素が加わる|search()-sub-match|。例: >
	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		この例において、"submatch" は小文字|/\l|が見つかったとき2とな
		り、大文字|/\u|が見つかったとき3となる。

		|method| としても使用できる: >
			GetPattern()->searchpos()

server2client({clientid}, {string})			*server2client()*
		{clientid}に返信文字列を送る。最後に文字列を送った{clientid}は
		expand("<client>")で取得できる。
		{|+clientserver|機能付きでコンパイルしたときのみ利用可能}
		成功で0を返し、失敗で-1を返す。
		Note:
		このIDは次のコマンドを受け取る前に取得しなければならない。つま
		り、受け取ったコマンドから戻る前で、入力を待つコマンドを呼ぶ前。
		|clientserver|も参照。
		例: >
			:echo server2client(expand("<client>"), "HELLO")

<		|method| としても使用できる: >
			GetClientId()->server2client(string)
<
serverlist()					*serverlist()*
		利用可能なサーバー名のリストを返す。1行に1つの形式。
		サーバーが1つもないとき、または情報を取得できないときは空文字
		列を返す。|clientserver|も参照。
		{|+clientserver|機能付きでコンパイルしたときのみ利用可能}
		例: >
			:echo serverlist()
<
setbufline({buf}, {lnum}, {text})			*setbufline()*
		バッファ {buf} の行 {lnum} を {text} に設定する。これは特定の
		バッファに対し、|setline()| のように機能する。

		この関数は、ロードされたバッファに対してのみ機能する。必要であ
		れば、最初に |bufload()| を呼び出すこと。

		行を挿入する場合には |appendbufline()| を使用する。
		{lnum} 内のテキストプロパティはすべて消去される。

		{text} は、1行を設定する文字列、または複数行を設定する文字列の
		リストである。リストが最後の行の下にある場合、それらの行が追加
		される。リストが空の場合は何も変更されず、ゼロが返される。

		{buf} の使い方については前述の |bufname()| を参照。

		{lnum} は |setline()| と同様に扱われる。
		"$" を使うことでバッファ {buf} の最終行を参照できる。
		{lnum} が最後の行のすぐ下にある場合、{text} は最後の行の下に追
		加される。

		{buf} が有効なバッファでない場合、バッファがロードされないか、
		{lnum} が無効な場合は 1 が返される。|Vim9| script ではエラーに
		なる。
		成功すると 0 が返される。

		|method| としても使用でき、ベースは第3引数として渡される: >
			GetText()->setbufline(buf, lnum)

setbufvar({buf}, {varname}, {val})			*setbufvar()*
		バッファ{buf}のオプションまたはローカル変数{varname}に{val}を
		代入する。
		グローバル・ウィンドウローカルオプションに対しても動作するが、
		グローバル・ウィンドウローカル変数に対しては動作しない。
		ウィンドウローカルオプションの場合、グローバルな値は変更されな
		い。
		{buf}の解釈の仕方については|bufname()|を参照。
 		引数 {varname} は文字列。
		Note 変数名には "b:" をつけてはならない。
		例: >
			:call setbufvar(1, "&mod", 1)
			:call setbufvar("todo", "myvar", "foobar")
<		サンドボックスの中ではこの関数は使用できない。

		|method| としても使用でき、ベースは第3引数として渡される: >
			GetValue()->setbufvar(buf, varname)


setcellwidths({list})					*setcellwidths()*
		指定した文字範囲のセル幅を上書きする。これは、端末に表示される
		時の文字の幅が画面のセルで数えてどれだけになるかを Vim に教え
		るのに使う。これは 'ambiwidth' を上書きする。例: >
		   call setcellwidths([
				\ [0x111, 0x111, 1],
				\ [0x2194, 0x2199, 2],
				\ ])

<		引数 {list} は3つの数字を持つリストのリスト:
		[{low}, {high}, {width}]。	*E1109* *E1110*
		{low} と {high} は同じにすることもできる。その場合、これは 1
		つの文字を指す。それ以外の場合は、{low} から {high} (両端を含
		む) までの文字の範囲になる。		*E1111* *E1114*
		値が 0x80 以上の文字だけを使用できる。

		{width} は、画面セル内の文字幅を示す 1 または 2 のいずれかでな
		ければならない。			*E1112*
		引数が無効な場合や、範囲が他の範囲と重なっている場合もエラーが
		発生する。				*E1113*

 		新しい値が原因で 'fillchars' か 'listchars' が無効になる場合
 		は、拒否されてエラーになる。

		空の {list} を渡すことで上書きがクリアされる: >
		   setcellwidths([]);

<		既知の絵文字への効果を確認するのに
		$VIMRUNTIME/tools/emoji_list.vim スクリプトが使える。テキスト
		内でカーソルを移動して、端末のセル幅が各絵文字について Vim が
		認識している内容とマッチするかどうかを確認する。正しく見えない
		場合は、{list} 引数を調整する必要がある。


setcharpos({expr}, {list})				*setcharpos()*
		|setpos()| と同様だが指定に使う桁番号はその行のバイトインデッ
		クスの代わりに文字インデックスである。

		例:
		8行目にテキスト "여보세요" がある状態: >
			call setcharpos('.', [0, 8, 4, 0])
<		4番目の文字 '요' へカーソルを位置させる。 >
			call setpos('.', [0, 8, 4, 0])
<		2番目の文字 '보' へカーソルを位置させる。

		|method| としても使用できる: >
			GetPosition()->setcharpos('.')

setcharsearch({dict})					*setcharsearch()*
		現在の文字検索の情報を{dict}に設定する。
		この辞書は下記のエントリを1以上持つ:

		    char	続いて起こる|,|や|;|コマンドで使われる文字。
				空文字列の場合、文字検索を解除する。
		    forward	文字検索の方向。1は前方、0は後方。
		    until	文字検索の種類。1は|t|もしくは|T|の文字検索、0は
				|f|もしくは|F|の文字検索。

		これはユーザーの文字検索のセーブ/リストアを使うことができる: >
			:let prevsearch = getcharsearch()
			:" ユーザーの検索に影響を与えるコマンドを実行する。
			:call setcharsearch(prevsearch)
<		|getcharsearch()|も参照。

		|method| としても使用できる: >
			SavedSearch()->setcharsearch()

setcmdline({str} [, {pos}])					*setcmdline()*
		コマンドラインを {str} に設定し、カーソル位置を {pos} に設定す
		る。
		{pos} を省略した場合、カーソルはテキストの後に配置される。
		成功した場合は 0 を返し、コマンドラインを編集していない場合は
		1 を返す。

		|method| としても使用できる: >
			GetText()->setcmdline()

setcmdpos({pos})					*setcmdpos()*
		コマンドラインの{pos}バイトの位置へカーソルを移動する。
		{pos}は1から始まる。
		現在の位置を取得するには|getcmdpos()|を使う。
		コマンドラインを編集している最中のみ機能する。よって、
		|c_CTRL-\_e|、|c_CTRL-R_=|、|c_CTRL-R_CTRL-R|＋ '=' と組み合
		わせて使うときだけ意味がある。|c_CTRL-\_e|と|c_CTRL-R_CTRL-R|
		＋ '=' の場合、コマンドラインにその式をセットした後でカーソル
		を移動する。|c_CTRL-R_=|の場合、式を評価した後、結果のテキスト
		を挿入する前にカーソルを移動する。
		{pos}が大きすぎるときは行末にカーソルを移動する。{pos}が1より
		小さいときの結果は未定義である。
		成功なら偽、コマンドラインを編集しているとき以外には真を返す。
		成功した場合は 0 を返し、コマンドラインを編集していない場合は
		1 を返す。

		|method| としても使用できる: >
			GetPos()->setcmdpos()

setcursorcharpos({lnum}, {col} [, {off}])		*setcursorcharpos()*
setcursorcharpos({list})
		|cursor()| と同様だが指定に使う桁番号はその行のバイトインデッ
		クスの代わりに文字インデックスである。

		例:
		4行目にテキスト "여보세요" がある状態: >
			call setcursorcharpos(4, 3)
<		3番目の文字 '세' へカーソルを位置させる。 >
			call cursor(4, 3)
<		1番目の文字 '여' へカーソルを位置させる。

		|method| としても使用できる: >
			GetCursorPos()->setcursorcharpos()


setenv({name}, {val})						*setenv()*
		環境変数{name} に {val} を設定する。例: >
			call setenv('HOME', '/home/myhome')

<		{val} が |v:null| の場合は、環境変数は削除される。
		|expr-env| も参照。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetPath()->setenv('PATH')

setfperm({fname}, {mode})				*setfperm()* *chmod*
		{fname} のファイル許可属性を {mode} に設定する。
		{mode} は9文字の文字列でなければならない。形式は "rwxrwxrwx"
		であり、それぞれはファイルの所有者権限、グループ権限、その他
		のユーザーを表す "rwx" というフラグのグループである。文字 "-"
		は許可属性がオフであり、その他の文字はオンである。マルチバイト
		文字はサポートされない。

		例えば "rw-r-----" はそのユーザーの読み書き、グループでは読み
		取り専用、その他のユーザーはアクセス不可である。"xx-x-----" は
		同じ意味となる。

		成功するとゼロ以外を返し、失敗するとゼロを返す。

		|method| としても使用できる: >
			GetFilename()->setfperm(mode)
<
		許可属性の読み取りについては|getfperm()|を参照。


setline({lnum}, {text})					*setline()*
		カレントバッファの{lnum}行目を{text}にする。行を挿入したい場合
		は |append()| を使う。別のバッファの行を変更したい場合は
		|setbufline()| を使う。{lnum}内のテキストプロパティはすべて消
		去される。

		{lnum}は|getline()|のときと同じように解釈される。
		{lnum}が最後の行の次の行の場合、最後の行の下に{text}が追加され
		る。
		{text}は任意の型もしくは任意の型のリストで、各要素が文字列に変
		換される。{text} が空のリストの場合、何も変更されず、偽が返さ
		れる。

		成功したら偽を返す。失敗したら(大抵{lnum}が無効な値のとき)真を
		返す。
		{lnum}が無効な値のとき |Vim9| script ではエラーになる。

		例: >
			:call setline(5, strftime("%c"))

<		{text}がリスト|List|の場合、{lnum}行目とそれ以降の行にリストの
		要素をセットする。例: >
			:call setline(5, ['aaa', 'bbb', 'ccc'])
<		上の例は次と同値である: >
			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
			:  call setline(n, l)
			:endfor

<		Note: マーク '[ と '] はセットされない。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetText()->setline(lnum)

setloclist({nr}, {list} [, {action} [, {what}]])		*setloclist()*
		ウィンドウ{nr}のlocationリストを作成・置き換え・追加する。
		{nr} にはウィンドウ番号または|window-ID|が使える。
		{nr}が0のときはカレントウィンドウを対象にする。

		locationリストウィンドウの場合、そこに表示しているlocationリス
		トが修正される。ウィンドウ番号{nr}が無効な場合、-1を返す。それ
		以外は |setqflist()| と同じ。
		|location-list| も参照。

		{action} については |setqflist-action| を参照。

		オプショナル引数の辞書 {what} が提供される場合、{what} で指定
		されるアイテムのみが設定される。サポートされる {what} の一覧は
		|setqflist()|を参照。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetLoclist()->setloclist(winnr)

setmatches({list} [, {win}])				*setmatches()*
		|getmatches()| で取得したマッチのリストを復元する。成功なら 0、
		失敗なら -1 を返す。リストを復元するに先立って、現在のマッチは
		すべて消去される。|getmatches()| の例を参照。
		{win} が指定されれば、カレントウィンドウではなく指定されたウィ
		ンドウあるいはウィンドウID を対象にする。

		|method| としても使用できる: >
			GetMatches()->setmatches()
<
							*setpos()*
setpos({expr}, {list})
		文字列{expr}の位置を設定する。有効な値は次の通り:
			.	カーソル位置
			'x	マーク x

		{list} は 4 個か 5 個の要素を持つリスト|List|である:
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]

		"bufnum" はバッファ番号。0にするとカレントバッファを表す。大文
		字のマークを設定するとき、"bufnum" はマーク位置として用いられ
		る。それ以外のマークの場合、"bufnum" はマークを設定するバッファ
		を指定する。関数|bufnr()|を使ってファイル名をバッファ番号に変
		換することができる。
		カーソルと ' マークを設定する場合、バッファ番号は無視される。
		なぜならそれらはバッファではなくウィンドウに関連付けられている
		からである。
		ジャンプリストは変更されない。

		"lnum" と "col" はバッファ内の位置。桁番号は1から始まる。
		"lnum" を 0 にするとそのマークを削除する。"col" が 1 より小さ
		いときは 1 が使われる。バイトでのカウントではなく文字でのカウ
		ントを使いたいなら、|setcharpos()| を使う。

		数値 "off" は 'virtualedit' がオンのときのみ使われ、その文字の
		開始位置からの画面上の桁のオフセットとなる。例えば、<Tab>の中、
		または最後の文字より後に設定したいときに使う。

		"curswant" はカーソル位置を設定するときのみ使われる。これは縦
		方向移動の優先的列番号である。"curswant" を指定しなかった場合
		は優先値は設定されない。マークの位置を設定するときに
		"curswant" を指定した場合はその値は使用されない。

		Note: '< と '> の行番号を変更した場合は '< が '> の手前にくる
		ように位置が交換される。

		位置をセットできたときは 0 を、そうでなければ -1 を返す。
		{expr} が無効なときはエラーメッセージが出る。

		|setcharpos()|、|getpos()| と |getcurpos()| も参照。

		縦方向移動の優先的列番号は復元されない。これを使ってカーソル位
		置を設定した場合は、|j| や |k| で移動すると以前の列にジャンプす
		るだろう！優先的列番号も併せて設定するには |cursor()| を使うこ
		と。|winrestview()| の "curswant" キーも参照。

		|method| としても使用できる: >
			GetPosition()->setpos('.')


setqflist({list} [, {action} [, {what}]])		*setqflist()*
		quickfixリストを作成、置き換え、もしくはリストへの追加を行う。

		オプショナル引数の辞書 {what} が提供される場合、{what} で指定
		されるアイテムのみが設定される。最初の {list} は無視される。
		{what} でサポートされる項目については以下を参照。
							*setqflist-what*
		{what} が存在しない場合、{list} 内の要素が使用される。各要素は
		辞書であること。辞書でない {list} の要素は無視される。各辞書は
		以下の要素を持つ:

		    bufnr	バッファ番号。有効なバッファ番号でなければなら
				ない。
		    filename	ファイル名。"bufnr" がないとき、または無効であ
				るときのみ使われる。
		    module	モジュール名; 与えられた場合はファイル名の代わ
				りに quickfix エラーウィンドウ内で使用される。
		    lnum	ファイル中の行番号
		    end_lnum	複数行の時の最後の行番号
		    pattern	エラーの位置を特定するための検索パターン
		    col		桁番号
		    vcol	0でない場合: "col" は表示上の桁
				0の場合: "col" はバイトインデックス
		    end_col	複数桁の時の最後の桁番号
		    nr		エラー番号
		    text	エラーの説明
		    type	エラータイプを示す1文字。'E', 'W' など。
		    valid	エラーメッセージが認識されている
		    user_data   要素に関連付けられたカスタムデータは、任意の型
				にすることができる。

		辞書の要素 "col"、"vcol"、"nr"、"type"、"text" は省略可能であ
		る。"lnum" か "pattern" のどちらか一方のみがエラー行を特定する
		ために使われる。"filename" と "bufnr" の両方ともない場合、また
		は "lnum" と "pattern" の両方ともない場合、その要素はエラー行
		として扱われない。"pattern" と "lnum" の両方があるときは
		"pattern" が使われる。
		要素 "valid" が与えられていない場合、"bufnr" が有効なバッファ
		であるか、もしくは "filename" が存在するときには有効フラグが設
		定される。
		{list} に空のリストを指定すると quickfix リストはクリアされ
		る。
		このリストは|getqflist()|が返すものと正確に同じではないことに
		注意。

		{action} の値:			*setqflist-action* *E927*
		'a'	{list} の要素を既存のquickfixリストに追加する。
			quickfixリストがまだ存在しない場合は新規に作成される。

		'r'	{list} の要素で現在のquickfixリストを置き換える。これ
			はリストをクリアするのにも使える: >
				:call setqflist([], 'r')
<
		'f'	quickfix スタック内のすべての quickfix リストが解放さ
			れる。

		{action}が指定されないとき、または ' ' のときは新しい quickfix
		リストを作成する。新しい quickfix リストは、スタック内の現在の
		quickfix リストと、続くすべてのリストが解放された後に追加され
		る。新しい quickfix リストをスタックの最後に追加する場合には、
		{what} 内の "nr" に "$" を設定する。

		{what} の辞書では以下のアイテムを指定する事ができる:
		    context	quickfix リストコンテキスト。
				|quickfix-context| を参照
		    efm		"lines" からテキストをパースするときに使うエ
				ラーフォーマット。存在しない場合はオプション
				'errorformat' の値が使用される。
				|quickfix-parse| を参照
		    id		quickfix リスト識別子 |quickfix-ID|
		    idx		'id' または 'nr' で指定されたquickfixリスト内
				の現在のエントリのインデックス。'$' に設定する
				と、リストの最後のエントリが現在のエントリとし
				て設定される。|quickfix-index| を参照。
		    items	quickfix エントリのリスト。引数 {list} と同じ。
		    lines	行のリストをパースするのに 'errorformat' を使
				用し、結果のエントリを quickfix リスト {nr} も
				しくは {id} に加える。|List| 値だけがサポート
				される。|quickfix-parse| を参照
		    nr		quickfix スタックでのリスト番号; 0 は現在の
				quickfix リストを意味し、"$" は最後の quickfix
				リストを意味する。
		    quickfixtextfunc
				quickfixウィンドウでの表示テキストを取得する関
				数。この値は関数名もしくはfuncrefもしくはラム
				ダ。関数の書き方と例の説明については
				|quickfix-window-function| を参照。
		    title	quickfix リストのタイトルテキスト。
				|quickfix-title| を参照
		{what} 内でのサポートされていないキーは無視される。
		"nr" 番目のアイテムが提供されていない場合は現在の quickfix リ
		ストが変更される。新しい quickfix リストを作成するときは、"nr"
		に quickfix スタックサイズより 1 大きい値を設定することができ
		る。quickfix リストを変更するときには、正しいリストが変更され
		ることを保証するために、リストの指定には "nr" ではなく "id" が
		使用されるべきである。

		例 (|setqflist-examples| も参照): >
		   :call setqflist([], 'r', {'title': 'My search'})
		   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
		   :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})
<
		成功なら0、失敗なら-1を返す。

		この関数は 'errorformat' の設定とは無関係にquickfixリストを作
		るために使える。その最初のエラーへジャンプするには `:cc 1` な
		どのコマンドを使う。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetErrorlist()->setqflist()
<

							*setreg()*
setreg({regname}, {value} [, {options}])
		レジスタ{regname}に{value}をセットする。
		{regname} が "" もしくは "@" のとき、無名レジスタ '"' を使う。
		引数 {regname} は文字列。|Vim9-script| では {regname} は1文字
		でなくてはならない。

		{value} には |getreg()| か |getreginfo()| の戻り値ならどんな値
		でも (リスト |List| でも 辞書 |Dictionary|でも) 指定できる。
		{options}が "a" を含んでいるとき、または{regname}が大文字のと
		きは、その値に追加する。

		{options}は以下のレジスタの種類指定を含んでもよい:
		    "c" または "v"	      |characterwise| モード
		    "l" または "V"	      |linewise| モード
		    "b" または "<CTRL-V>"     |blockwise-visual| モード
		"b" または "<CTRL-V>" の直後に数値を続けると、それが選択範囲の
		幅となる。これを指定しない場合、選択範囲の幅は一番長い行の文字
		数となる(<Tab>は1文字と数えられる)。

		{options} にレジスタの設定が何も含まれていないときのデフォルト
		値は文字モードである。ただし、{value} が文字列で末尾が <NL> の
		場合や {value} がリストの場合は行モードになる。矩形モードは明
		示的に指定しない限り選択されない。
		成功なら0、失敗なら非0を返す。

							*E883*
		Note: 検索レジスタや式レジスタを設定するときは複数の要素を含ん
		      だリスト (|List|) を指定することはできない。空のリストは
		      空文字列と同様に扱われる。

		例: >
			:call setreg(v:register, @*)
			:call setreg('*', @%, 'ac')
			:call setreg('a', "1\n2\n3", 'b5')
			:call setreg('"', { 'points_to': 'a'})

<		次の例は、この関数を使ってレジスタを退避・復元する例である: >
			:let var_a = getreginfo()
			:call setreg('a', var_a)
<		もしくは: >
			:let var_a = getreg('a', 1, 1)
			:let var_amode = getregtype('a')
			    ....
			:call setreg('a', var_a, var_amode)
<		Note: |getreg()| の 3 番目の引数を使用せずにレジスタの内容を完
		全に復元することはできない。改行文字と Nul 文字がどちらも改行
		文字として表現されてしまうため。|NL-used-for-Nul| 参照。

		空文字列を追加すると、レジスタの種類を変更することができる: >
			:call setreg('a', '', 'al')

<		|method| としても使用でき、ベースは第2引数として渡される: >
			GetText()->setreg('a')

settabvar({tabnr}, {varname}, {val})			*settabvar()*
		タブページ {tabnr} のタブローカル変数 {varname} を {val} に設
		定する。|t:var|
 		引数 {varname} は文字列。
		Note 自動コマンドがブロックされ、副作用が発生しない可能性があ
		る。例えば、'filetype' を設定する時。
		Note: 指定する変数名は "t:" を除いた名前。
		タブの番号は 1 から始まる。
		この関数はサンドボックス (|sandbox|) の中では使えない。

		|method| としても使用でき、ベースは第3引数として渡される: >
			GetValue()->settabvar(tab, name)

settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
		ウィンドウ{winnr}のオプションやローカル変数{varname}の値を
		{val}にセットする。
		タブ番号は1から始まる。カレントタブページを対象とする場合は
		|setwinvar()|を使う。
		{winnr} にはウィンドウ番号または|window-ID|が使える。
		{winnr}が0のときはカレントウィンドウが対象となる。
		Note 自動コマンドがブロックされ、副作用が発生しない可能性があ
		る。例えば、'filetype' または 'syntax' を設定する時。グローバ
		ルオプションやバッファローカルオプションを設定することもできる
		が、グローバル変数やバッファローカル変数を設定することはできな
		い。
		バッファローカルオプションを設定した場合、グローバル値は変更さ
		れない。
		Note 変数名には "w:" をつけてはならない。
		例: >
			:call settabwinvar(1, 1, "&list", 0)
			:call settabwinvar(3, 2, "myvar", "foobar")
<		この関数は|sandbox|の中では使用できない。

		|method| としても使用でき、ベースは第4引数として渡される: >
			GetValue()->settabwinvar(tab, winnr, name)

settagstack({nr}, {dict} [, {action}])			*settagstack()*
		{dict}を使用してウィンドウ{nr}のタグスタックを変更する。
		{nr}にはウィンドウ番号または |window-ID| を指定できる。

		{dict}でサポートされている項目のリストについては、
		|gettagstack()| を参照。"curidx" はタグスタックを変更する前に
		効果を生じる。
							*E962*
		どのようにタグスタックが更新されるかは {action} 引数に依存する:
		- {action} が与えられないか 'r' に設定されている場合、タグス
		  タックは置き換えられる。
		- {action} が 'a' に設定されている場合、{dict} の新しいエント
		  リはタグスタックにプッシュされる。
		- {action} が 't' に設定されている場合、タグスタックの現在のエ
		  ントリあるいは {dict} の "curidx" からすべてのエントリが削除
		  され、新しいエントリがスタックにプッシュされる。

		タグスタックの変更後、現在のインデックスはスタックの長さの 1
		つ後に設定される。

		成功の場合は 0 を返し、失敗の場合は -1 を返す。

		例 (より多くの例は |tagstack-examples| を参照):
<		    ウィンドウ番号 3 のタグスタックを空にする: >
			call settagstack(3, {'items' : []})

<		    タグスタックの保存と復元: >
			let stack = gettagstack(1003)
			" do something else
			call settagstack(1003, stack)
			unlet stack
<
		|method| としても使用でき、ベースは第2引数として渡される: >
			GetStack()->settagstack(winnr)

setwinvar({winnr}, {varname}, {val})			*setwinvar()*
		|settabwinvar()|と同様。カレントタブページを対象とする。
		例: >
			:call setwinvar(1, "&list", 0)
			:call setwinvar(2, "myvar", "foobar")

<		|method| としても使用でき、ベースは第3引数として渡される: >
			GetValue()->setwinvar(winnr, name)

sha256({string})						*sha256()*
		{string}のSHA256チェックサムを64文字の16進文字列で返す。

		|method| としても使用できる: >
			GetText()->sha256()

<		{|+cryptv| 機能つきでコンパイルされたときのみ有効}

shellescape({string} [, {special}])			*shellescape()*
		シェルコマンドの引数として利用できるように{string}をエスケープ
		する。
		'shell' がpowershell (MS-Windows) か pwsh (MS-Windows、Linux、
		macOS) が設定されている時、{string} をシングルクォートで囲み、
		{string}の中のシングルクォートを全て二重にする。
		MS-Windowsでは、'shellslash' が設定されていない場合、{string}
		をダブルクォートで囲み、{string}の中のダブルクォートを全て二重
		にする。そうでなければ、{string}をシングルクォートで囲み、"'"
		を"'\''" で置き換える。

		{special} が指定され、0 でない数値または空でない文字列の場合
		(|non-zero-arg|)、"!", "%", "#", "<cword>" などの特殊なアイテ
		ムの前にはバックスラッシュがつく。コマンド |:!| によってその
		バックスラッシュは再び除かれる。

		'shell' の値の末尾が "csh" である場合、{special} が
		|non-zero-arg| ならば "!" の文字もエスケープされる。これは、
		csh と tcsh は シングルクォートの中であっても "!" を履歴置換と
		解釈するためである。

		{special} が |non-zero-arg| である場合、<NL> 文字もエスケープ
		される。'shell' の末尾が "csh" である場合、これは 2 回エスケー
		プされる。

		'shell' の値の末尾が "fish" である場合、"\" 文字はエスケープさ
		れる。fish はシングルクォート内のエスケープ文字として "\"をシ
		ングルクォートの代わりに使うため。

		|:!| コマンドを使う場合の例: >
		    :exe '!dir ' .. shellescape(expand('<cfile>'), 1)
<		これはカーソル下のファイルを dir コマンドで表示する。
		|system()| を使う場合の例: >
		    :call system("chmod +w -- " .. shellescape(expand("%")))
<		|::S| も参照のこと。

		|method| としても使用できる: >
			GetCommand()->shellescape()

shiftwidth([{col}])						*shiftwidth()*
		実際に使用される 'shiftwidth' の値を返す。'shiftwidth' がゼロ
		以外の場合はその値が返る。ゼロの場合は 'tabstop' の値が返る。
		この関数は2012年のパッチ 7.3.694 で導入されたので、現在では皆
		使えるようになっているに違いない。(ただし、オプションの引数
		{col}は 8.1.542 まで使用できない)

		引数{col}があるとき、'shiftwidth' の値を返す桁番号として使用さ
		れる。これは、'vartabstop' 機能のためのものである。
		'vartabstop' 設定が有効で、引数{col}が指定されていない場合、桁
		番号1だと仮定される。

		|method| としても使用できる: >
			GetColumn()->shiftwidth()

sign_ 関数群はここに文書化されている: |sign-functions-details|

simplify({filename})					*simplify()*
		ファイル名を、意味を変えずにできるだけ簡略化する。MS-Windowsで
		のショートカットやUnixでのシンボリックリンクは解決される。
		{filename}の最初のパスコンポーネントがカレントディレクトリを指
		す場合、結果にそのまま残される。末尾のパス区切り文字も取り除か
		れない。Unix では "//path" は変更されない、しかし "///path" は
		"/path" に簡略化される (POSIX 標準に準拠)。
		例: >
			simplify("./dir/.././/file/") == "./file/"
<		Note: "dir/.." の組み合わせは、"dir" が検索可能なディレクトリ
		であるか、存在しないときのみ取り除かれる。Unixでは、"dir" が同
		じディレクトリ内にあるシンボリックリンクであるときも取り除かれ
		る。パス名を簡略化する前に全てのシンボリックリンクを解決させる
		には|resolve()|を使う。

		|method| としても使用できる: >
			GetName()->simplify()

sin({expr})						*sin()*
		{expr} の正弦(サイン)をラジアンで |Float| で返す。{expr} は
		|Float| または |Number| に評価されなければならない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo sin(100)
<			-0.506366 >
			:echo sin(-4.01)
<			0.763301

		|method| としても使用できる: >
			Compute()->sin()

sinh({expr})						*sinh()*
		{expr} の双曲線正弦 (ハイパボリックサイン) を返す。
		値は [-inf, inf] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か数値 (|Number|) でなければな
		らない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo sinh(0.5)
<			0.521095 >
			:echo sinh(-0.9)
<			-1.026517

		|method| としても使用できる: >
			Compute()->sinh()


slice({expr}, {start} [, {end}])			*slice()*
		スライス |slice| "expr[start : end]" と同様に使えるが、"end"
		を含まない。そして文字列のインデックスは、|vim9script| と同様
		にバイトインデックスの代わりに文字インデックスが使われる。ま
		た、合成文字は直前の基底文字の一部として扱われる。
		{end} がない場合スライスは最後の項目を含む。
		{end} が-1の場合最後の項目を含まない。
		{start} または {end} が無効な場合は空の値を返す。

		|method| としても使用できる: >
			GetList()->slice(offset)


sort({list} [, {how} [, {dict}]])			*sort()* *E702*
		{list} の要素をその場で(in-place)ソートする。{list} を返す。

		リストを変更したくない場合は、最初にコピーを作っておくこと: >
			:let sortedlist = sort(copy(mylist))
<		{how} が省略されるか文字列の場合、各項目の文字列表現を使って
		ソートする。数値は文字列より後になり、リストは数値より後にな
		る。カレントバッファのテキストをソートするには |:sort| を使う。

		{how} が 'i' なら大文字小文字は区別されない。旧来のスクリプト
		の場合、後方互換性のため、大文字小文字の区別なしとして値が1も
		使える。0は大文字小文字の区別する意味になる。

		{how} が 'l' ならソート順に現在のロケールの照合順序を使用する。
		実装詳細: 文字列の比較に strcoll() を使用する。ロケール照合順
		をチェックしたり設定するには |:language| を参照すること。
		|v:collate| でも現在のロケールを確認することができる。ロケール
		利用のソートでは通常大文字小文字を区別しない。例: >
			" ö は英語ロケールでは o と同等にソートされる。
			:language collate en_US.UTF8
			:echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
<			['n', 'o', 'O', 'ö', 'p', 'z'] ~
>
			" ö はスウェーデン語ロケールでは z のうしろにソートさ
			" れる。
			:language collate sv_SE.UTF8
			:echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
<			['n', 'o', 'O', 'p', 'z', 'ö'] ~
		これはMacでは正常に動作しない。

		{how} が 'n' ならすべての要素は数値順にソートされる (実装詳細:
		数値の読み込みには strtod() 関数が使われる。文字列、リスト、辞
		書、関数参照は 0 として扱われる)。Note これは数字を含む文字列
		のリストを並べ替えないことに注意!

		{how} が 'N' ならすべての要素は数値順にソートされる。これは
		'n' に似ているが、数値を含む文字列はその文字列が表す数値として
		扱われる。

		{how} が 'f' ならすべての要素は数値順にソートされる。すべての
		値は数値か浮動小数点数でなければならない。

		{how} に |Funcref| または関数名を指定すると、その関数を使って
		要素を比較する。その関数は2つの要素を引数として受け取り、それ
		らが等しいときは0、1番目の引数を2番目より後にするなら1以上、1
		番目の方を前にするなら-1以下を返す。

		{dict} は "dict" 属性付きの関数と一緒に使う。値はローカル変数
		"self" として使われる。 |Dictionary-function|

		ソートは安定である。(数値または文字列として) 等価な要素は元の
		順序関係が保持される。例えば数値としてソートした場合、文字列は
		元の順番通りに隣り合って並ぶ。

		|method| としても使用できる: >
			mylist->sort()

<		|uniq()| も参照のこと。

		例: >
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			eval mylist->sort("MyCompare")
<		この例の場合、より短く次のように書くことができる。ただしオーバー
		フローは無視される: >
			func MyCompare(i1, i2)
			   return a:i1 - a:i2
			endfunc
<		簡単な式をラムダとして使う例: >
			eval mylist->sort({i1, i2 -> i1 - i2})
<
sound_clear()						*sound_clear()*
		すべてのサウンドの再生を停止する。

		一部のLinuxシステムでは libcanberra-pulse のパッケージが必要に
		なる場合があり、そうしないとサウンドが停止しない場合がある。

		|method| としても使用できる: >
			GetSoundName()->sound_playevent()

<		{|+sound| 機能つきでコンパイルされたときのみ有効}

							*sound_playevent()*
sound_playevent({name} [, {callback}])
		{name} で識別されるサウンドを再生する。サポートされているイベ
		ント名はシステムによって異なる。XDGのサウンド名がよく使われる。
		Ubuntuでは、それらは /usr/share/sounds/freedesktop/stereo に見
		つかるだろう。例: >
			call sound_playevent('bell')
<		MS-Windows では、{name} は SystemAsterisk、SystemDefault、
		SystemExclamation、SystemExit、SystemHand、SystemQuestion、
		SystemStart、SystemWelcome 等になる。
		macOS では、{name} は /System/Library/Sounds にあるファイルを
		指します (例: "Tink")。~/Library/Sounds 等のフォルダにカスタム
		でインストールされたサウンドにも機能する。

		{callback} が指定されている場合は、サウンドが終了したときに呼
		び出される。最初の引数はサウンドID、2番目の引数はステータスで
		ある:
			0	最後までサウンドが再生された
			1	サウンドは中断された
			2	サウンド開始後にエラーが発生した
		例: >
		   func Callback(id, status)
		     echomsg "sound " .. a:id .. " finished with " .. a:status
		   endfunc
		   call sound_playevent('bell', 'Callback')

<		MS-Windows: {callback} はこの関数では動作しない。

		`sound_stop()` に渡すことができるサウンドIDを返す。
		サウンドを再生できなかった場合はゼロを返す。
		{|+sound| 機能つきでコンパイルされたときのみ有効}

							*sound_playfile()*
sound_playfile({name} [, {callback}])
		`sound_playevent()` と似ているが、サウンドファイル {name} を再
		生する。{name} はフルパスでなければならない。Ubuntuでは、この
		コマンドで再生するファイルが見つかるかもしれない: >
		    :!find /usr/share/sounds -type f | grep -v index.theme

<		|method| としても使用できる: >
			GetSoundPath()->sound_playfile()

<		{|+sound| 機能つきでコンパイルされたときのみ有効}


sound_stop({id})					*sound_stop()*
		サウンド {id} の再生を停止する。{id} は、事前に
		`sound_playevent()` または `sound_playfile()` によって返された
		ものでなければならない。

		一部のLinuxシステムでは libcanberra-pulse のパッケージが必要に
		なる場合があり、そうしないとサウンドが停止しない場合がある。

		MS-Windowsでは、これは `sound_playevent()` によって開始される
		イベントサウンドに対しては機能しない。イベントのサウンドを止め
		るには `sound_clear()` を使用する。

		|method| としても使用できる: >
			soundid->sound_stop()

<		{|+sound| 機能つきでコンパイルされたときのみ有効}

							*soundfold()*
soundfold({word})
		{word} の soundfold 値を返す。カレントウィンドウの 'spelllang'
		で設定された言語のうち、soundfold に対応している最初の言語が使
		用される。'spell' がオンでなければならない。soundfold ができな
		い場合は {word} がそのまま返される。
		この関数はスペル修正候補の作成に使える。Note この方法はとても
		遅くなる可能性がある。
		{訳注: phonetic algorithm の一種}

		|method| としても使用できる: >
			GetWord()->soundfold()
<
							*spellbadword()*
spellbadword([{sentence}])
		引数なしの場合: カーソル下またはカーソル以降のスペルミスした単
		語を返す。その単語の先頭へカーソルを移動する。カレント行にスペ
		ルミスした単語が見つからない場合は空文字列を返し、カーソルは移
		動しない。

		引数ありの場合: {sentence}の中のスペルミスしている最初の単語を
		返す。スペルミスしている単語がない場合は空文字列を返す。

		戻り値は、次の2個の要素を持つリスト:
		- スペルミスした単語または空文字列
		- スペルミスの種類:
			"bad"		スペルミス
			"rare"		頻度の低い単語
			"local"		他の地域でのみ有効な単語
			"caps"		大文字で始めるべき単語
		例: >
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~

		カレントウィンドウに対するスペリング情報と 'spelllang' の値が
		使用される。

		|method| としても使用できる: >
			GetText()->spellbadword()
<
							*spellsuggest()*
spellsuggest({word} [, {max} [, {capital}]])
		{word}の正しいスペルの候補のリストを返す。{max}を指定すると、
		候補の数の最大値となる。{max}を指定しないと、25個までの候補を
		返す。

		{capital}に0でない値を指定すると、先頭が大文字の候補だけを返す。
		これは 'spellcapcheck' とのマッチの後に使う。

		{word}はスペルの間違った単語で、後に他のテキストが続いてもよい。
		これにより、分割された2つの単語を連結することができる。候補も
		また続きのテキストを含んでいるので、これによって行を置き換える
		ことができる。

		{word}は正しい単語でもよい。すると似た単語が返ってくるだろう。
		{word}自身は候補に含まれないが、大文字化されたものが含まれてい
		ることはある。

		カレントウィンドウのスペリング情報が使われる。オプション
		'spell' がオンでなければならず、'spelllang' と 'spellsuggest'
		の値が適用される。

		|method| としても使用できる: >
			GetWord()->spellsuggest()

split({string} [, {pattern} [, {keepempty}]])			*split()*
		{string}を分割してリスト |List| にする。{pattern}を省略した場
		合、または {pattern}が空文字列の場合は、{expr}を空白文字で区
		切った各文字列が要素となる。
		{pattern}を指定すると、{pattern}がマッチする位置で文字列を分割
		する。マッチした文字列は削除される。'ignorecase' はここでは適
		用されないので大文字小文字を無視するには \c を使う。 |/\c|
		{keepempty}に非0を指定しない限り、最初または最後の要素が空文字
		列ならばリストから取り除かれる。
		それ以外の空文字列は、{pattern}が1文字以上にマッチすれば、また
		は{keepempty}が非0ならばそのままリストの要素となる。
		例: >
			:let words = split(getline('.'), '\W\+')
<		文字列を各文字に分割するには: >
			:for c in split(mystring, '\zs')
<		区切り文字を削除せず、そのままにしておきたい場合は、'\zs' を
		パターンの最後で使う: >
			:echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi'] ~
		最初の要素が空であるかもしれないテーブルを分割するには: >
			:let items = split(line, ':', 1)
<		これの逆を行う関数は|join()|である。

		|method| としても使用できる: >
			GetString()->split()

sqrt({expr})						*sqrt()*
		浮動小数点数 {expr} の非負平方根を |Float| で返す。
		{expr} は |Float| または |Number| に評価されなければならない。
		{expr} が負の場合、結果は NaN (Not a Number) になる。{expr} が
		|Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo sqrt(100)
<			10.0 >
			:echo sqrt(-4.01)
<			nan
		"nan" はシステムのライブラリに依存するので、異なるかもしれな
		い。

		|method| としても使用できる: >
			Compute()->sqrt()


srand([{expr}])						*srand()*
		|rand()| で使われる種を初期化する:
		- {expr} が与えられない場合、種は可能ならば /dev/urandom を読
		  むことで初期化され、そうでなければ time(NULL)、すなわちエポッ
		  クタイム (これは秒の正確度しかないが) で初期化される。
		- {expr} が与えられる場合、数値でなければならない。これは種の
		  値を初期化するのに用いられる。これはテストや、予期可能な数列
		  を意図しているときに有用である。

		例: >
			:let seed = srand()
			:let seed = srand(userinput)
			:echo rand(seed)

state([{what}])						*state()*
		現在の状態を示す文字を含む文字列を返す。常に安全であるとは限ら
		ないかもしれない作業を行いたいコールバックで最も有用である。お
		およそ次のように動作する:
		- コールバックは state() を使用して、作業が安全かどうかを確認
		  する。
		  はい:   その後すぐにそれを行う
		  いいえ: 作業キューへの追加と、|SafeState| および/または
			  |SafeStateAgain| 自動コマンドを追加する(|SafeState|
			  はトップレベルでトリガー、|SafeStateAgain| はメッセー
			  ジとコールバックの処理後にトリガー)。
		- SafeState または SafeStateAgain がトリガーされて自動コマンド
		  が実行されたら、`state()` で作業をすぐに実行できるかどうかを
		  確認し、はいの場合はキューから削除して実行する。キューが空に
		  なった場合、自動コマンドを削除する。
		|mode()| も参照。

		{what} を指定すると、この文字列の文字のみが追加される。たとえ
		ば、これは画面がスクロールしたかどうかを確認する: >
			if state('s') == ''
			   " 画面はスクロールしていない
<
		これらの文字は状態を示し、大概は何かがビジーであることを示す:
		    m	マッピングの途中、:normalコマンド、feedkeys() または詰
			め込まれたコマンド
		    o	オペレータ待機、例えば |d| の後
		    a	挿入モード自動補完がアクティブ
		    x	自動コマンド実行中
		    w	待機中にブロックされた。例えば、jsonを読む時の
			ch_evalexpr(), ch_read() および ch_readraw()
		    S	SafeState または SafeStateAgain をトリガーしない、例え
			ば |f| の後やカウント時
		    c	タイマーを含むコールバック呼び出し(再帰呼び出しは
			"ccc" まで繰り返す)
		    s	画面がメッセージでスクロールされた

str2float({string} [, {quoted}])				*str2float()*
		文字列 {string} を浮動小数点数に変換する。これは式の中で浮動小
		数点数を使っているときと同じように働く
		(|floating-point-format| を参照)。しかしこちらの方がゆるやかで
		ある。例えばこちらでは "1e40" も許されるが、式の中では
		"1.0e40" と書かなければならない。16進形式の "0x123" も許される
		が、バイナリや8進数のようなものは許されない。
		{quoted} が存在し非0の場合は小数点の前のシングルクォートの付与
		は無視され、結果 "1'000.0" は1000になる。
		数値の後ろにある文字列は黙って無視される。
		小数点数はロケールの設定にかかわらず常に '.' である。コンマを
		発見すると、そこで数値は終わりになる。つまり "12,345.67" は
		12.0 に変換される。3桁ごとのコンマ区切りを取り除くには
		|substitute()| が使える: >
			let f = str2float(substitute(text, ',', '', 'g'))
<
		変換が失敗した場合は 0.0 を返す。

		|method| としても使用できる: >
			let f = text->substitute(',', '', 'g')->str2float()

str2list({string} [, {utf8}])					*str2list()*
		文字列{string}の各文字を表す数値を含むリストを返す。例: >
			str2list(" ")		returns [32]
			str2list("ABC")		returns [65, 66, 67]
<		|list2str()| は反対のことをする。

		{utf8}が省略されているかゼロの場合、現在の 'encoding' が使用さ
		れる。{utf8}が真の場合は、常に文字列がUTF-8であるとして扱う。
		UTF-8の合成文字は正しく処理される: >
			str2list("á")		returns [97, 769]

<		|method| としても使用できる: >
			GetString()->str2list()


str2nr({string} [, {base} [, {quoted}]])			*str2nr()*
		文字列{string}を数値に変換する。
		{base}は変換の底。2、8、10、16のいずれか。
		{quoted} が与えられ 0 以外の場合、埋め込まれた単一引用符は無視
		されるため、"1'000'000" は100万である。
		{base}を省略すると10となる。そのため、文字列の先頭に0があると
		き、デフォルトの文字列・数値変換とは異なり、8進数とは解釈され
		ない。例: >
			let nr = str2nr('0123')
<
		{base}が16のとき、文字列の先頭の "0x" と "0X" は無視される。そ
		れ以外の底の場合は0となる。同様に、
		{base}が8のとき、文字列の先頭の "0" と "0o" と "0O" は無視され
		る。そして、{base}が2のとき、文字列の先頭の "0b" と "0B" は無
		視される。
		数値の後のテキストは暗黙に無視される。

		{string} が空の場合、またはエラーの場合は 0 を返す。

		|method| としても使用できる: >
			GetText()->str2nr()

strcharlen({string})					*strcharlen()*
		結果は数値で、文字列 {string} の文字の数を返す。合成文字は無視
		される。
		|strchars()| は合成文字を別々にカウントできる。

		{string} が空の場合、またはエラーの場合は 0 を返す。

		|strlen()|, |strdisplaywidth()|, |strwidth()| も参照。

		|method| としても使用できる: >
			GetText()->strcharlen()

strcharpart({src}, {start} [, {len} [, {skipcc}]])		*strcharpart()*
		|strpart()| と同様だがバイトのインデックスおよび長さではなく文
		字のインデックスおよび長さを使用する。
		{skipcc} を省略するかゼロにすると、合成文字は別々にカウントさ
		れる。
		{skipcc} を 1 にすると、|slice()| と同様に合成文字は直前の基底
		文字の一部として扱われる。
		文字インデックスが存在しない文字を指す場合、それは 1 つの文字
		としてカウントされるが、戻り値には現れない。例: >
			strcharpart('abc', -1, 2)
<		結果は 'a' である。

		エラーの場合は空の文字列を返す。

		|method| としても使用できる: >
			GetText()->strcharpart(5)


strchars({string} [, {skipcc}])					*strchars()*
		結果は数値で、文字列 {string} の文字の数を返す。
		{skipcc} を省略またはゼロを指定すると、合成文字は別々にカウン
		トされる。
		{skipcc} に 1 を指定すると、合成文字は無視される。
		|strcharlen()| では合成文字は常に無視される。

		エラーの場合はゼロを返す。

		|strlen()|, |strdisplaywidth()|, |strwidth()| も参照。

		{skipcc}は7.4.755以降でのみ有効である。それ以前では、ラッパー
		関数を定義すればよい: >
		    if has("patch-7.4.755")
		      function s:strchars(str, skipcc)
			return strchars(a:str, a:skipcc)
		      endfunction
		    else
		      function s:strchars(str, skipcc)
			if a:skipcc
			  return strlen(substitute(a:str, ".", "x", "g"))
			else
			  return strchars(a:str)
			endif
		      endfunction
		    endif
<
strdisplaywidth({string} [, {col}])			*strdisplaywidth()*
		結果は数値で、文字列 {string} が {col} (最初の桁はゼロ)で始ま
		る時のスクリーン上での表示セル幅を返す。
		{col} が省略されたときはゼロが使われる。{col} には計算を開始す
		るスクリーン上の列の位置を指定する。これはタブ文字の幅の計算に
		影響する。
		計算にはカレントウィンドウのオプションが使用される。'tabstop'
		や 'display' のような表示を変更するようなオプションが影響す
		る。
		{string} に幅が曖昧 (Ambiguous) な東アジアの文字が含まれている
		ときは、文字幅は 'ambiwidth' の設定に依存する。
		エラーの場合はゼロを返す。
		|strlen()|, |strwidth()|, |strchars()| も参照。

		|method| としても使用できる: >
			GetText()->strdisplaywidth()

strftime({format} [, {time}])				*strftime()*
		結果は文字列で、{format}に従って日付や時間がフォーマットされた
		ものになる。{time}が与えられた場合にはそれを使うが、省略された
		場合には現在時刻を使用する。受け付け可能な文字列{format}は使用
		するシステムに依存するので、ポータブルとは言えない。フォーマッ
		トについてはCの関数strftime()のマニュアルを参照。結果は最大80
		文字に制限される。|localtime()|, |getftime()| と |strptime()|
		も参照。
		ここで使われる言語はコマンド|:language|で変更できる。
		例: >
		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
		  :echo strftime("%y%m%d %T")	   970427 11:53:55
		  :echo strftime("%H:%M")	   11:55
		  :echo strftime("%c", getftime("file.c"))
						   file.cの更新時刻を表示
<		この関数はどのシステムでも利用できるとは限らない。利用できるか
		チェックするには次のようにする: >
			:if exists("*strftime")

<		|method| としても使用できる: >
			GetFormat()->strftime()

strgetchar({str}, {index})				*strgetchar()*
		{str} 内の {index} 番目の文字に対応する数値を取得する。これは、
		バイトインデックスではなく、ゼロから始まる文字インデックスを使
		用する。ここでは、合成文字は別個の文字とみなされる。
		|nr2char()| を使用して数値を文字列に変換する。
		{index} が無効な場合は -1 を返す。
		|strcharpart()| と |strchars()| も参照。

		|method| としても使用できる: >
			GetText()->strgetchar(5)

stridx({haystack}, {needle} [, {start}])		*stridx()*
		結果は数値で、{haystack}の中で文字列{needle}が最初に現れる位置
		のバイトインデックスを表す。{start}を指定すると、インデックス
		{start}の位置から検索を開始する。
		2番目のマッチを探すには次のようにする: >
			:let colon1 = stridx(line, ":")
			:let colon2 = stridx(line, ":", colon1 + 1)
<		検索は大文字・小文字を区別する。
		検索パターンについては|match()|を使う。
		{haystack}の中に{needle}がないときは-1を返す。
		|strridx()|も参照。
		例: >
		  :echo stridx("An Example", "Example")	     3
		  :echo stridx("Starting point", "Start")    0
		  :echo stridx("Starting point", "start")   -1
<						*strstr()* *strchr()*
		stridx()はCの関数strstr()と同じように動作する。{needle}が1文字
		のときはstrchr()と同じように動作する。

		|method| としても使用できる: >
			GetHaystack()->stridx(needle)
<
							*string()*
string({expr})	{expr}を文字列に変換して返す。{expr}が数値、浮動小数点数、文字
		列、Blob またはそれらの複合の場合は、この戻り値を |eval()| で
		パースして復元できる。
			{expr} 型	結果 ~
			文字列		'string' (シングルクォートは二重化され
					る)
			数値		123
			浮動小数点数	123.123456 or 1.123456e8
			Funcref		function('name')
			Blob		0z00112233.44556677.8899
			リスト		[item, item]
			辞書		{key: value, key: value}
			クラス		class SomeName
			オブジェクト	object of SomeName {lnum: 1, col: 3}
			列挙型		enum EnumName
			列挙値		enum name.value {name: str, ordinal: nr}

		リスト |List| や辞書 |Dictionary| に循環参照がある場合、それら
		は "[...]" や "{...}" に置き換えられる。その結果に対して eval()
		を使用すると失敗する。

		オブジェクトに対しては、string() メソッドを呼び出してオブジェ
		クトのテキスト表現を取得する。メソッドが存在しない場合は、デ
		フォルトの表現が用いられる。|object-string()|

		|method| としても使用できる: >
			mylist->string()

<		|strtrans()|も参照。

strlen({string})						*strlen()*
		結果は数値で、文字列{string}のバイト単位での長さ。
		引数が数値の場合は、まず文字列に変換される。
		それ以外の型の場合はエラーとなり、ゼロが返される。
		マルチバイト文字の数を数える場合は|strchars()|を使用する。
		|len()|, |strdisplaywidth()|, |strwidth()| も参照。

		|method| としても使用できる: >
			GetString()->strlen()

strpart({src}, {start} [, {len} [, {chars}]])			*strpart()*
		結果は文字列で、{src}の{start}番目の文字から始まる、長さ{len}
		の部分文字列。
		引数 {chars} が存在し真であれば {len} は文字の位置の数字 (合成
		文字は分割して数えない、つまり "1" は基底文字1つとそれに続く合
		成文字を意味する)。
		{start} をバイト数ではなく文字数で数えるには |strcharpart()|
		を用いる。

		存在しない文字を含むように範囲を指定しても、エラーにはならな
		い。単に文字が省略されるだけである。
		{len}を省略すると、{start}から{src}の末尾までの部分文字列を返
		す。 >
			strpart("abcdefg", 3, 2)    == "de"
			strpart("abcdefg", -2, 4)   == "ab"
			strpart("abcdefg", 5, 4)    == "fg"
			strpart("abcdefg", 3)       == "defg"
<		Note: 文字列の最初の文字を指定するためには、{start}は0でなけれ
		ばならない。カーソルのある位置の文字を取得する例: >
			strpart(getline("."), col(".") - 1, 1, v:true)
<
		エラー時には空の文字列を返す。

		|method| としても使用できる: >
			GetText()->strpart(5)

strptime({format}, {timestring})				*strptime()*
		結果は数値で、{format} で指定した書式に一致する {timestring} が
		表す日付と時刻の unix タイムスタンプを返す。

		受け入れられる {format} はシステムに依存するため、これは移植可
		能ではない! 書式は C 関数 strptime() のマニュアルページを参照
		すること。特に "%c" は避けること。$TZ の値も影響する。

		{timestring} が {format} でパースできないときは 0 が返される。
		{timestring} の書式が分からないときは、非 0 の値が返るまで、異
		なった {format} の値を試してみるとよい。

		|strftime()| も参照。
		例: >
		  :echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")
<		  862156163 >
		  :echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))
<		  Sun Apr 27 11:53:55 1997 >
		  :echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)
<		  Sun Apr 27 12:53:55 1997

		|method| としても使用できる: >
			GetFormat()->strptime(timestring)
<
		全システムで使用可能ではない。調べるにはこれを使う: >
			:if exists("*strptime")

strridx({haystack}, {needle} [, {start}])			*strridx()*
		結果は数値で、{haystack}の中で文字列{needle}が最後に現れる位置
		のバイトインデックスとなる。
		{start}を指定すると、そのインデックス以降でのマッチは無視され
		る。前のマッチより前にあるものを見つけるには次のようにする: >
			:let lastcomma = strridx(line, ",")
			:let comma2 = strridx(line, ",", lastcomma - 1)
<		検索は大文字・小文字を区別する。
		検索パターンについては|match()|を使う。
		{haystack}の中に{needle}がないときは-1を返す。
		{needle}が空文字列のときは{haystack}の長さを返す。
		|stridx()|も参照。例: >
		  :echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		{needle}が1文字の場合はCの関数strrchr()と同じように動作する。

		|method| としても使用できる: >
			GetHaystack()->strridx(needle)

strtrans({string})					*strtrans()*
		結果は文字列で、{string}内の表示不可能な文字を|'isprint'|で指
		定される、表示可能な文字に変換したもの。ウィンドウに表示するこ
		とができるようになる。例: >
			echo strtrans(@a)
<		これはレジスタの中の改行を、改行として表示する代わりに "^@" と
		表示する。
<
		エラー時には空の文字列を返す。

		|method| としても使用できる: >
			GetString()->strtrans()

strutf16len({string} [, {countcc}])			*strutf16len()*
		結果は数値で、文字列 {string} 内の UTF-16 コード単位の数
		(UTF-16 に変換後) である。

		{countcc} が TRUE の場合、合成文字は個別にカウントされる。
		{countcc} が省略または FALSE の場合、合成文字は無視される。

		エラーの場合はゼロを返す。

		|strlen()| と |strcharlen()| も参照。
		例: >
		    echo strutf16len('a')		returns 1
		    echo strutf16len('©')		returns 1
		    echo strutf16len('😊')		returns 2
		    echo strutf16len('ą́')		returns 1
		    echo strutf16len('ą́', v:true)	returns 3
<
		|method| としても使用できる: >
			GetText()->strutf16len()
<
strwidth({string})					*strwidth()*
		結果は数値で、文字列 {string} のスクリーン上での表示セル幅を返
		す。タブ文字の幅は 1 として数えられる (タブ文字の幅も考慮した
		い場合は|strdisplaywidth()| を使うこと)。
		{string} に幅が曖昧 (Ambiguous) な東アジアの文字が含まれている
		ときは、文字幅は 'ambiwidth' の設定に依存する。
		エラーの場合はゼロを返す。
		|strlen()|, |strdisplaywidth()|, |strchars()| も参照。

		|method| としても使用できる: >
			GetString()->strwidth()

submatch({nr} [, {list}])			*submatch()* *E935*
		|:substitute| や substitute() 関数の中の式でのみ使われる。
		マッチしたテキストの{nr} 番目の部分マッチを返す。{nr}が0のとき
		はマッチしたテキスト全体を返す。
		Note: 文字列中の NL 文字は複数行マッチにおける改行文字か、NUL
		文字のどちらかである。
		|sub-replace-expression| も参照。

		{list} に非ゼロの値が指定されたときは submatch() は文字列のリ
		ストを返す。|getline()| に 2 つの引数を指定したときの戻り値と
		同じである。テキスト中の NL 文字は NUL 文字を表す。
		|:substitute| で使われたときのみ複数要素のリストを返す。
		|substitute()| では、実際の改行はそこにはないので、リストは常
		に 0 または 1 つの要素である。

		substitute() が再帰的に使用された場合、現在の（最も深い）サブ
		マッチのみが取得できる。

		エラーの場合は空の文字列かリストを返す。

		例: >
			:s/\d\+/\=submatch(0) + 1/
			:echo substitute(text, '\d\+', '\=submatch(0) + 1', '')
<		この例は、行の中で最初の数値を検索し、それに1を加える。改行は
		改行文字として含まれる。

		|method| としても使用できる: >
			GetNr()->submatch()

substitute({string}, {pat}, {sub}, {flags})		*substitute()*
		結果は文字列で、{string}内で最初に{pat}にマッチした部分を{sub}
		に置換えたコピーになる。
		{flags} が "g" なら、{string} 内の {pat} にマッチした部分をす
		べて置換する。そうしたくない場合は {flags} は "" にすべきであ
		る。

		これはコマンド ":substitute" (一切のフラグ無し) のように働く。
		しかしマッチングは常にオプション 'magic' が設定され、オプショ
		ン 'cpoptions' は空にして実行される(スクリプトをポータブルにす
		るため)。'ignorecase' は適用される。'ignorecase' の設定にかか
		わらず大文字小文字を区別するかしないか固定するには |/\c| か
		|/\C| を使う。'smartcase' は適用されない。{pat}がどう扱われる
		かについては|string-match|を参照。

		また、{sub}内の "~" は前回の{sub}に置換されない。
		{sub}内の幾つかのコードには|sub-replace-special|の特殊な意味が
		あることに注意。例えば、何かの文字列をリテラルの "\n" に置換え
		るためには、"\\\\n" か '\\n' を使う必要がある。

		{pat}が{string}の何処にもマッチしなければ、{string}が何の変更
		も受けずに返される。

		例: >
		   :let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		これはオプション 'path' の最後のコンポーネントを削除する。 >
		   :echo substitute("testing", ".*", "\\U\\0", "")
<		結果は "TESTING" となる。

		{sub} が "\=" で開始している場合は、その後ろの文字列は式として
		解釈される。|sub-replace-expression| 参照。例: >
		   :echo substitute(s, '%\(\x\x\)',
			   \ '\=nr2char("0x" .. submatch(1))', 'g')

<		{sub} が関数リファレンスの場合、1個のオプショナル引数と共にそ
		の関数が呼び出される。例: >
		   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')
<		オプショナル引数はマッチ文字列全体と9個のサブマッチが含まれる
		以下の |submatch()| が返す様なリストである。例: >
		   :echo substitute(s, '%\(\x\x\)', {m -> '0x' .. m[1]}, 'g')

<		エラーの場合は空の文字列を返す。

		|method| としても使用できる: >
			GetString()->substitute(pat, sub, flags)

swapfilelist()						*swapfilelist()*
		"vim -r" で表示されるようなスワップファイル名のリストを返す。
		|-r| コマンド引数を参照。'directory' オプションは、検査するディ
		レクトリとして使用される。カレントディレクトリ内のスワップファ
		イルのリストのみを取得したい場合は、一時的に 'directory' をドッ
		トに設定する: >
			let save_dir = &directory
			let &directory = '.'
			let swapfiles = swapfilelist()
			let &directory = save_dir

swapinfo({fname})					*swapinfo()*
		結果は、スワップファイル {fname} に関する情報を含む辞書。利用
		可能なフィールドは以下のとおり:
			version Vim バージョン
			user	ユーザー名
			host	ホスト名
			fname	オリジナルファイルの名前
			pid	スワップファイルを作成した Vim プロセスの PID
			mtime	秒単位での最終修正時間
			inode	オプショナル: ファイルの INODE 番号
			dirty	ファイルが修正されていれば 1、そうでなければ 0
		Note: "user" および "host" は最大で 39 バイトに切り詰められる。
		失敗した場合、以下の理由と共に "error" 項目が追加される:
			Cannot open file: ファイルが見つからない、もしくはアク
					  セス不可
			Cannot read file: 先頭ブロックが読めない
			Not a swap file: 正しいブロック ID を含んでいない
			Magic number mismatch: 先頭ブロックの情報が無効である

		|method| としても使用できる: >
			GetFilename()->swapinfo()

swapname({buf})						*swapname()*
		結果はバッファ {buf} のスワップファイルパス。
		{buf} の使用については、上記の |bufname()| を参照。
		バッファ {buf} がカレントバッファの場合、結果は |:swapname|
		と等しい。(スワップファイルがない場合を除く)
		バッファ {buf} にスワップファイルがない場合、空文字列を返す。

		|method| としても使用できる: >
			GetBufname()->swapname()

synID({lnum}, {col}, {trans})				*synID()*
		結果は数値で、現在のウィンドウ内での位置{lnum}と{col}の位置の
		構文ID。
		構文IDは|synIDattr()|と|synIDtrans()|に渡すことで、テキストに
		ついての構文情報を取得するのに使用できる。

		最左のカラムを指定するには{col}に1を、最初の行を指定するには
		{line}に1を指定する。'synmaxcol' が適用され、長すぎる行では0が
		返ってくる。
		Note 挿入モードでカーソル位置を最後の文字より後ろにした場合、
		synID()は0を返す。{lnum}は|getline()|と同様に扱われる。

		{trans}が|TRUE|ならば、透過属性のアイテムは省略され、実際に表
		示されているアイテムが評価対象になる。これは実際に有効になって
		いるカラーを知りたい時に役に立つ。{trans}が|FALSE|ならば、透過
		属性のアイテムが返される。これはどの構文アイテムが有効になって
		いるかを知りたい時に役に立つ(例:カッコの中とか)。
		警告: この関数は非常に遅い。ファイルを順方向に走査する時にだけ
		ベストなスピードが得られる。

		エラーの場合はゼロを返す。

		例(カーソルの下の構文アイテムの名前を表示する): >
			:echo synIDattr(synID(line("."), col("."), 1), "name")
<

							*synIDattr()*
synIDattr({synID}, {what} [, {mode}])
		結果は文字列で、{synID}の属性{what}の内容を示す。これは構文
		アイテムの情報を取得するのに使用できる。
		{mode}には取得したいモードの属性に応じて、"gui" か "cterm" か
		"term" が指定できる。{mode}が省略されるか、無効な値が指定され
		た場合、現在有効になっているハイライトモードが使用される (GUI、
		cterm、termのどれか)。
		ハイライトグループにリンクされた属性を取得するにはsynIDtrans()
		を使用する。
		{what}		結果
		"name"		構文アイテムの名前
		"fg"		前景色(GUI:カラー名、cterm:文字列としてのカ
				ラー番号、term空文字列)
		"bg"		背景色("fg" 同様)
		"font"		フォント名 (GUI でのみ利用可)
				|highlight-font|
		"sp"		GUIでの特殊な色 ("fg" 同様) |highlight-guisp|
		"ul"		ctermで下線の色:文字列としてのカラー番号
		"fg#"		"fg" 同様だが、"#RRGGBB" のフォーマットで
		"bg#"		"bg" 同様だが、"#RRGGBB" のフォーマットで
		"sp#"		"sp" 同様だが、"#RRGGBB" のフォーマットで
		"bold"		太字なら "1"
		"italic"	斜体なら "1"
		"reverse"	反転なら "1"
		"inverse"	反転(原文inverse)なら "1" (reverseと等価)
		"standout"	強調 (standout) なら "1"
		"underline"	下線付きなら "1"
		"undercurl"	波線付きなら "1"
		"strike"	取り消し線付きなら "1"
		"nocombine"	属性を結合しないなら "1"

		エラーの場合は空の文字列を返す。

		例(カーソルの下の構文アイテムのカラーを表示する): >
	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<
		|method| としても使用できる: >
	:echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")


synIDtrans({synID})					*synIDtrans()*
		結果は数値で、{synID}を構文IDに変換したもの。キャラク
		タをハイライト表示している構文グループのIDである。
		":highlight link" によって与えられるハイライトのリンクはこれに
		従っている。

		エラーの場合はゼロを返す。

		|method| としても使用できる: >
	:echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")

synconcealed({lnum}, {col})				*synconcealed()*
		結果は現状 3 つのアイテムを含むリスト |List| である。
		1. リストの 1 番目のアイテムは、{lnum} と {col} が指す位置の文
		   字が Conceal 可能リージョンの中にあるなら 1、そうでないなら
		   0。{lnum}は|getline()|と同様に扱われる。
		2. リストの 2 番目のアイテムは文字列で、最初のアイテムが 1 な
		   ら、Conceal されたテキストの代わりに表示されるテキストが入
		   る (実行時の'conceallevel' および 'listchars' の設定に依
		   存)。
		3. リストの 3 番目の最後のアイテムは、行内でどのシンタックス
		   リージョンにマッチしたかを示す番号。その文字が Conceal され
		   ていない場合、この値は 0 である。これは同じ置換文字を持つ 2
		   つの Concela 可能リージョンが連続していた場合に、その区切り
		   を識別できるようにするため。テキストが "123456"で、"23" と
		   "45" の両方が Conceal されて文字 "X" に置き換えられていた場
		   合の例:
			call			returns ~
			synconcealed(lnum, 1)   [0, '', 0]
			synconcealed(lnum, 2)   [1, 'X', 1]
			synconcealed(lnum, 3)   [1, 'X', 1]
			synconcealed(lnum, 4)   [1, 'X', 2]
			synconcealed(lnum, 5)   [1, 'X', 2]
			synconcealed(lnum, 6)   [0, '', 0]


synstack({lnum}, {col})					*synstack()*
		カレントウィンドウの {lnum}, {col} の位置の構文アイテムのスタッ
		クをリスト |List| にして返す。{lnum} は |getline()| と同様に扱
		われる。
		このリストの要素は |synID()| が返すのと同じ種類の ID である。
		リストの最初の要素が一番外側の領域で、続く要素がその中に内包さ
		れている。アイテム全体がハイライトされている、または最後の要素
		が transparent なアイテムである場合を除き、最後の要素が
		|synID()| が返すものである。
		この関数は構文ファイルをデバッグするのに役に立つ。
		例(カーソル下の構文スタックを表示する): >
			for id in synstack(line("."), col("."))
			   echo synIDattr(id, "name")
			endfor
<		{lnum} と {col} で指定された位置が無効な場合は、空のリストが返
		される。行の最後の文字の直後と空行の最初の桁が有効な位置であ
		る。

system({expr} [, {input}])				*system()* *E677*
		シェルコマンド {expr} の実行結果を文字列 |String| として得る。
		リスト |List| として受け取るには |systemlist()| を参照。

		{input} に文字列 |String| が指定された場合、その文字列はファイ
		ルに書き出され、コマンドの標準入力として渡される。この文字列は
		そのまま (as-is) 書き出されるので、正しい改行文字を使うよう自
		分自身で気をつけなければならない。
		{input} にリスト (|List|) が指定された場合は、|writefile()| の
		{binary} に "b" を指定したのと同様にファイルに書き出される (つ
		まり、リストの各要素は改行文字で連結され、要素内の改行文字は
		NUL 文字に変換される)。
		{input} が指定され、それが数値で既存のバッファとして有効な id
		であるならば、そのバッファの内容が 1 行ずつファイルに書き出さ
		れる。それぞれの行は NL で終端され、テキスト中の NL は NUL 文
		字に置き換えられる。

		パイプは使用されず、'shelltemp' オプションは使用されない。

		|:silent| が前置されたときは、端末は cooked モードには設定され
		ない。これはユーザー入力を必要としないコマンドを使用することを
		意味する。これは画面に不要な文字が表示されるのを防ぐ (|CTRL-L|
		でそれをクリアする必要がなくなる)。 >
			:silent let f = system('ls *.vim')
<
		Note: コマンドの引数をエスケープするには、 |shellescape()|、
		|expand()| の |::S|、または |fnamemodify()| を使用する。{expr}
		内に改行文字があるとコマンドは失敗するだろう。'shellquote' や
		'shellxquote' 内にある文字も問題を起こすかもしれない。
		対話的なコマンドを使用することはできない。

		戻り値は文字列。例: >
		    :let files = system('ls ' .. shellescape(expand('%:h')))
		    :let files = system('ls ' .. expand('%:h:S'))

<		システムに依存しないような戻り値にするために、シェルの出力を
		フィルタリングし、マッキントッシュにおいては<CR>を<NL>に変換
		し、DOS系のシステムにおいては<CR><NL>を<NL>に変換している。
		文字列が NUL 文字で切れるのを防ぐため、すべての NUL 文字は SOH
		(0x01) に置換される。

		実行されるコマンドはいくつかのオプションを適用して構成される:
	'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'
		({tmp}は自動的に生成されるファイル名)
		Unixではコマンドの連結ができるように{expr}の両側に波括弧が置か
		れる。

		コマンドは「cooked」モードで実行される。そのためCTRL-Cでコマン
		ドを中断できる(少なくともUnixでは)。

		エラーコードは|v:shell_error|に格納される。
		この関数は|restricted-mode|では失敗する。

		Note 上記のオプションに不正な値が入っていると、この関数の呼び
		出しが失敗する可能性がある。セキュリティエージェントアプリケー
		ションを使っていると失敗することがあるとも報告されている。
		":!cmd" とは違い、ファイルが変更されているかのチェックは行わな
		い。
		明示的にチェックさせるには|:checktime|を使う。

		|method| としても使用できる: >
			:echo GetCmd()->system()

systemlist({expr} [, {input}])				*systemlist()*
		|system()| と同じだが行のリスト (|List|) を返す。行は NL 文字
		で区切られ、NUL 文字は NL 文字に変換される。出力は
		|readfile()| の {binary} 引数に "b" を指定したのと同様である。
		ただし、結果が NL で終わる場合、余分な空の項目はない。
		Note MS-Windows では末尾の CR 文字がつくかもしれないことに注
		意。

		"echo hello" と "echo -n hello" の違いを確認するには、
		|system()| および |split()| を使用する: >
			echo system('echo hello')->split('\n', 1)
<
		エラー時には空文字列が返る。

		|method| としても使用できる: >
			:echo GetCmd()->systemlist()


tabpagebuflist([{arg}])					*tabpagebuflist()*
		カレントタブページ内の各ウィンドウに表示されているバッファの番
		号を要素とするリスト|List|を返す。{arg}は対象とするタブページ
		の番号を指定する。省略したときはカレントタブページを対象とする。
		{arg}が無効なときは数値0を返す。
		全タブページ中の全バッファのリストを得るには次のようにする: >
			let buflist = []
			for i in range(tabpagenr('$'))
			   call extend(buflist, tabpagebuflist(i + 1))
			endfor
<		Note 1つのバッファが複数のウィンドウに表示されている場合がある
		ことに注意。

		|method| としても使用できる: >
			GetTabpage()->tabpagebuflist()

tabpagenr([{arg}])					*tabpagenr()*
		結果は数値で、カレントタブページの番号。最初のタブページの番号
		は1となる。

 		省略可能な引数{arg}は以下の値をサポートする:
			$	最後のタブページの番号(つまりタブページの個
				数)。
			#	最後に利用したタブページの番号(|g<Tab>| で移動
				できる)。前のタブページが無い場合は 0 を返す。
		この番号はコマンド|:tab|で指定できるものと同じである。

		エラーの場合はゼロを返す。


tabpagewinnr({tabarg} [, {arg}])			*tabpagewinnr()*
		|winnr()|と同様だが、タブページ{tabarg}を対象とする。
		{tabarg}は対象とするタブページの番号を指定する。
		{arg}は|winnr()|の場合と同じように扱われる。すなわち:
		- 省略するとカレントウィンドウの番号を返す。これは、このタブ
		  ページに入るとき使われるウィンドウである。
		- "$" とするとウィンドウの個数を返す。
		- "#" とすると前のウィンドウ番号を返す。
		役に立つ例: >
		    tabpagewinnr(1)	    " タブページ1のカレントウィンドウ
		    tabpagewinnr(4, '$')    " タブページ4内のウィンドウの個数
<		{tabarg}が無効なときは0を返す。

		|method| としても使用できる: >
			GetTabpage()->tabpagewinnr()
<
							*tagfiles()*
tagfiles()	カレントバッファにおいて、タグを検索するときに使うファイルの名
		前からなるリスト|List|を返す。オプション 'tags' を展開したもので
		ある。


taglist({expr} [, {filename}])				*taglist()*
		正規表現 {expr} にマッチするタグのリスト |List| を返す。

		{filename} が渡された場合、|:tselect| と同じ方法で結果を優先順
		位付けするために使われる。|tag-priority| を参照。
		{filename} はファイルの絶対パスでなければならない。

		そのリストの各要素は辞書であり、少なくとも次の要素を持つ:
			name		タグの名前。
			filename	タグの定義があるファイルの名前。カレン
					トディレクトリからの相対パス、またはフ
					ルパスである。
			cmd		そのファイルの中でタグの位置を特定する
					ために使うexコマンド。
			kind		タグの種類。種類は言語に依存する。この
					要素は、Universal/Exuberant ctagsか
					hdrtagによって生成されたタグファイルを
					使っているときのみ使用できる。
			static		ファイル固有のタグ。より詳しくは
					|static-tag|を参照。
		タグファイルの内容によってはこれ以上の要素が存在することもある。
		例: アクセス、実装、継承、シグネチャ。これらのフィールドについ
		ての情報はctagsのドキュメントを参照。Cのソースにおいては、
		フィールド "struct"、"class"、"enum" が現れることがある。これ
		らは、タグを含んでいるものの名前を示す。

		exコマンド "cmd" は検索パターンか、行番号か、行番号とバイト番
		号のいずれかである。

		マッチするタグがない場合は空リストを返す。

		完全一致するタグを取得するには、{expr}にアンカー '^' と '$' を
		つけること。これは関数の動作を速くすることにもなる。タグ検索の
		正規表現についてより詳しいことは |tag-regexp|を参照。

		Vimが使用するタグファイルについては |'tags'| を参照。様々な
		ctagsによって生成されるタグファイルのフォーマットについては
		|tags-file-format|を参照。

		|method| としても使用できる: >
			GetTagpattern()->taglist()

tan({expr})						*tan()*
		{expr} の正接 (タンジェント) をラジアンで返す。
		値は [-inf, inf] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か数値 (|Number|) でなければな
		らない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo tan(10)
<			0.648361 >
			:echo tan(-4.01)
<			-1.181502

		|method| としても使用できる: >
			Compute()->tan()


tanh({expr})						*tanh()*
		{expr} の双曲線正接 (ハイパボリックタンジェント) を返す。
		値は [-1, 1] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か数値 (|Number|) でなければな
		らない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			:echo tanh(0.5)
<			0.462117 >
			:echo tanh(-1)
<			-0.761594

		|method| としても使用できる: >
			Compute()->tanh()


tempname()					*tempname()* *temp-file-name*
		結果は文字列で、存在しないファイルのファイル名を示す。これはテ
		ンポラリファイルの名前として使用可能である。少なくとも連続26回
		の呼出しまでは違う名前を生成することが保証される。例: >
			:let tmpfile = tempname()
			:exe "redir > " .. tmpfile
<		Unix では、ファイルはプライベートなディレクトリに置かれる。
		|tempfile|
		MS-Windowsでは、'shellslash' がオンのときか、'shellcmdflag' が
		'-' で始まり 'shell' が powershell か pwsh を含まない時はスラッ
		シュが使われる。

term_ 関数群はここに文書化されている: |terminal-function-details|


terminalprops()						*terminalprops()*
		Vimが |t_RV| 問い合せの応答から検知した端末のプロパティを辞書
		|Dictionary| として返す。応答自体は |v:termresponse| を参照。
		もし |v:termresponse| が空の時はここにある多くの値は不明を表す
		'u' になる。
		   cursor_style		|t_RS| を送って動くか **
		   cursor_blink_mode	|t_RC| を送って動くか **
		   underline_rgb	|t_8u| が動くか **
		   mouse		サポートするマウスのタイプ
		   kitty		Kitty 端末が検出されたか

		** 不明ならば値 'u'、はいで 'y'、いいえで 'n'

		|+termresponse| 機能が無いならば、結果は空の辞書になる。

		"cursor_style" が 'y' の時、|t_RS| で現在のカーソルのスタイル
		の問い合せが送られる。
		"cursor_blink_mode" が 'y' の時、|t_RC| でカーソルの点滅のス
		テータスの問い合せが送られる。
		"cursor_style" と "cursor_blink_mode" はまた |t_u7| が空でな
		く、Vim が起動時に |t_RS| と |t_RC| を送って動くか検知すること
		でも設定される。

		"underline_rgb" が 'y' でない時に、|t_8u| は空になる。これはそ
		れを xterm に送ってしまうことで、色をクリアするのを回避する。

		"mouse" の 'u' は不明なときになる。

		以下も参照:
		- 'ambiwidth' - |t_u7| を使って検知する。
		- |t_RS| と |t_RC| の応答については |v:termstyleresp| と
		  |v:termblinkresp| を参照。


test_ 関数群はここに文書化されている: |test-functions-details|

							*timer_info()*
timer_info([{id}])
		タイマーに関する情報のリストを返す。
		{id} が指定された場合はそのタイマーに関する情報だけが返され
		る。タイマー {id} が存在しない場合は空のリストが返される。
		{id} が省略された場合は全てのタイマーに関する情報が返される。

		各タイマーの情報は以下の項目を含んだ辞書 |Dictionary| で格納さ
		れる:
		    "id"	    タイマーのID
		    "time"	    タイマーが開始してからの時間
		    "remaining"	    タイマーが発火するまでの時間
		    "repeat"	    何回タイマーを発火させるかの回数;
				    -1 は無限を意味する
		    "callback"	    コールバック
		    "paused"	    タイマーが一時停止中なら 1、それ以外は 0

		|method| としても使用できる: >
			GetTimer()->timer_info()

<		{|+timers| 機能を有効にしてコンパイルしたときのみ有効}

timer_pause({timer}, {paused})				*timer_pause()*
		タイマーを一時停止もしくは再開する。一時停止したタイマーは時間
		が経過してもコールバックを呼び出さない。タイマーの再開は十分
		に時間が経過しているなら、すぐさまコールバックが呼び出されるか
		もしれない。

		タイマーの停止は少しの間、コールバックが呼び出されるのを避ける
		のに便利である。

		{paused} が 0 以外の数値、もしくは空でない文字列で評価される
		場合にタイマーが停止し、それ以外は再開する。
		|non-zero-arg| を参照。

		|method| としても使用できる: >
			GetTimer()->timer_pause(1)

<		{|+timers| 機能を有効にしてコンパイルしたときのみ有効}

						*timer_start()* *timer* *timers*
timer_start({time}, {callback} [, {options}])
		タイマーを作成しその ID を返す。

		{time} はミリ秒での待機時間。これはコールバックが呼び出される
		までの最短の時間である。システムがビジーもしくは Vim が入力待
		ちでない場合、これは長くなる。
		ゼロは、Vim がメインループに戻った時にコールバックを実行するた
		めに使うことができる。

		{callback} は呼び出す関数。関数の名前もしくは|Funcref|であって
		も良い。引数にはタイマーIDの引数が1つだけ渡されて呼び出され
		る。コールバックは Vim が入力待ちの場合だけ呼び出される。
		メッセージの表示を望むなら、|popup_notification()| を見てユー
		ザーの入力との干渉を回避すること。

		{options} は辞書。以下がサポートされている:
		   "repeat"	コールバックを呼び出す繰り返し回数。-1 は無限
				を意味する。指定されない場合はコールバックは一
				度だけ呼び出される。
				タイマーが 3 回連続してエラーを発生させた場合、
				繰り返しはキャンセルされる。これは、すべてのエ
				ラーメッセージによって Vim が使用不可になるの
				を防ぐ。

		エラーの場合は -1 を返す。

		例: >
			func MyHandler(timer)
			  echo 'Handler called'
			endfunc
			let timer = timer_start(500, 'MyHandler',
				\ {'repeat': 3})
<		これは MyHandler() を 500ms 間隔で3回呼び出す。

		|method| としても使用できる: >
			GetMsec()->timer_start(callback)

<		|sandbox| では利用できない。
		{|+timers| 機能を有効にしてコンパイルしたときのみ有効}

timer_stop({timer})					*timer_stop()*
		タイマーを停止する。タイマーのコールバックは以降呼び出されな
		い。{timer} は timer_start() が返した ID である。よって数値で
		なければならない。{timer} が存在しなかった場合でもエラーは発生
		しない。

		|method| としても使用できる: >
			GetTimer()->timer_stop()

<		{|+timers| 機能を有効にしてコンパイルしたときのみ有効}

timer_stopall()						*timer_stopall()*
		全てのタイマーを停止する。タイマーのコールバックは以降呼び出さ
		れない。タイマーが不作法に振る舞う場合に便利である。タイマーが
		存在しなかった場合でもエラーは発生しない。

		{|+timers| 機能を有効にしてコンパイルしたときのみ有効}

tolower({expr})						*tolower()*
		引数の文字列の大文字を小文字に変換してできた文字列を返す(文字
		列に|gu|を適用するのとちょうど同じ)。エラーの場合は空の文字列
		を返す。

		|method| としても使用できる: >
			GetText()->tolower()

toupper({expr})						*toupper()*
		引数の文字列の小文字を大文字に変換してできた文字列を返す(文字
		列に|gU|を適用するのとちょうど同じ)。エラーの場合は空の文字列
		を返す。

		|method| としても使用できる: >
			GetText()->toupper()

tr({src}, {fromstr}, {tostr})				*tr()*
		文字列{src}の中で、{fromstr}に含まれる全ての文字を{tostr}の対
		応する文字で置き換えた文字列を返す。つまり、{fromstr}の最初の
		文字が{tostr}の最初の文字に置き換えられる。2文字目以降も同様。
		Unixのコマンド "tr" とちょうど同じである。
		マルチバイト文字も正しく扱える。

		エラーの場合は空の文字列を返す。

		例: >
			echo tr("hello there", "ht", "HT")
<		戻り値は "Hello THere" となる。 >
			echo tr("<blob>", "<>", "{}")
<		戻り値は "{blob}" となる。

		|method| としても使用できる: >
			GetText()->tr(from, to)

trim({text} [, {mask} [, {dir}]])				*trim()*
		{text} の先頭と/もしくは末尾から、{mask} 内のすべての文字を取
		り除いた文字列を返す。

		{mask} が指定されていないか、空の文字列の場合、{mask} は 0x20
		までのすべての文字となり、これにはタブ、空白、NL および CR に
		加え、ノーブレークスペース文字 0xa0 が含まれる。

		オプショナル引数 {dir} は削除する文字の位置を示す:
			0	{text} の先頭と末尾から削除する
			1	{text} の先頭のみから削除する
			2	{text} の末尾のみから削除する
		省略した場合は両端を切り取る。

		この関数はマルチバイト文字を正しく扱える。
		エラーの場合は空の文字列を返す。

		例: >
			echo trim("   some text ")
<		"some text" を返す >
			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") .. "_TAIL"
<		"RESERVE_TAIL" を返す >
			echo trim("rm<Xrm<>X>rrm", "rm<>")
<		"Xrm<>X" を返す (中央部分の文字は取り除かれない) >
			echo trim("  vim  ", " ", 2)
<		"  vim" を返す

		|method| としても使用できる: >
			GetText()->trim()

trunc({expr})							*trunc()*
		{expr} をゼロ方向に切りつめた整数を |Float| で返す。
		{expr} は |Float| または |Number| に評価されなければならない。
		{expr} が |Float| または |Number| でない場合は 0.0 を返す。
		例: >
			echo trunc(1.456)
<			1.0  >
			echo trunc(-5.456)
<			-5.0  >
			echo trunc(4.0)
<			4.0

		|method| としても使用できる: >
			Compute()->trunc()
<
							*type()*
type({expr})	{expr}の型を示す数値を返す。
		マジックナンバーを使わずに、v:t_ 変数を使う方が良い。それぞれ
		の値は以下の通り:
			数値:	       0  |v:t_number|
			文字列:	       1  |v:t_string|
			Funcref:       2  |v:t_func|
			リスト:	       3  |v:t_list|
			辞書:	       4  |v:t_dict|
			浮動小数点数:  5  |v:t_float|
			真偽値:	       6  |v:t_bool| (v:false と v:true)
			特殊値:	       7  |v:t_none| (v:null と v:none)
			ジョブ:	       8  |v:t_job|
			チャネル:      9  |v:t_channel|
			Blob:	      10  |v:t_blob|
			クラス:	      12  |v:t_class|
			オブジェクト: 13  |v:t_object|
			型エイリアス: 14  |v:t_typealias|
			列挙型:	      15  |v:t_enum|
			列挙値:	      16  |v:t_enumvalue|
		後方互換性のためには、次のような使い方ができる: >
			:if type(myvar) == type(0)
			:if type(myvar) == type("")
			:if type(myvar) == type(function("tr"))
			:if type(myvar) == type([])
			:if type(myvar) == type({})
			:if type(myvar) == type(0.0)
			:if type(myvar) == type(v:false)
			:if type(myvar) == type(v:none)
<		v:t_ 変数が存在するかを判定するにはこれを使う: >
			:if exists('v:t_number')

<		|method| としても使用できる: >
			mylist->type()


typename({expr})					*typename()*
		{expr} の型について表す文字列を返す。
		例: >
			echo typename([1, 2, 3])
<			list<number> ~


undofile({name})					*undofile()*
		{name} という名前のファイルの保存時に使用されるアンドゥファイ
		ルの名前を返す。'undodir' オプションが使用され、存在するディレ
		クトリが検索される。アンドゥファイルが存在するかどうかはチェッ
		クされない。
		{name} は常に絶対パスに展開される (内部では絶対パスを使ってい
		るため)。
		{name} が空の場合 undofile() は空文字列を返す。ファイル名のな
		いバッファはアンドゥファイルを書かないからである。
		|:wundo| や |:rundo| と組み合わせて使うと便利だろう。
		|+persistent_undo| オプションを無効にしてコンパイルされた場合
		はこの関数は常に空文字列を返す。

		|method| としても使用できる: >
			GetFilename()->undofile()

undotree([{buf}])					*undotree()*
		カレントバッファ、または {buf} が指定されている場合は特定のバッ
		ファのアンドゥツリーの現在の状態を返す。結果は、以下の項目を含
		む辞書である:
		  "seq_last"	使用されたアンドゥシーケンス番号の最大値。
		  "seq_cur"	アンドゥツリーの現在のシーケンス番号。いくつか
				の変更がアンドゥされた状態だと "seq_last" と違
				う値になる。
		  "time_cur"	最後に |:earlier| 系のコマンドが使われた時間。
				読みやすい形式に変換するには |strftime()| を使
				う。
		  "save_last"	最後にファイルが保存された番号。保存がまだなら
				ゼロになる。
		  "save_cur"	アンドゥツリー内の現在位置の番号。
		  "synced"	最後のアンドゥブロックが同期されていれば非ゼ
				ロ。これはユーザーからの入力を待機しているとき
				に起こる。|undo-blocks| 参照。
		  "entries"	アンドゥブロックの情報を表す辞書のリスト。

		"entries" リストの 1 番目にはもっとも古いアンドゥアイテムが入っ
		ている。リストの各アイテムは次のような情報を持った辞書
		|Dictionary| である:
		  "seq"		アンドゥシーケンス番号。|:undolist| で表示され
				るものと同じ。
		  "time"	変更が起こった時間。読みやすい形式に変換するに
				は |strftime()| を使う。
		  "newhead"	この項目は最後に追加されたアイテムにのみある。
				これは最後の変更を示し、次の変更を追加する場所
				を示す。
		  "curhead"	この項目は最後にアンドゥされたアイテムにのみあ
				る。これはアンドゥツリーの現在位置を示し、次に
				リドゥコマンドによって使われるブロックを示す。
				最後に変更を加えてからアンドゥを一度も実行して
				いないときはこの項目はどこにも現れない。
		  "save"	この項目はファイルが保存される前の最後のブロッ
				クにのみある。番号は保存回数を示す。最初の保存
				は 1 で、最後のものは "save_last" と同じ。
		  "alt"		切り替えエントリ。同じアンドゥブロックのリスト
				が入れ子にされている。それぞれのアイテムはさら
				に "alt" アイテムを持っていることがある。

uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
		{list} 内の隣接する同じ値の要素の 2 個目以降をその場で
		(in-place) 削除する。{list} を返す。リストを変更したくない場合
		は事前にコピーする: >
			:let newlist = uniq(copy(mylist))
<		デフォルトの比較関数は各要素の文字列表現を使う。{func} と
		{dict} については |sort()| 参照。

		{list} が |List| でない場合はゼロを返す。

		|method| としても使用できる: >
			mylist->uniq()
<
							*utf16idx()*
utf16idx({string}, {idx} [, {countcc} [, {charidx}]])
		|charidx()| と同じだが、{string} の {idx} にあるバイトの
		UTF-16 コード単位インデックスを返す (UTF-16 に変換後)。

		{charidx} が存在し、TRUE の場合、{idx} はバイトインデックスと
		してではなく、文字列 {string} 内の文字インデックスとして使用さ
		れる。
		UTF-8 シーケンスの途中にある {idx} は、そのシーケンスの先頭に
		丸め込まれる。

		引数が無効な場合、または {string} 内のバイト数が {idx} バイト
		未満の場合は、-1 を返す。ちょうど {idx} バイトの場合は、UTF-16
		コード単位の文字列の長さが返される。

		UTF-16 インデックスからバイトインデックスを取得するには
		|byteidx()| と |byteidxcomp()| を、UTF-16 インデックスから文字
		インデックスを取得するには |charidx()| を参照。
		詳細は |string-offset-encoding| を参照。
		例: >
			echo utf16idx('a😊😊', 3)	returns 2
			echo utf16idx('a😊😊', 7)	returns 4
			echo utf16idx('a😊😊', 1, 0, 1)	returns 2
			echo utf16idx('a😊😊', 2, 0, 1)	returns 4
			echo utf16idx('aą́c', 6)		returns 2
			echo utf16idx('aą́c', 6, 1)	returns 4
			echo utf16idx('a😊😊', 9)	returns -1
<
		|method| としても使用できる: >
			GetName()->utf16idx(idx)


values({dict})						*values()*
		{dict}の全ての値からなるリスト|List|を返す。このリストの順序は
		不定である。|items()| と |keys()| も参照。
		{dict} が |Dict| でない場合はゼロを返す。

		|method| としても使用できる: >
			mydict->values()

virtcol({expr} [, {list} [, {winid}]])			*virtcol()*
		結果は数値で、{expr}で与えられるファイルの位置の、スクリーン上
		での桁の位置を示す。返る値は、指定された位置にある文字の末尾が、
		スクリーン座標(の桁)でどこに存在するかである。<Tab>(タブ文字)
		が指定した位置にあった場合には、戻り値はそのタブの最後のカラム
		(桁)位置になる。具体的に、'ts' が8に設定された状態で第1桁に
		<Tab>があった場合、戻り値は8になる。|conceal| は無視される。
		バイト位置については |col()| を使う。

		{expr}の解釈の仕方については|col()|を参照。
		'virtualedit' がオンのときは[lnum, col, off]というリストを指定
		することもできる。"off" は文字の開始位置からのスクリーン座標で
		のオフセットである。例えば、<Tab>の中の位置や、行の最後の文字
		以降の位置を示すために使う。"off" が省略された場合はゼロが使わ
		れる。
		現在のモードに対して仮想編集がオンのときは、行末を越えた位置が
		返ってくることもある。|'virtualedit'| も参照。
		可能な位置指定:
		    .	    カーソルの位置
		    $	    カーソル行の末尾(カーソル行に表示されている文字数
			    +1となる)
		    'x	    マークxの位置(マークが設定されていない場合、0が返
			    る)
		    v	    ビジュアルモードでは: ビジュアル選択領域の開始行
			    (カーソルがその端)。ビジュアルモード以外ではカーソ
			    ル位置を返す。すぐに更新される点が |'<| と違う。

		{list} が存在し、非ゼロの場合、virtcol() は、文字が占める最初
		と最後のスクリーン位置を含むリストを返す。

		オプションの {winid} 引数を使用すると、カレントウィンドウの代
		わりにそのウィンドウの値が取得される。

		現在のファイルに対して設定されているマークだけが使用可能なこと
		に注意。
		例: >
			" テキスト "foo^Lbar" で、カーソルが "^L" の上にある:

			virtcol(".")	" 戻り値 5
			virtcol(".", 1)	" 戻り値 [4, 5]
			virtcol("$")	" 戻り値 9

			" テキスト "	  there" で、'h' のところに 't:

			virtcol("'t")	" 戻り値 6
<		最初の桁は 1 である。エラーの場合は、0 または [0, 0] が返され
		る:
		より高度な例(全ての行の長さの最大値を返す): >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))

<		|method| としても使用できる: >
			GetPos()->virtcol()

virtcol2col({winid}, {lnum}, {col})			*virtcol2col()*
		結果は数値で、ウィンドウ {winid} のバッファ行 {lnum} および仮
		想桁 {col} の文字のバイトインデックスである。

		バッファ行 {lnum} が空行の場合、0 が返される。

		{col} が行 {lnum} の最後の仮想桁より大きい場合、最後の仮想桁の
		文字のバイトインデックスが返される。

		マルチバイト文字の場合、文字の最初のバイトの桁番号が返される。

		{winid} 引数には、ウィンドウ番号または |window-ID| を指定でき
		る。これがゼロの場合、カレントウィンドウが使用される。

		ウィンドウ {winid} が存在しない場合、またはバッファ行 {lnum}
		または仮想桁 {col} が無効な場合は、-1 を返す。

		|screenpos()|, |virtcol()| および |col()| も参照。

		|method| としても使用できる: >
			GetWinid()->virtcol2col(lnum, col)

visualmode([{expr}])						*visualmode()*
		結果は文字列で、カレントバッファ内で最後に使われたビジュアル
		モードを教えてくれる。初期状態では単に空文字列を返すだけだが、
		一度でもビジュアルモードが使われた場合、その種類によって "v"
		か "V" か "<CTRL-V>" (CTRL-Vの文字が1文字で) 返される。これは
		それぞれ文字選択、行選択、矩形選択を意味している。
		例: >
			:exe "normal " .. visualmode()
<		これは最後に使われたのと同じビジュアルモードに入る。また、スク
		リプトの動作を、最後に使われたビジュアルモードに応じて変更した
		い場合にも便利だろう。
		ビジュアルモードにいるときは |mode()| を使ってビジュアルモード
		の種類を取得できる。(|:vmap| などの中などで)
		{expr}に0以外の数値か空文字列以外の文字列を指定した場合は、ビ
		ジュアルモードがクリアされ、以前の値を返す。|non-zero-arg| を
		参照。

wildmenumode()					*wildmenumode()*
		wildmenuが有効な場合は|TRUE|を返し、そうでなければ|FALSE|を返
		す。'wildmenu' と 'wildmode' を参照。
		マッピングの中で 'wildcharm' オプションを有効に扱うために使用
		できる。(|mapmode-c|マッピングの場合のみ意味をなす。)

		例えば、wildmodeで<c-j>が<down>と同じように動作するようにする
		には: >
    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
<
		(Note 'wildcharm' オプションが適切に設定されている必要がある。)

win_execute({id}, {command} [, {silent}])		*win_execute()*
		`execute()` と似ているが、ウィンドウ {id} のコンテキスト内で実
		行する。
		自動コマンドを発生させないかディレクトリを変更しないで、ウィン
		ドウを一時的にカレントウィンドウにする。{command} を実行する
		と、自動コマンドがトリガーされる。これは予期しない副作用を引き
		起こす可能性がある。必要であれば `:noautocmd` を使用すること。
		例: >
			call win_execute(winid, 'set syntax=python')
<		`setwinvar()` で同じことをしても自動コマンドはトリガーされず、
		実際には構文ハイライトは表示されない。
							*E994*
		すべてのコマンドがポップアップウィンドウで許可されているわけで
		はない。
		ウィンドウ {id} が存在しない場合、エラーは発生せず空の文字列を
		返す。

		|method| としても使用でき、ベースは第2引数として渡される: >
			GetCommand()->win_execute(winid)

win_findbuf({bufnr})					*win_findbuf()*
		バッファ {bufnr} が含まれているウィンドウについて |window-ID|
		のリスト |List| を返す。存在しない場合は空のリストになる。

		|method| としても使用できる: >
			GetBufnr()->win_findbuf()

win_getid([{win} [, {tab}]])				*win_getid()*
		特定のウィンドウに関する |window-ID|を得る。
		{win} が未指定の時は現在のウィンドウとなる。
		この {win} はウィンドウ番号である。トップウィンドウは番号 1 を
		持つ。
		{tab} が未指定の場合現在のタブが使用され、{tab} が番号で指定さ
		れた場合はそのタブとなる。最初のタブ番号は 1 である。
		ウィンドウが見付からない場合には 0 を返す。

		|method| としても使用できる: >
			GetWinnr()->win_getid()


win_gettype([{nr}])					*win_gettype()*
		ウィンドウの種別を返す:
			"autocmd"	自動コマンドのウィンドウ。自動コマンド
					を実行するに使う一時的なウィンドウ。
			"command"	コマンドラインウィンドウ |cmdwin|
			(empty)		通常のウィンドウ
			"loclist"	|location-list-window|
			"popup"		ポップアップウィンドウ |popup|
			"preview"	プレビューウィンドウ |preview-window|
			"quickfix"	|quickfix-window|
			"unknown"	ウィンドウ{nr}が見付からない

		{nr} を省略した場合は現在のウィンドウの種別を返す。
		{nr} が与えられた場合はそのウィンドウ番号または |window-ID| の
		種別を返す。

		'buftype' オプションも参照すること。ポップアップウィンドウ上で
		ターミナルが起動している場合、'buftype' は "terminal" であり、
		win_gettype() は "popup" を返す。

		|method| としても使用できる: >
			GetWinid()->win_gettype()
<
win_gotoid({expr})					*win_gotoid()*
		{expr} の ID で示されるウィンドウへ移動する。これは現在のタブ
		ページも移動する。
		成功した場合は真を、ウィンドウが見付からない場合は偽を返す。

		|method| としても使用できる: >
			GetWinid()->win_gotoid()

win_id2tabwin({expr})					*win_id2tabwin()*
		{expr} の ID で示されるタブ番号とウィンドウ番号のリストを返す:
		[tabnr, winnr]
		ウィンドウが見付からなかった場合は [0, 0] を返す。

		|method| としても使用できる: >
			GetWinid()->win_id2tabwin()

win_id2win({expr})					*win_id2win()*
		{expr} の ID で示されるウィンドウのウィンドウ番号を返す。
		現在のタブページ内でそのウィンドウが見付からなかった場合は 0
		を返す。

		|method| としても使用できる: >
			GetWinid()->win_id2win()

win_move_separator({nr}, {offset})			*win_move_separator()*
		ウィンドウ {nr} の垂直セパレータ(例えば、右側のボーダー)を
		{offset} 桁分、マウスでドラッグしたかのように動かす。{nr} は
		ウィンドウ番号もしくは |window-ID| が使える。正の値の {offset}
		は右への移動になり負の値の {offset} は左への移動になる。ウィン
		ドウの垂直セパレータの移動はウィンドウの幅と垂直セパレータで隣
		接する他のウィンドウの幅を変更しうる。移動の変更量の大きさは指
		定したよりは小さくなりうる(例えば、'winminwidth' 変更の帰結と
		して)。ウィンドウを見付ければ戻り値が TRUE になり、そうでない
		なら FALSE になる。
		最右のウィンドウや全幅ウィンドウでは、右端にセパレーターがない
		ため失敗する。
		カレントタブページに対してのみ動作する。 *E1308*

		|method| としても使用できる: >
			GetWinnr()->win_move_separator(offset)

win_move_statusline({nr}, {offset})			*win_move_statusline()*
		ウィンドウ {nr} のステータス行(例えば、下側のボーダー)を
		{offset} 行分、マウスでドラッグしたかのように動かす。{nr} は
		ウィンドウ番号もしくは |window-ID| が使える。正の値の {offset}
		は下への移動になり負の値の {offset} は上への移動になる。ウィン
		ドウのステータス行の移動はウィンドウの高さとステータス行で隣接
		する他のウィンドウの高さを変更しうる。移動の変更量の大きさは指
		定したよりは小さくなりうる(例えば、'winminheight' 変更の帰結と
		して)。ウィンドウを見付ければ戻り値が TRUE になり、そうでない
		なら FALSE になる。
		カレントタブページでのみ動作する。

		|method| としても使用できる: >
			GetWinnr()->win_move_statusline(offset)

win_screenpos({nr})					*win_screenpos()*
		ウィンドウ {nr} のスクリーン位置を 2 つの数値のリストで返す:
		[row, col]。タブラインがない限り先頭のウィンドウは常に [1, 1]
		の位置となり、タブラインがある場合は [2, 1] となる。
		{nr} にはウィンドウ番号もしくは |window-ID| を指定する。現在の
		ウィンドウには0を使う。
		対象のウィンドウが見つからない場合、[0, 0] を返す。

		|method| としても使用できる: >
			GetWinid()->win_screenpos()
<
win_splitmove({nr}, {target} [, {options}])		*win_splitmove()*
		一時的にウィンドウ {target} に移り、そしてウィンドウ {nr} を
		{target} に隣接する新しい分割に移動する。
		|:split| などのコマンドと異なり、新しいウィンドウは作成されな
		い (ウィンドウ {nr} の |window-ID| は移動後も変更されない)。

		{nr} と {target} の両方とも、ウィンドウ番号または |window-ID|
		である。両方とも現在のタブページになければならない。

		成功時は 0、失敗時は非0 を返す。

		{options}は、次のオプションエントリを持つ辞書 |Dictionary| で
		ある:
		  "vertical"	TRUEの場合、|:vsplit| と同様に、分割が垂直に作
				成される。
		  "rightbelow"	TRUEの場合、分割は下または右(垂直の場合)に行わ
				れる。FALSEの場合、上または左(垂直の場合)に行
				われる。未指定の場合、'splitbelow' および
				'splitright' の値が使用される。

		|method| としても使用できる: >
			GetWinid()->win_splitmove(target)
<

							*winbufnr()*
winbufnr({nr})	結果は数値で、{nr}番目のウィンドウに関連付けられているバッファ
		の番号。{nr} にはウィンドウ番号または|window-ID|が使える。
		{nr}が0の場合、現在のウィンドウに関連付けられているバッファの
		番号が返る。{nr}で存在しないウィンドウを指定した場合には-1が返
		る。
		例: >
  :echo "The file in the current window is " . bufname(winbufnr(0))
<
		|method| としても使用できる: >
			FindWindow()->winbufnr()->bufname()
<
							*wincol()*
wincol()	結果は数値で、ウィンドウの中でカーソルがある位置の仮想桁番号を
		表す。これはウィンドウの左側から数えたスクリーン上の桁である。
		一番左の桁は1となる。

							*windowsversion()*
windowsversion()
		文字列を返す。MS-Windows では OS のバージョンを示す。例えば、
		Windows 10 は "10.0"、Windows 8 は "6.2"、Windows XP は "5.1"
		である。MS-Windows 以外のシステムでは、結果は空文字列である。

winheight({nr})						*winheight()*
		結果は数値で、{nr}で示されるウィンドウの高さ(行数)を示す。
		{nr} にはウィンドウ番号または|window-ID|が使える。
		{nr}が0ならば、現在のウィンドウの高さが返る。{nr}というウィン
		ドウが存在しない場合、-1が返る。存在しているウィンドウは、絶対
		に0かそれ以上の高さを持っている。
		ウィンドウツールバーはすべて除く。
		例: >
  :echo "The current window has " .. winheight(0) .. " lines."

<		|method| としても使用できる: >
			GetWinid()->winheight()
<
winlayout([{tabnr}])					*winlayout()*
		結果は、タブページ内のウィンドウの配置を含むネストしたリストで
		ある。

		{tabnr} が与えられない場合は現在のタブページを使い、それ以外は
		番号 {tabnr} のタブページとなる。{tabnr} のタブページが見つか
		らない場合、空リストを返す。

		末端 (leaf) のウィンドウでは以下が返る:
			['leaf', {winid}]
		列を形成する水平に分割されたウィンドウでは以下が返る:
			['col', [{ウィンドウのネストしたリスト}]]
		行を形成する垂直に分割されたウィンドウではいかが返る:
			['row', [{ウィンドウのネストしたリスト}]]

		例: >
			" タブページ内に一つのウィンドウのみ
			:echo winlayout()
			['leaf', 1000]
			" 水平に分割された 2 つのウィンドウ
			:echo winlayout()
			['col', [['leaf', 1000], ['leaf', 1001]]]
			" 2番目のタブページが水平に分割された 3 つのウィンドウ
			" で、かつ真ん中のウィンドウが 2 つのウィンドウに垂直
			" に分割されている
			:echo winlayout(2)
			['col', [['leaf', 1002], ['row', [['leaf', 1003],
					    ['leaf', 1001]]], ['leaf', 1000]]]
<
		|method| としても使用できる: >
			GetTabnr()->winlayout()
<
							*winline()*
winline()	結果は数値で、ウィンドウの最上行から数えた行番号を返す。ウィン
		ドウでの最上行が1となる。
		カーソルが移動するとファイルの表示が更新され、それによってスク
		ロールが引き起こされることがある。

							*winnr()*
winnr([{arg}])	結果は現在のウィンドウを示す数値。最上位のウィンドウは1であ
		る。ポップアップウィンドウは0を返す。

		省略可能な引数{arg}は以下の値をサポートする:
			$	最後のウィンドウの番号(ウィンドウ数)
			#	最後にアクセスしたウィンドウの番号(|CTRL-W_p|
				の行き先)。前のウィンドウがないか、別のタブペー
				ジにある場合は、0が返される。一部のケース (例
				えば 'statusline' 式を評価しているとき) では、
				現在のウィンドウを参照するかもしれない。
			{N}j	現在のウィンドウの下N番目のウィンドウの番号
				(|CTRL-W_j| の行き先)。
			{N}k	現在のウィンドウの上N番目のウィンドウの番号
				(|CTRL-W_k| の行き先)。
			{N}h	現在のウィンドウの左N番目のウィンドウの番号
				(|CTRL-W_h| の行き先)。
			{N}l	現在のウィンドウの右N番目のウィンドウの番号
				(|CTRL-W_l| の行き先)。
		この番号は|CTRL-W_w|と ":wincmd w" で使える。|:wincmd|
		{arg} が無効な場合はエラーが発生し、ゼロが返される。
		|tabpagewinnr()|と|win_getid()|も参照。
		例: >
			let window_count = winnr('$')
			let prev_window = winnr('#')
			let wnum = winnr('3k')

<		|method| としても使用できる: >
			GetWinval()->winnr()
<
							*winrestcmd()*
winrestcmd()	現在のウィンドウサイズを復元するための一連の|:resize|コマンド
		を返す。これが返すコマンドは、ウィンドウを開閉せず、カレント
		ウィンドウとカレントタブページが変更されていないときのみ正しく
		動作する。
		例: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
							*winrestview()*
winrestview({dict})
		|winsaveview()|が返す辞書|Dictionary|を使ってカレントウィンド
		ウの表示状態を復元する。
		Note: {dict} は |winsaveview()| の戻り値に含まれる値をすべて
		持っていなくても構わない。値がない場合はその設定は復元されな
		い。次のようにできる: >
		    :call winrestview({'curswant': 4})
<
		これは curswant 値 (縦方向移動でカーソルの移動先として使われる
		列番号) を列番号 5 に設定する (はいそのとおり。5 です)。ほかの
		設定値は変更されない。これはカーソル位置を手動で設定したい場合
		に便利である。

		この値を手動で変更した場合、結果は予測できない。
		ウィンドウサイズが変更されていると、結果は必ずしも元通りになら
		ない。

		|method| としても使用できる: >
			GetView()->winrestview()
<
							*winsaveview()*
winsaveview()	カレントウィンドウの表示状態を復元するための情報を持つ辞書
		|Dictionary|を返す。この表示状態を復元するには|winrestview()|
		を使う。
		マッピング内でジャンプして、元の表示状態を戻したいときに使われ
		る。
		折り畳み情報は保存しない。オプション 'foldenable' によって一時
		的に折り畳みをオフにし、移動中に折り畳みが開かれないようにする
		こと。これは副作用があるかもしれない。
		戻り値は以下のキーを持つ:
			lnum		カーソルの行番号
			col		カーソルの桁番号 (Note: |getcurpos()|
					とは異なり最初の桁番号はゼロ)
			coladd		カーソル位置の桁オフセット。
					'virtualedit' がオンのとき使われる。
			curswant	垂直移動するときの桁 (Note: 最初のカ
					ラムは0で、|getcurpos()| が返す値と対
					応する)。|$| コマンド後は非常に巨大な
					値として |v:maxcol| と同値になる。
			topline		ウィンドウの最上行
			topfill		削除行。差分モードでのみ
			leftcol		表示されている最初の桁。'wrap' がオフ
					のときのみ。
			skipcol		スキップされている桁
		Note オプションの値は保存されない。


winwidth({nr})						*winwidth()*
		結果は数値で、ウィンドウ{nr}の幅。
		{nr} にはウィンドウ番号または|window-ID|が使える。
		{nr}が0のときはカレントウィンドウの幅を返す。ウィンドウ{nr}が
		存在しないときは-1を返す。ウィンドウは必ず0以上の幅を持つ。
		例: >
  :echo "The current window has " .. winwidth(0) .. " columns."
  :if winwidth(0) <= 50
  :  50 wincmd |
  :endif
<		端末または画面サイズを取得するには、'columns' オプション参照。

		|method| としても使用できる: >
			GetWinid()->winwidth()


wordcount()						*wordcount()*
		この結果は現在のバッファのバイト/文字/単語統計情報の辞書である。
		これは|g_CTRL-G|が提供する情報と同じである。
		この値には下記が含まれる:
			bytes		バッファ内のバイト数
			chars		バッファ内の文字数
			words		バッファ内の単語数
			cursor_bytes    カーソル位置より前のバイト数
					(ビジュアルモードでない)
			cursor_chars    カーソル位置より前の文字数
					(ビジュアルモードでない)
			cursor_words    カーソル位置より前の単語数
					(ビジュアルモードでない)
			visual_bytes    ビジュアル選択領域内のバイト数
					(ビジュアルモードのみ)
			visual_chars    ビジュアル選択領域内の文字数
					(ビジュアルモードのみ)
			visual_words    ビジュアル選択領域内の単語数
					(ビジュアルモードのみ)

							*writefile()*
writefile({object}, {fname} [, {flags}])
		{object}が |List| の場合、それをファイル{fname}に書き込む。リ
		ストの各要素は改行文字(NL)で区切られる。各要素は文字列か数値で
		なければならない。
		すべての NL 文字は NUL 文字に置き換えられる。CR 文字の挿入は、
		{list} を writefile() に渡す前に行う必要がある。

		{object} が |Blob| の場合、バイナリモードが指定されていなくて
		もバイトを変更せずにファイル {fname} に書き込む。

		{flags} は文字列である必要がある。次の文字が認識される:

		'b'  バイナリモードが使われる。最後のリスト項目の後には NL は
		     ない。末尾に空の項目があると、ファイルの最後の行が NL で
		     終了する。

		'a'  追加モードが使われ、行がファイルに追加される: >
			:call writefile(["foo"], "event.log", "a")
			:call writefile(["bar"], "event.log", "a")
<
		'D'  現在の関数が終了したらファイルを削除する。これは次のよう
		     に動作する: >
			:defer delete({fname})
<		     関数内にない場合は失敗する。|:defer| も参照。

		's'  ファイルの書き込み後に fsync() が呼び出される。これによ
		     り、可能であればファイルがディスクにフラッシュされる。こ
		     れには時間が掛かりますが、システムがクラッシュした場合に
		     ファイルが失われることは避けられる。

		'S'  'fsyncs' が設定されている場合でも、fsync() は呼び出されな
		     い。

		     {flags} に "S" または "s" が含まれていない場合、'fsync'
		     オプションが設定されていれば fsync() が呼び出される。

		可能であれば、既存のファイルは上書きされる。

		書き込みが失敗した場合は -1 が返され、それ以外の場合は 0 が返
		される。ファイルを作成できない場合、または書き込みが失敗した場
		合は、エラー メッセージが表示される。

		|readfile()| も参照。
		バイト単位でファイルをコピーするには次のようにする: >
			:let fl = readfile("foo", "b")
			:call writefile(fl, "foocopy", "b")

<		|method| としても使用できる: >
			GetText()->writefile("thefile")


xor({expr}, {expr})					*xor()*
		2 つの引数のビット排他的論理和。引数は数値に変換される。リス
		ト、辞書、浮動小数点数を指定するとエラーになる。
		`and()` および `or()` も参照。
		例: >
			:let bits = xor(bits, 0x80)
<
		|method| としても使用できる: >
			:let bits = bits->xor(0x80)
<

==============================================================================
3. 機能リスト						*feature-list*

機能は大別して 3 つの系統に分けられる:
1.  コンパイル時に|+feature-list|とした時にだけサポートされる機能。例: >
	:if has("cindent")
<							*gui_running*
2.  ある状態の時にだけサポートされる機能。例: >
	:if has("gui_running")
<							*has-patch*
3.  あるバージョンより後か、あるバージョンで特定のパッチが適用されているか。機
    能"patch-7.4.248" は、Vim のバージョンが 7.5 以降であるか、もしくはバージョ
    ンが 7.4 でパッチ 248 が適用されているかを意味する。例: >
	:if has("patch-7.4.248")
<    Note: 249 が適用されていても、248 が抜けている可能性もある。チェリーピッ
    キングされたパッチでのみ発生する。
    Note: この形式はパッチ 7.4.237 以降で機能し、それより前ではパッチと
    v:version の両方を確認する必要がある。例 (バージョン 6.2.148 以降であるこ
    とを確認する): >
	:if v:version > 602 || (v:version == 602 && has("patch148"))

ヒント: Vim がファイル名(MS-Windows)でバックスラッシュをサポートしているかどうか
を調べるには `if exists('+shellslash')` を使用する。


acl			|ACL| をサポート
all_builtin_terms	全ての組込みターミナルを有効にしてコンパイル。(常に
			true)
amiga			AMIGAバージョン
arabic			アラビア語をサポート |Arabic|
arp			ARPをサポート (Amiga)
autocmd			自動コマンドをサポート (常に true)
autochdir		'autochdir' をサポート
autoservername		|clientserver| を自動的に有効化する
balloon_eval		|balloon-eval| をサポート
balloon_multiline	複数行バルーンをサポート
beos			BeOSバージョン
browse			|:browse|をサポートし、browse()が動作する
browsefilter		|browsefilter| をサポート
bsd			BSDファミリのOSでコンパイルされている (macOS を除く)
builtin_terms		幾つかの組込みターミナルが有効。(常に true)
byte_offset		'statusline' において 'o' がサポートされる
channel			|channel| プロセス間通信と |job| ジョブをサポート
cindent			'cindent' をサポート。(常に true)
clientserver		リモート呼び出しをサポート |clientserver|
clipboard		'clipboard' をサポート
clipboard_working	'clipboard' をサポートし、使用可能
cmdline_compl		|cmdline-completion| コマンドライン補完をサポート
cmdline_hist		|cmdline-history| コマンドライン履歴をサポート
cmdline_info		'showcmd' と 'ruler' をサポート
comments		|'comments'| をサポート
compatible		Vi互換度を非常に高めてコンパイルされている
conpty			|ConPTY| を使用できるプラットフォームである
cryptv			暗号化をサポート |encryption|
cscope			|cscope|をサポート
cursorbind		|'cursorbind'| をサポート (常に true)
debug			デバッグバージョンである
dialog_con		コンソールダイアログのサポート
dialog_con_gui		コンソールとGUIのダイアログのサポート
dialog_gui		GUIダイアログのサポート
diff			|vimdiff| と 'diff' のサポート
digraphs		ダイグラフをサポート
directx			DirectX と 'renderoptions' をサポート
dnd			レジスタ "~ をサポート |quote_~|
drop_file		ファイルのドロップ |drop_file| をサポート
ebcdic			EBCDIC文字セットのマシン用
emacs_tags		Emacs式のタグファイルをサポート
eval			式評価をサポート。もちろん常に真。
ex_extra		|+ex_extra| (常に true)
extra_search		|'incsearch'| と |'hlsearch'| をサポート
farsi			|farsi|のサポートは削除された
file_in_path		|gf| と |<cfile>| をサポート。(常に true)
filterpipe		'shelltemp' がオフのとき、シェルの読み込み・書き込み・
			フィルタコマンドにパイプを使う。
find_in_path		includeファイル内の検索をサポート |+find_in_path|
float			浮動小数点数 |Float| サポート
fname_case		ファイル名の大文字小文字が区別される(AmigaとMS-
			Windowsでは区別されないので偽)
folding			|folding| 折り畳みをサポート
footer			GUIのフッターをサポート |gui-footer|
fork			system()の代わりにfork()/exec()を用いている
gettext			翻訳メッセージをサポート |multi-lang|
gui			GUIが有効である
gui_athena		AthenaのGUIが有効である (常に false)
gui_gnome		Gnomeサポート(gui_gtkも定義される)
gui_gtk			GTK+のGUIが有効である
gui_gtk2		GTK+ 2のGUIが有効である (gui_gtkも定義される)
gui_gtk3		GTK+ 3のGUIが有効である (gui_gtkも定義される)
gui_haiku		HaikuのGUIが有効である
gui_mac			マッキントッシュのGUIが有効である
gui_motif		MotifのGUIが有効である
gui_photon		PhotonのGUIが有効である
gui_running		VimがGUIモードで起動している、もしくは間もなくする
gui_win32		Win32のGUIが有効である
gui_win32s		Win32sのGUIが有効である (Windows 3.1)
haiku			Haikuバージョン
hangul_input		ハングル入力サポート
hpux			HP-UXバージョン
iconv			iconv()をサポート
insert_expand		挿入モード時にCTRL-Xの展開がサポートされる (常に true)
job			|channel| プロセス間通信と |job| ジョブをサポート
ipv6			|channel| での IPv6 通信をサポート
jumplist		|jumplist| をサポート。(常に true)
keymap			'keymap' をサポート
lambda			|lambda| をサポート
langmap			'langmap' サポート
libcall			|libcall()| をサポート
linebreak		'linebreak'、'breakat'、'showbreak'、'breakindent' を
			サポート
linux			Linuxバージョン
lispindent		lisp式のインデントをサポート。(常に true)
listcmds		バッファリスト用のコマンド|:files|と引数リスト用のコマ
			ンド|arglist|をサポート
localmap		ローカルなマッピングと短縮入力をサポート|:map-local|
lua			Lua インターフェイスをサポート |Lua|
mac			すべてのマッキントッシュ版Vim、osx を参照
macunix			osxdarwin と同じ
menu			|:menu|をサポート
mksession		|:mksession|をサポート
modify_fname		ファイル名変換子をサポート |filename-modifiers|
			(常に true)
mouse			マウスをサポート
mouse_dec		DECのターミナルマウスをサポート
mouse_gpm		gpmをサポート (Linuxのコンソールマウス)
mouse_gpm_enabled	GPMマウスが動作している
mouse_netterm		nettermのマウスをサポート
mouse_pterm		qnx ptermのマウスをサポート
mouse_sysmouse		sysmouse (*BSD コンソールマウス)をサポート
mouse_sgr		sgrのマウスをサポート
mouse_urxvt		urxvtのマウスをサポート
mouse_xterm		xtermのマウスをサポート
mouseshape		'mouseshape' をサポート
multi_byte		'encoding' をサポート (常に true)
multi_byte_encoding	'encoding' がマルチバイトエンコーディングになる
multi_byte_ime		IMEによる入力をサポート
multi_lang		複数言語をサポート
mzscheme		MzSchemeインターフェイスをサポート |mzscheme|
nanotime		サブ秒のタイムスタンプチェックのサポート
netbeans_enabled	|netbeans|をサポートし、現在接続している
netbeans_intg		|netbeans|をサポート
num64			64ビット |Number| をサポート。(常に true)
ole			Win32にてOLEオートメーションをサポート
osx			macOS 向けにコンパイル、mac を参照
osxdarwin		|mac-darwin-feature| 付きで macOS 向けにコンパイル
packages		|packages|をサポート
path_extra		'path' と 'tags' の上方・下方検索をサポート
perl			Perlインターフェイスをサポート
persistent_undo		永続アンドゥをサポート
postscript		PostScriptファイルの印刷をサポート
printer			|:hardcopy| をサポート
profile			|:profile| をサポート
prof_nsec		プロファイルの結果はナノ秒単位。
python			Python 2.x インターフェイスが使用可能。|has-python|
python_compiled		Python 2.x インターフェイス付きでコンパイルされた。
			|has-python|
python_dynamic		Python 2.x インターフェイスが動的にロードされた。
			|has-python|
python3			Python 3.x インターフェイスが使用可能。|has-python|
python3_compiled	Python 3.x インターフェイス付きでコンパイルされた。
			|has-python|
python3_dynamic		Python 3.x インターフェイスが動的にロードされた。
			|has-python|
python3_stable		Python 3.x インターフェイスは Python Stable ABI を使
			用。 |has-python|
pythonx			Python 2.x と/もしくは Python 3.x インターフェイスが使用可能。|python_x|
qnx			QNXバージョン
quickfix		|quickfix|をサポート
reltime			|reltime()|をサポート
rightleft		'rightleft' をサポート
ruby			Rubyインターフェイスをサポート
scrollbind		'scrollbind' をサポート (常に true)
showcmd			'showcmd' をサポート
signs			|:sign|をサポート
smartindent		'smartindent' をサポート。(常に true)
sodium			libsodium ライブラリによるより良い暗号のサポート
sound			サウンド再生をサポート。例えば、`sound_playevent()`
spell			スペルチェックをサポート |spell|
startuptime		|--startuptime| をサポート
statusline		'statusline', 'rulerformat' そして 'titlestring' と
			'iconstring' の特殊フォーマットをサポート
sun			SunOSバージョン
sun_workshop		Sun |workshop| のサポートは削除された
syntax			構文ハイライトをサポート
syntax_items		現在のバッファに有効なシンタックスが設定されている
system			fork()/exec()の代わりにsystem()が使用されている
tag_binary		タグファイル内の二分探索 |tag-binary-search|。(常に
			true)
tag_old_static		旧式の静的tagsのサポートは削除された |tag-old-static|
tcl			TCLインターフェイスをサポート
termguicolors		端末でのtrueカラーをサポート
terminal		|terminal| をサポート
terminfo		termcapの代わりにterminfoをサポート
termresponse		|t_RV|と|v:termresponse|をサポート
textobjects		|text-objects|をサポート
textprop		|text-properties| をサポート
tgetent			tgetentをサポート。termcapかterminfoファイルが使用可能
timers                  |timer_start()| をサポート
title			ウィンドウタイトルをサポート |'title'|。(常に true)
toolbar			|gui-toolbar|をサポート
ttyin			入力が端末 (tty) である
ttyout			出力が端末 (tty) である
unix			Vim の Unix バージョン。 *+unix*
unnamedplus		'clipboard' に "unnamedplus" をサポート
user_commands		ユーザー定義コマンドをサポート (常に true)
vartabs			可変タブストップをサポート |'vartabstop'|.
vcon			Win32: 仮想コンソールサポートが機能していて、
			'termguicolors' を使用することができる。|+vtp| も参照。
vertsplit		ウィンドウの垂直分割をサポート |:vsplit| (常に true)
vim_starting		Vimの初期化プロセス中は真となる。|startup|
			*vim_starting*
vim9script		|Vim9| script をサポート
viminfo			viminfoをサポート
vimscript-1		Vim scriptバージョン1 サポート
vimscript-2		Vim scriptバージョン2 サポート
vimscript-3		Vim scriptバージョン3 サポート
vimscript-4		Vim scriptバージョン4 サポート
virtualedit		オプション 'virtualedit' をサポート (常に true)
visual			ビジュアルモードをサポート (常に true)
visualextra		拡張ビジュアルモードをサポート (常に true)
			|blockwise-operators|
vms			VMSバージョン
vreplace		コマンド|gR|と|gr|をサポート (常に true)
vtp			vcon をサポート |+vtp| (現在のコンソール内で機能するか
			どうかを調べるには vcon を確認する)
wildignore		オプション 'wildignore' をサポート
wildmenu		オプション 'wildmenu' を指定してコンパイル
win16			MS-Windows 3.1 用の古いバージョン (常に false)
win32			Win32バージョン(MS-Windows 95 以上の 32 or 64 ビット)
win32unix		Win32バージョン。Unixファイルを使用 (Cygwin)
win64			Win64バージョン(MS-Windows 64 bit)
win95			Win32バージョン。MS-Windows 95/98/ME用 (常に false)
winaltkeys		オプション 'winaltkeys' を指定してコンパイル
windows			複数ウィンドウをサポート (常に true)
writebackup		オプション 'writebackup' が起動時にonになる
xattr			拡張属性をサポート |xattr|
			(現在は Linux でのみサポート)。
xfontset		X fontsetをサポート |xfontset|
xim			XIMをサポート |xim|
xpm			pixmap をサポート
xpm_w32			Win32 で pixmap をサポート(後方互換性のためのみ。
			代わりに "xpm" を使用せよ。)
xsmp			Xセッションマネージメントをサポート
xsmp_interact		対話的Xセッションマネージメントをサポート
xterm_clipboard		xtermのクリップボードサポート
xterm_save		xtermのスクリーンの保存復帰をサポート
x11			X11をサポート


==============================================================================
4. 文字列内でのパターンマッチング			*string-match*

これはいくつかの関数に共通する。|pattern|で説明されている正規表現パターンは通
常、バッファ内の行に対してマッチを検索するために使われる。文字列内でマッチを見
つけるために使うときも、ほとんどは同じように動作する。違いは、文字列が1つの行
であるかのように扱われる事である。文字列が文字 "\n" だけを含むとき、これは改行
とはみなされない。この "\n" はパターン内の "\n" や "." にマッチする。例: >
	:let a = "aaaa\nxxxx"
	:echo matchstr(a, "..\n..")
	aa
	xx
	:echo matchstr(a, "a.x")
	a
	x

"^" は文字列の最初の文字でだけマッチし、"$" は最後の文字でだけマッチすることに
注意。"\n" の前後にはマッチしない。

 vim:tw=78:ts=8:noet:ft=help:norl:
