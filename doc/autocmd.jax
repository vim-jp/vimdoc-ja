*autocmd.txt*   For Vim バージョン 9.1.  Last change: 2025 Mar 12


		  VIMリファレンスマニュアル    by Bram Moolenaar


自動コマンド					*autocommand* *autocommands*

基本的な説明については、ユーザーマニュアルの |40.3| 章を参照。

1. はじめに				|autocmd-intro|
2. 自動コマンドの定義			|autocmd-define|
3. 自動コマンドの削除			|autocmd-remove|
4. 自動コマンドの列挙			|autocmd-list|
5. イベント				|autocmd-events|
6. パターン				|autocmd-patterns|
7. バッファローカルな自動コマンド	|autocmd-buflocal|
8. グループ				|autocmd-groups|
9. 自動コマンドの実行			|autocmd-execute|
10.自動コマンドの使用			|autocmd-use|
11.自動コマンドを無効にする		|autocmd-disable|


==============================================================================
1. はじめに						*autocmd-intro*

ファイルを読み込んだり書き込むときや、バッファやウィンドウに入ったり出たりし
たとき、あるいはVimを終了させるときに、コマンドを自動的に実行するように指定で
きる。例えば "*.c" にマッチするファイルに対して、オプション 'cindent' をオンに
する自動コマンドを作ることができる。また自動コマンドでさらに高度な機能を実装す
ることができる。圧縮ファイルを編集するといったような機能だ (|gzip-example| を
参照)。こういった自動コマンドはファイル .vimrc かファイル .exrc に書き込む。

				*E203* *E204* *E143* *E855* *E937* *E952*
警告: 自動コマンドは大変強力であるので、思いも寄らない副作用をもたらすことがあ
る。テキストを壊さないように注意しなければならない。
- 捨ててもよいようなファイルのコピーに対して、最初にテストしておくのがよい。例
  えば、ファイルの編集開始時にファイルを解凍する自動コマンドを使うときには、
  書き込みするときに圧縮を行う自動コマンドが正しく働くか確かめること。
- 実行中のエラー (例えばディスクが満杯になる) に対して、対処の準備をしておかな
  ければならない。バッファへの変更に対しては大抵アンドゥができるが、他のファイ
  ルへの変更は、自分で処理しなければならないかもしれない (例えば、解凍された
  ファイルを圧縮する、等)。
- もしイベント BufRead* の自動コマンドによって圧縮ファイルを編集できるなら、
  FileRead* でも同じ事ができるようにするべきである (こうすることで復旧可能にな
  る場合がたまにある)。可能であれば、イベント File* や Buf* には同じ自動コマン
  ドを使うのはよい考えだ。

推奨される使用法:
- 常にグループを使用することで、自動コマンドの削除が容易になる。
- コマンド自体を短く維持し、より多くの仕事をする関数を呼ぶようにする。
- 定義されているスクリプトを、自動コマンドを繰り返さずに数回ソースできるように
  する。

Vim9 script での例: >
   autocmd_add([{replace: true,
		group:   'DemoGroup',
		event:   'BufEnter',
		pattern: '*.txt',
		cmd:     'call DemoBufEnter()'
		}])

旧来のスクリプトの例: >
   call autocmd_add([#{replace: v:true,
		    \ group: 'DemoGroup',
		    \ event: 'BufEnter',
		    \ pattern: '*.txt',
		    \ cmd: 'call DemoBufEnter()'
		    \ }])

==============================================================================
2. 自動コマンドの定義					*autocmd-define*

							*:au* *:autocmd*
:au[tocmd] [group] {event} {aupat} [++once] [++nested] {cmd}
			{aupat} |autocmd-patterns| に一致するファイルで、
			{event} のときに自動的に実行するコマンドのリストに、
			{cmd} を加える。
			{event} には "*" は使えない。 *E1155*
			Note: クォートは :autocmd への引数と見なされ、コメント
			を開始しない。
			{cmd} は常に既存の自動コマンドの後に追加されるので、
			自動コマンドは指定された順に実行される。
			[nested] については |autocmd-nested| を参照。後方互換
			性のために、"nested" (++ なし)も使用できるが、|Vim9|
			script では使用できない。 *E1078*
							*autocmd-once*
			[++once] が指定されている場合、コマンドは1回実行される
			と削除される("one shot")。

特殊なパターン<buffer>や<buffer=N>はバッファローカルな自動コマンドを定義する。
|autocmd-buflocal| を参照。

`:autocmd` が Vim9 script (スクリプトが `:vim9script` で始まるのと `:def` 関数
内) にあると {cmd} は Vim9 script として実行される。したがってこの依存は自動コ
マンドが定義された位置に依存し、トリガーされた位置ではない。
							*:autocmd-block*
{cmd} は `:command` のようにブロックにできる。|:command-repl| を参照。例: >
	au BufReadPost *.xml {
		  setlocal matchpairs+=<:>
		  /<start
		}

|autocmd_add()| 関数は、Vim script から自動コマンドやグループのリストを追加す
るために使用できる。`:autocmd` で `:execute` を使用する必要があるような場合は、
この関数を使用することが好ましい。

Note: ":autocmd" コマンドの後には、パターンが期待される位置に '|' が現れる場合
にのみ別のコマンドを続けることができる。これは動作する: >
	:augroup mine | au! BufRead | augroup END
しかし、これは定義されたコマンドの一部として "augroup" を見做す: >
	:augroup mine | au! BufRead * | augroup END
	:augroup mine | au BufRead * set tw=70 | augroup END
代わりにグループ名をコマンドの中に置くことができる: >
	:au! mine BufRead *
	:au mine BufRead * set tw=70
もしくは `:execute` を使用する: >
	:augroup mine | exe "au! BufRead *" | augroup END
	:augroup mine | exe "au BufRead * set tw=70" | augroup END

<							*autocmd-expand*
Note ":autocmd" の引数の中の特別な文字 (例えば "%" や "<cword>" 等) は、自動コ
マンドが定義されたときに展開されるのではなく、イベントの発生が認識され、{cmd}
が実行されるときに展開されることに注意せよ。唯一の例外は、"<sfile>" が自動コマ
ンドが定義されたときに展開されることである。例: >

	:au BufNewFile,BufRead *.html so <sfile>:h/html.vim

ここで <sfile> は、この行を含むファイルの名前に展開される。

`:autocmd` は、すでに存在しているかどうかにかかわらず、自動コマンドのリストに
追加する。.vimrc ファイルが2回読み込まれると、自動コマンドが2回表示される。こ
れを避けるには、グループ内に自動コマンドを定義することで、簡単にクリアできる:
>
	augroup vimrc
	  " 「全ての」vimrcの自動コマンドを削除する
	  autocmd!
	  au BufNewFile,BufRead *.html so <sfile>:h/html.vim
	augroup END

もし全ての自動コマンドを消去したくなかったら、代わりに変数を使って自動コマンド
を読み込むのがただ1度だけにすることができる。 >

	:if !exists("autocommands_loaded")
	:  let autocommands_loaded = 1
	:  au ...
	:endif

引数 [group] が指定されないと、現在のグループが使われる (":augroup" で定義され
たもの)。そうでなければ、Vimは [group] で定義されたグループを使う。
Note [group] はあらかじめ定義されていなければならないことに注意。
":au group ..." で新しいグループを定義することはできない。それには ":augroup"
を使うこと。

自動コマンドをテストするとき、オプション 'verbose' が便利かもしれない。 >
	:set verbose=9
この設定により、Vimは自動コマンドが実行されるとそれらを表示するようになる。

スクリプト内で自動コマンドを定義するときには、スクリプト内でのみ有効なローカル
関数とローカルキーマップを利用できる。イベントが発生してコマンドが実行されると
き、コマンドは自分の定義されたスクリプト内での設定に従って働く。これはコマンド
に |<SID>| が使われているときに問題になる。

コマンドを実行するとき、あるコマンドからのメッセージは前のメッセージを上書きし
てしまう。これはコマンドを手動で実行するときとは違う動作である。大抵、メッセー
ジスクリーンはスクロールしないので、「続けるには」というプロンプトは現れない。
また1個のコマンドが2つのメッセージを出すときには、何にせよメッセージは上書きさ
れてしまう。

==============================================================================
3. 自動コマンドの除去					*autocmd-remove*

以下で説明するコマンドに加えて、|autocmd_delete()| 関数を使用し Vim script か
ら自動コマンドおよびグループのリストを削除できる。

:au[tocmd]! [group] {event} {aupat} [++once] [++nested] {cmd}
			{event} と {aupat} に関連づけられた全ての自動コマンド
			を除去し、コマンド {cmd} を加える。
			[++once] については |autocmd-once| を参照。
			[++nested] については |autocmd-nested| を参照。

:au[tocmd]! [group] {event} {aupat}
			{event} と {aupat} に関連づけられた全ての自動コマンド
			を除去する。

:au[tocmd]! [group] * {aupat}
			{aupat} に関連づけられた、全てのイベントに関する自動コ
			マンドを全て除去する。

:au[tocmd]! [group] {event}
			{event} に関連づけられた「全ての」自動コマンドを除去す
			る。
			警告: |BufRead| や他の一般的なイベントのためのグループ
			なしでこれを行うべきではない。プラグインや構文のハイラ
			イトなどを壊すことがある。

:au[tocmd]! [group]	「全ての」自動コマンドを除去する。
			Note: クォートは :autocmd への引数と見なされ、コメント
			を開始しない。
			警告: 通常はグループなしでこれを行うべきではない。プラ
			グインや構文の強調表示などが壊れる。

引数 [group] が指定されないと、現在のグループが使われる (":augroup" で定義され
たもの)。そうでなければ、[group] で定義されたグループが使われる。

==============================================================================
4. 自動コマンドの列挙					*autocmd-list*

:au[tocmd] [group] {event} {aupat}
			{event} と {aupat} に関連づけられた全ての自動コマンド
			を表示する。

:au[tocmd] [group] * {aupat}
			{aupat} に関連づけられた、全てのイベントに関する自動コ
			マンドを表示する。

:au[tocmd] [group] {event}
			{event} に関連づけられた全ての自動コマンドを表示する。

:au[tocmd] [group]	全ての自動コマンドを表示する。

引数 [group] を指定すると、[group] に関する自動コマンドのみが列挙される。そう
でなければ、「全ての」グループに関する自動コマンドが表示される。Note ここでの
引数による動作の違いは、自動コマンドを定義したり除去するときとは違うことに注
意。

バッファローカルな自動コマンドを列挙するには、<buffer>または<buffer=N>という形
のパターンを使う。|autocmd-buflocal|を参照。

|autocmd_get()| 関数で自動コマンドのリストを Vim script から取得できる。

							*:autocmd-verbose*
'verbose' がゼロでないならば、自動コマンドを列挙するときに、それが最後にどこで
定義されたかも表示する。例: >

    :verbose autocmd BufEnter
    FileExplorer  BufEnter
	*	  call s:LocalBrowse(expand("<amatch>"))
	    Last set from /usr/share/vim/vim-7.0/plugin/NetrwPlugin.vim
<
より詳しい情報は|:verbose-cmd|を参照。

==============================================================================
5. イベント					*autocmd-events* *E215* *E216*

複数のイベントをコンマ (,) で区切ったリストにして指定することもできる。そのリ
ストにはスペースを含めてはいけない。そのコマンドは指定したリストにある全てのイ
ベントに適用される。

「ファイル読み込み」には次の4種類のイベントが発生しうる。
	BufNewFile			存在しないファイルの編集を開始する。
	BufReadPre	BufReadPost	既存のファイルの編集を開始する。
	FilterReadPre	FilterReadPost	フィルタの出力による一時ファイルを読み
					込む。
	FileReadPre	FileReadPost	その他のファイルを読み込む。
Vimはファイルを読み込むときにこの4種類のうちどれか1つを利用する。"Pre"と"Post"
のイベントは、ファイル読み込みの前後で両方とも起動される。

Note イベント *ReadPre や、全てのイベント Filter に関する自動コマンドは、カレ
ントバッファを変更してはならないことに注意 (これが起きると、エラーメッセージが
表示される)。これは、間違ったバッファにファイルを読み込むのを防ぐためである。

Note オプション 'modified' は、BufReadPost と BufNewFile の自動コマンドを実行
した「後に」オフに設定されることに注意。しかし 'modified' が自動コマンドから
オンに設定されたときはそうならない。

'eventignore' は、いくつかあるいは全てのイベントを無視するために使える。


					*autocommand-events* *{event}*
Vimは以下のイベントを認識する。イベント名が大文字か小文字かは無視される (例え
ば "BufRead" の代わりに "BUFread" や "bufread" が使える)。

まず機能ごとに短い説明とともに概要を解説する。それから完全な説明とともにアル
ファベット順のリストを載せる |autocmd-events-abc|。

名前			発生するとき ~

	読み込み
|BufNewFile|		存在しないファイルの編集を始めたとき
|BufReadPre|		新しいバッファの編集を始めたとき。ファイルを読み込む前
|BufRead|		新しいバッファの編集を始めたとき。
			ファイルを読み込んだ後
|BufReadPost|		新しいバッファの編集を始めたとき。
			ファイルを読み込んだ後
|BufReadCmd|		新しいバッファの編集を始める前 |Cmd-event|

|FileReadPre|		":read"でファイルを読み込む前
|FileReadPost|		":read"でファイルを読み込んだ後
|FileReadCmd|		":read"でファイルを読み込む前 |Cmd-event|

|FilterReadPre|		フィルタコマンドでファイルを読み込む前
|FilterReadPost|	フィルタコマンドでファイルを読み込んだ後

|StdinReadPre|		標準入力からバッファに読み込む前
|StdinReadPost|		標準入力からバッファに読み込んだ後

	書き込み
|BufWrite|		バッファ全体をファイルに書き込むとき
|BufWritePre|		バッファ全体をファイルに書き込むとき
|BufWritePost|		バッファ全体をファイルに書き込んだ後
|BufWriteCmd|		バッファ全体をファイルに書き込む前 |Cmd-event|

|FileWritePre|		バッファの一部をファイルに書き込むとき
|FileWritePost|		バッファの一部をファイルに書き込んだ後
|FileWriteCmd|		バッファの一部をファイルに書き込む前 |Cmd-event|

|FileAppendPre|		ファイルに追加するとき
|FileAppendPost|	ファイルに追加した後
|FileAppendCmd|		ファイルに追加する前 |Cmd-event|

|FilterWritePre|	フィルタコマンドやdiff用にファイルを書き込むとき
|FilterWritePost|	フィルタコマンドやdiff用にファイルを書き込んだ後

	バッファ
|BufAdd|		バッファリストにバッファを追加した直後
|BufCreate|		バッファリストにバッファを追加した直後
|BufDelete|		バッファリストからバッファを削除する前
|BufWipeout|		完全にバッファを削除する前

|BufFilePre|		カレントバッファの名前を変える前
|BufFilePost|		カレントバッファの名前を変えた後

|BufEnter|		バッファに入った後
|BufLeave|		別のバッファへ移る前
|BufWinEnter|		バッファがウィンドウに表示された後
|BufWinLeave|		バッファがウィンドウから削除される前

|BufUnload|		バッファをアンロードする前
|BufHidden|		バッファが隠れバッファになる直前
|BufNew|		新規バッファを作成した直後

|SwapExists|		既存のスワップファイルを検出したとき

	オプション
|FileType|		オプション 'filetype' がセットされたとき
|Syntax|		オプション 'syntax' がセットされたとき
|EncodingChanged|	オプション 'encoding' が変更された後
|TermChanged|		オプション 'term' が変更された後
|OptionSet|		オプションが設定された後

	起動と終了
|VimEnter|		全ての起動処理が終わった後
|GUIEnter|		GUIの起動が成功した後
|GUIFailed|		GUIの起動が失敗した後
|TermResponse|		|t_RV| に対する端末の反応を受け取った後
|TermResponseAll|	|t_RV| および他の端末応答を受信した後

|QuitPre|		`:quit` を使ったとき、本当に終了するか決定する前
|ExitPre|		Vimを終了するコマンドを使ったとき
|VimLeavePre|		Vimを終了する前、viminfoファイルを書き出す前
|VimLeave|		Vimを終了する前、viminfoファイルを書き出した後

|VimSuspend|		Vimがサスペンドした時
|VimResume|		Vimがサスペンド後復帰した時

	端末
|TerminalOpen|		端末バッファが生成された後
|TerminalWinOpen|	新しいウィンドウで端末バッファが生成された後

	その他
|FileChangedShell|	編集を始めた後にファイルが変更されたことを検出したとき
|FileChangedShellPost|	編集を始めた後にファイルが変更されたことに対処した後
|FileChangedRO|		読み込み専用ファイルに対して最初に変更を加える前

|DiffUpdated|		差分が更新された後
|DirChangedPre|		作業ディレクトリが変更される前
|DirChanged|		作業ディレクトリが変更された後

|ShellCmdPost|		シェルコマンドを実行した後
|ShellFilterPost|	シェルコマンドでフィルタをかけた後

|CmdUndefined|		呼び出そうとしたユーザー定義コマンドが定義されていな
			かったとき
|FuncUndefined|		呼び出そうとしたユーザー定義関数が定義されていなかった
			とき
|SpellFileMissing|	スペリングファイルを使おうとしたが見つからなかったとき
|SourcePre|		Vim script を読み込む前
|SourcePost|		Vim script を読み込んだ後
|SourceCmd|		Vim script を読み込む前 |Cmd-event|

|VimResized|		Vimのウィンドウサイズが変わったとき
|FocusGained|		Vimが入力フォーカスを得たとき
|FocusLost|		Vimが入力フォーカスを失ったとき
|CursorHold|		ユーザーが一定時間キーを押さなかったとき
|CursorHoldI|		挿入モードでユーザーが一定時間キーを押さなかったとき
|CursorMoved|		ノーマルモードでカーソルが移動したとき
|CursorMovedC|		|Command-line| でカーソルが移動したとき
|CursorMovedI|		挿入モードでカーソルが移動したとき

|WinNewPre|		新しいウィンドウを作成する前
|WinNew|		新しいウィンドウを作成した後
|TabNew|		新しいタブページを作成した後
|WinClosed|		ウィンドウを閉じた後
|TabClosed|		タブページを閉じた後
|TabClosedPre|		タブページを閉じる前
|WinEnter|		別のウィンドウに入った後
|WinLeave|		ウィンドウから離れる前
|TabEnter|		別のタブページに入った後
|TabLeave|		タブページから離れる前
|CmdwinEnter|		コマンドラインウィンドウに入った後
|CmdwinLeave|		コマンドラインウィンドウから離れる前

|CmdlineChanged|	コマンドラインのテキストに変更が加えられた後
|CmdlineEnter|		カーソルがコマンドラインに移動した後
|CmdlineLeave|		カーソルがコマンドラインを離れる前

|InsertEnter|		挿入モードを開始したとき
|InsertChange|		挿入や置換モードで<Insert>をタイプしたとき
|InsertLeave|		挿入モードを抜けるとき
|InsertLeavePre|	挿入モードを抜ける直前
|InsertCharPre|		挿入モードで文字が入力されたとき、その文字が挿入される
			前

|ModeChanged|		モード変更後

|TextChanged|		ノーマルモードでテキストが変更された後
|TextChangedI|		ポップアップメニューが表示されていないときに、挿入モー
			ドでテキストが変更された後
|TextChangedP|		ポップアップメニューが表示されているときに、挿入モード
			でテキストが変更された後
|TextChangedT|		端末モードでテキストが変更された後
|TextYankPost|		テキストがヤンクもしくは削除された後

|SafeState|		保留中のものはなく、ユーザーの文字入力を待つとき
|SafeStateAgain|	繰り返された SafeState

|ColorSchemePre|	カラースキームを読み込む前
|ColorScheme|		カラースキームを読み込んだ後

|RemoteReply|		Vimサーバーからの返答を受け取ったとき

|QuickFixCmdPre|	QuickFixコマンドを実行する前
|QuickFixCmdPost|	QuickFixコマンドを実行した後

|SessionLoadPost|	セッションファイルを読み込んだ後

|SessionWritePost|	|:mksession| コマンドを使用してセッションファイルを書
			き込んだ後

|MenuPopup|		ポップアップメニューを表示する直前
|CompleteChanged|	挿入モード補完メニューが変更されたとき
|CompleteDonePre|	挿入モード補完が完了したとき、情報がクリアされる前
|CompleteDone|		挿入モード補完が完了したとき、情報がクリアされた後

|KeyInputPre|		キーが処理される前

|User|			":doautocmd" との組合せで使われる
|SigUSR1|		SIGUSER1シグナルを受けとった後

|WinScrolled|		ウィンドウがスクロールもしくはサイズ変更した後

自動コマンドイベントのアルファベット順リスト:		*autocmd-events-abc*

							*BufCreate* *BufAdd*
BufAdd or BufCreate		バッファリストに追加されるバッファを作った直後
				か、バッファをバッファリストに追加した直後。
				バッファリスト内のバッファがリネームされた直後
				にも発生する。
				起動中に作成された初期バッファでは発生しない。
				イベント BufCreate は歴史上の理由で存在してい
				る。
				NOTE: このイベントで自動コマンドが実行された
				ときは、"%" で表されるカレントバッファと
				"<afile>" で表される作成されたバッファは異なる
				かもしれないことに注意。
							*BufDelete*
BufDelete			バッファリストからバッファを削除する前。(バッ
				ファが読み込まれているなら) BufUnload が最初に
				呼び出されるだろう。
				また、バッファリスト内のバッファがリネームされ
				た直前にも使われる。
				NOTE: このイベントで自動コマンドが実行された
				ときは、"%" で表されるカレントバッファと
				"<afile>" と "<abuf>" で表される削除されるバッ
				ファとは異なるかもしれないことに注意。
				他のバッファに切り替えないこと。もしすると問題
				が発生するだろう。
							*BufEnter*
BufEnter			バッファに入った後。ファイルタイプに関するオプ
				ションの設定に便利である。バッファの編集を始め
				るときにも、BufReadPost の自動コマンドの後に実
				行される。
							*BufFilePost*
BufFilePost			現在のバッファの名前をコマンド ":file" または
				":saveas" で変更した後。
							*BufFilePre*
BufFilePre			現在のバッファの名前をコマンド ":file" または
				":saveas" で変更する前。
							*BufHidden*
BufHidden			バッファが隠れ状態 (hidden) になる直前。つまり
				そのバッファを表示するウィンドウがもう存在しな
				いのに、バッファが解放されなかったり、削除され
				ないとき。":qa" や "q" でVimを終了するときに
				は使われない。
				NOTE: このイベントで自動コマンドが実行された
				ときは、"%" で表されるカレントバッファと
				"<afile>" で表される解放されるバッファとは異な
				るかもしれないことに注意。
							*BufLeave*
BufLeave			他のバッファに移る前。カレントウィンドウを離れ
				たり、閉じたりするときで、新しいカレントウィン
				ドウが同じバッファを開いていないとき。":qa" や
				"q" でVimを閉じるときには使われない。
							*BufNew*
BufNew				新しいバッファを作った直後。バッファがリネーム
				された直後にも発生する。バッファがバッファリス
				トに追加されると、イベント BufAdd も発生する。
				NOTE: このイベントで自動コマンドが実行された
				ときは、"%" で表されるカレントバッファと
				"<afile>" で表される作成されるバッファとは異な
				るかもしれないことに注意。
							*BufNewFile*
BufNewFile			存在しないファイルの編集を始めたとき。スケルト
				ンファイル {訳注: テンプレートファイルともいう}
				に読み込むときに使える。
						*BufRead* *BufReadPost*
BufRead or BufReadPost		新しいバッファの編集を始めたときの、ファイルを
				バッファに読み込んだ後で、モードラインを実行す
				る前。モードラインを実行した後に何かするには
				|BufWinEnter|を参照すること。
				発行される場合:
				- 無名バッファを保存してバッファに名前がついた
				  とき
				- ファイルのリカバリーが成功した後
				- filetypedetect グループを対象として
				  ":filetype detect" を実行したとき
				発行されない場合:
				- `:read file` コマンド
				- ファイルが存在しないとき
							*BufReadCmd*
BufReadCmd			新しいバッファの編集を始める前。ファイルをバッ
				ファ内に読み込む役目を負う。 |Cmd-event|
						*BufReadPre* *E200* *E201*
BufReadPre			新しいバッファの編集を始めたときの、ファイルを
				バッファに読み込む前。読み込むファイルが存在し
				ないときは使えない。
							*BufUnload*
BufUnload			バッファを解放する前。これは、バッファ内のテキ
				ストが解放されるときである。BufWritePost の後
				で、BufDelete の前かもしれない。Vimが終了しよ
				うとしているとき、読み込まれた全てのバッファに
				ついて発生する。
				NOTE: このイベントで自動コマンドが実行された
				ときは、"%" で表されるカレントバッファと
				"<afile>" で表される解放されるバッファとは異な
				るかもしれないことに注意。
				他のバッファやウィンドウに切り替えないこと。問
				題が発生するだろう。
				終了時に v:dying が 2 以上のときはこのイベント
				は発生しません。
							*BufWinEnter*
BufWinEnter			バッファがウィンドウ内に表示された後。これはバッ
				ファが読み込まれたとき (モードラインの処理後)
				か、隠れ (hidden) バッファがウィンドウ内に表示
				されたとき (もう隠れバッファでなくなったとき)。
				引数なしで |:split| をしたときや、既にウィンド
				ウに表示されているバッファを指定して ":split"
				をしたときは、同じバッファを開いたままなので、
				このイベントは発生しない。既存のバッファがその
				まま使われるためである。しかし、カレントバッファ
				の名前を指定して ":split" をすると、そのバッファ
				を再読み込みすることになるので、発生する。
				端末ウィンドウでは発生しない。何故なら端末ジョ
				ブモードで開始され、ノーマルモードコマンドは機
				能しないからである。代わりに |TerminalOpen| を
				使用すること。
							*BufWinLeave*
BufWinLeave			バッファがウィンドウから取り除かれる前。そのバッ
				ファが別のウィンドウ内で表示中ならば発生しない。
				Vimの終了時にも発生する。イベント BufUnload や
				BufHidden よりも前に発生する。
				NOTE: このイベントで自動コマンドが実行された
				ときは、"%" で表されるカレントバッファと
				"<afile>" で表される解放されるバッファとは異な
				るかもしれないことに注意。
				他のバッファに切り替えないこと。もしすると問題
				が発生するだろう。
				終了時に v:dying が 2 以上のときはこのイベント
				は発生しません。
							*BufWipeout*
BufWipeout			バッファを完全に削除する前。イベント BufUnload
				と BufDelete が先に発生するかもしれない (バッ
				ファが読み込まれていて、バッファリスト内に存在
				するなら)。バッファがリネームされる直前にも発
				生する (そのバッファがバッファリスト内になくと
				も)。
				NOTE: このイベントで自動コマンドが実行された
				ときは、"%" で表されるカレントバッファと
				"<afile>" で表される削除されるバッファとは異な
				るかもしれないことに注意。
						*BufWrite* *BufWritePre*
BufWrite or BufWritePre		バッファ全体をファイルに書き込む前。
							*BufWriteCmd*
BufWriteCmd			バッファ全体をファイルに書き込む前。ファイルへ
				の書き込みの役目を負い、成功したときはオプショ
				ン 'modified' をオフにする。バッファの内容を変
				更すべきではない。
				'modified' をオフにすると、以前の undo 状態が
				'modified' (変更あり) になるように undo 情報が
				調整される (|:write| と同様)。
				|Cmd-event|
							*BufWritePost*
BufWritePost			バッファ全体をファイルに書き込んだ後 (イベント
				BufWritePre によるコマンドをアンドゥする役目を
				果たす)。
							*CmdUndefined*
CmdUndefined			ユーザー定義コマンドが使われたが、定義されてい
				なかったとき。必要なときのみコマンドを定義する
				のに便利である。パターンはコマンド名に対して照
				合される。<amatch> と <afile> の両方ともコマン
				ド名に設定される。
				これは、|autocmd-nested| なしで定義された自動
				コマンドの内部でもトリガーされる。
				NOTE: 未定義のコマンドに対して自動補完は機能し
				ない。このイベントを使う代わりにユーザー定義コ
				マンドを常に定義するようにしてそのコマンドから
				autoload 関数を呼び出すようにするという方法も
				ある。|autoload| 参照。
							*CmdlineChanged*
CmdlineChanged			コマンドラインのテキストに変更が加えられた後。
				Vim が固まってしまう可能性があるので、コマンド
				ラインで間違いを起こさないよう注意すること。
				<afile> はコマンドラインの種類を示す 1 文字に
				設定される。
				|cmdwin-char|
							*CmdlineEnter*
CmdlineEnter			ユーザーがコマンドを入力もしくは文字列を検索で
				きるコマンドラインにカーソルが移動した後、非イ
				ンタラクティブなマッピング内での ":" 利用を含
				むが、|<Cmd>| の利用は含まない。
				パターンは、コマンドラインの種類を表す文字と照
				合される。|cmdwin-char|
				<afile> はコマンドラインの種類を示す 1 文字に
				設定される。
							*CmdlineLeave*
CmdlineLeave			カーソルがコマンドラインを離れる前、非インタラ
				クティブなマッピング内での ":" 利用を含むが、
				|<Cmd>| の利用は含まない。CTRL-C もしくは
				<Esc> の入力によってコマンドラインを放棄する場
				合も同様。
				コマンドの結果がエラーとなる場合は、コマンドラ
				インは引き続き実行中となる。
				<afile> はコマンドラインの種類を示す 1 文字に
				設定される。
				|cmdwin-char|
							*CmdwinEnter*
CmdwinEnter			Command-lineウィンドウに入った後。この特殊な
				ウィンドウに対してのみオプションを設定するのに
				便利である。
				<afile> は、command-lineの種類を示す1文字に設
				定される。 |cmdwin-char|
							*CmdwinLeave*
CmdwinLeave			Command-lineウィンドウから出る前。イベント
				CmdwinEnter で行ったグローバル設定を消去するの
				に便利である。
				<afile> は、command-lineの種類を示す1文字に設
				定される。 |cmdwin-char|
							*ColorScheme*
ColorScheme			カラースキームを読み込んだ後。 |:colorscheme|
				カラースキームが見つからない場合は、トリガーさ
				れない。
				パターンはカラースキーム名にマッチする。
				<afile> はこのオプションを設定したファイルの名
				前になる。<amatch> はカラースキーム名になる。

							*ColorSchemePre*
ColorSchemePre			カラースキームを読み込む前。|:colorscheme|
				あるカラースキームが読み込まれる前に、それ以前
				に別のカラースキームによって追加されたものを取
				り除くのに便利。
CompleteChanged						*CompleteChanged*
				挿入モード補完メニューが変更される度。ポップ
				アップメニューが非表示時には発生しない。そのた
				めには |CompleteDonePre| または |CompleteDone|
				を使用すること。再帰的に発生することはない。

				これらの |v:event| キーを設定する:
				    completed_item	|complete-items| 参照
				    height		表示項目数
				    width		画面セル数
				    row			画面上端の行
				    col			画面最左の桁
				    size		全項目数
				    scrollbar		表示時 TRUE

				テキストの |textlock| を変更することはできない。

				ポップアップのサイズと位置は、|pum_getpos()|
				を呼び出すことでも得られる。

							*CompleteDonePre*
CompleteDonePre			挿入モード補完が完了したとき。補完が実行されて
				も中止されても発行される。 |ins-completion|
				|complete_info()| を使うことができる。情報は
				CompleteDonePre が発行された後にクリアされる。
				変数 |v:completed_item| には補完された候補につい
				ての情報が含まれている。

							*CompleteDone*
CompleteDone			挿入モード補完が完了したとき。補完が実行されて
				も中止されても発行される。 |ins-completion|
				|complete_info()| を使うことができる。情報は
				CompleteDone が発行される前にクリアされる。必
				要ならば CompleteDonePre を使うこと。
				変数 |v:completed_item| には補完された候補につい
				ての情報が含まれている。

				以下の |v:event| キーを設定する:
				    complete_word	選択された単語。補完が
							放棄された場合は空白に
							なる。
				    complete_type	|complete_info_mode|

							*CursorHold*
CursorHold			'updatetime' の時間の間、ユーザーがキーを押さ
				なかったとき。ユーザーが何かキーを押すまで、発
				生することはない (例えば、もしあなたがコーヒー
				を入れるためにVimの前を離れても、その間の
				'updatetime' ミリ秒ごと発生することはない :-)。
				タグをプレビューするためには、
				|CursorHold-example| を参照。
				このイベントはノーマルモードのときのみ呼ばれる。
				コマンドの引数の入力待ち状態、またはオペレータ
				の後の移動コマンド入力待ち状態のときは発生しな
				い。
				レコーディングの最中にはCursorHoldイベントは発
				生しない。|q|
							*<CursorHold>*
				この自動コマンドは内部的に <CursorHold> キーが
				引き金になっている。式による指定のマッピング内
				では |getchar()| によってこの文字が取得されるこ
				とがある。

				Note: このイベントには対話的なコマンドは使えな
				いことに注意。「続けるには」プロンプトは現れず、
				スクリーンは必要に応じて直接更新される。
				Note: 近いうちに、発生するまでの時間を設定する
				別のオプションができるだろう。
				ヒント: ステータスラインの更新を強制的に行うに
				は、これを使うこと: >
					:let &ro = &ro
<				{VimのAmiga版、Unix版、Win32版および全てのGUI
				版でのみ有効}
							*CursorHoldI*
CursorHoldI			CursorHoldと同様だが、挿入モードのとき発生す
				る。例えば別のキーを待っているとき、例えば
				CTRL-V の後で、CTRL-X モード |insert_expand|
				ではないときにはトリガーされない。
							*CursorMoved*
CursorMoved			ノーマルモードかビジュアルモードでカーソルが移
				動した後。カーソル行のテキストが変更されたとき
				にも発生する(例: "x", "rx", "p"などで)。
				先行入力があるとき、スクリプトファイルのコマン
				ドの実行中、オペレータが待機しているとき、また
				は同じカーソル位置のまま別のウィンドウへ移動し
				たときには常に発生しない。
				|match-parens|の例を参照。
				Note: この自動イベントは `:noautocmd` を付けて
				もスキップできない。
				注意: このイベントは頻繁に発生するので、ユーザー
				が予期しないことや時間のかかる処理は行わないこ
				と。
							*CursorMovedC*
CursorMovedC			コマンドラインでカーソルを移動した後。コマンド
				ラインをぐちゃぐちゃにすると Vim がロック状態
				になる可能性があるので注意。
				<afile> には、コマンドラインの種類を示す単一の
				文字が設定される。|cmdwin-char|
							*CursorMovedI*
CursorMovedI			挿入モードでカーソルが移動した後。ポップアップ
				メニューが表示されているときは発行されない。
				それ以外はCursorMovedと同じ。
                                                       *DiffUpdated*
DiffUpdated			差分が更新された後。使用されているdiffコマンド
				の種類(内部または外部)に応じて、変更毎か
				|:diffupdate| 実行時に発生する。
							*DirChangedPre*
DirChangedPre			|DirChanged| と同じように、作業ディレクトリが
				変更されようとしているとき。パターンは
				|DirChanged| と同様。新しいディレクトリ名は
				v:event.directory にある。
							*DirChanged*
DirChanged			|:cd|, |:tcd| もしくは |:lcd| コマンドによって、
				もしくは 'autochdir' オプションの結果として作業
				ディレクトリが変更された後。
				パターンは以下のようになる:
					"window"  `:lcd` により発生する
					"tabpage" `:tcd` により発生する
					"global"  `:cd` により発生する
					"auto"    'autochdir' により発生する
					"drop"    ファイルの編集により発生する
				<afile> は新ディレクトリ名に設定される。
							*EncodingChanged*
EncodingChanged			オプション 'encoding' が変更されたとき。例えば、
				フォント等の設定に便利である。
							*ExitPre*
ExitPre				Vim を終了させる `:quit`, `:wq` もしくは
				`:qall` を使用したときで、|QuitPre| の直後。不
				必要なウィンドウを閉じるのに使うことができる。
				自動的に保存されない変更済みのバッファがある場
				合には、終了はまだキャンセルされる可能性があ
				る。本当に終了するときのためには |VimLeavePre|
				を使用すること。
							*FileAppendCmd*
FileAppendCmd			ファイルに追加する前。ファイルへの追加の役目を
				負う。|Cmd-event|
							*FileAppendPost*
FileAppendPost			ファイルに追加した後。
							*FileAppendPre*
FileAppendPre			ファイルに追加する前。
							*FileChangedRO*
FileChangedRO			読み込み専用ファイルに最初の変更を加える前。
				ソース管理システム {訳注: CVSやRCS} からファイ
				ルをチェックアウトするのに使われる。変更が自動
				コマンドによるときには発生しない。
				このイベントが発生するのは、バッファに最初の変
				更を行うときや、'readonly'がセットされた後に最
				初の変更を行うときの、変更が適用される直前であ
				る。
				警告: 自動コマンドでカーソルが動かされるときの
				動作は、定義されていない。
							*E788*
				ここで他のバッファに変更をしてはならない。バッ
				ファを再読み込みするのはよいが、他のバッファを
				編集してはならない。
							*E881*
				行数が変化した場合 undo のための保存は失敗し、
				その変更は中止されるだろう。
							*FileChangedShell*
FileChangedShell		ファイルのタイムスタンプが、ファイルの編集が始
				まってから変更されたことを発見したとき。
				ファイルの属性やファイルサイズが変更されたとき
				にも使われる。|timestamp|
				大抵はシェルコマンドの実行後に発生する。またコ
				マンド |:checktime| の実行後や、gvimが入力
				フォーカスを一度失い、再び得たときにも発生す
				る。
				このイベントは変更されたファイルそれぞれに対し
				て発生する。オプション 'autoread' がオンであり、
				かつバッファが変更されていないときには使われな
				い。もし FileChangedShell の自動コマンドが存
				在しても、警告メッセージやプロンプトは現れない。
				変数|v:fcs_reason|に何が起こったのかが設定さ
				れ、|v:fcs_choice|によってVimに次に何をすべき
				かを指示できる。
				NOTE: このイベントで自動コマンドが実行された
				ときは、"%" で表されるカレントバッファと
				"<afile>" で表される変更されたバッファとは異な
				るかもしれないことに注意。
				NOTE: この自動コマンドはカレントバッファを変
				更したり、別のバッファにジャンプしたり、バッ
				ファを消去してはいけない。 *E246* *E811*
				NOTE: このイベントは、無限ループを避けるために
				決してネストしてはいけない (入れ子にならない)。
				つまり、FielChangedShellイベントの処理中は他の
				FileChangedShellイベントは呼ばれない。
							*FileChangedShellPost*
FileChangedShellPost		Vimの外部でファイルが変更されたのを検出・対処
				した後。ステータスラインを更新するのに使える。
							*FileEncoding*
FileEncoding			時代遅れである。まだ有効だがイベント
				|EncodingChanged| と同等である。
							*FileReadCmd*
FileReadCmd			コマンド ":read" でファイルを読み込む前。ファ
				イルを読み込む役目を負う。 |Cmd-event|
							*FileReadPost*
FileReadPost			コマンド ":read" でファイルを読み込んだ後。
				Note 読み込んだテキストの先頭行と末尾行には、
				マーク '[ と '] が設定されることに注意。これは、
				読み込まれた行に対して操作を行うのに使われる。
							*FileReadPre*
FileReadPre			コマンド ":read" でファイルを読み込む前。
							*FileType*
FileType			オプション 'filetype' が設定されたとき。
				パターンはファイルタイプに対して照合される。
				<afile> は 'filetype' が設定されたファイルの名
				前として使える。<amatch> は 'filetype' の新し
				い値として使える。他のウィンドウもしくはバッ
				ファへの移動は許されていない。
				|filetypes| を参照。
							*FileWriteCmd*
FileWriteCmd			バッファ全体を書き込まない場合の、ファイルに書
				き込む前。ファイルへの書き込みの役目を負う。バッ
				ファを変更すべきではない。 |Cmd-event|
							*FileWritePost*
FileWritePost			バッファ全体を書き込まない場合の、ファイルに書
				き込んだ後。
							*FileWritePre*
FileWritePre			バッファ全体を書き込まない場合の、ファイルに書
				き込む前。
							*FilterReadPost*
FilterReadPost			フィルタコマンドからファイルを読み込んだ後。
				Vimは FilterReadPre と同様に、現在のバッファの
				名前に対してパターンを調べる。
							*FilterReadPre* *E135*
FilterReadPre			フィルタコマンドからファイルを読み込む前。Vim
				は、フィルタコマンドの出力である一時ファイルの
				名前ではなく、現在のバッファの名前に対してパター
				ンを調べる。
							*FilterWritePost*
FilterWritePost			フィルタコマンド用のファイルを書き込んだり、外
				部diffで差分表示用のファイルを作った後。(内部
				diffについては |DiffUpdated| を参照)
				Vimは FilterWritePre と同様、現在のバッファの
				名前に対してパターンをチェックする。
				'shelltemp' がオフのときは発生しない。
							*FilterWritePre*
FilterWritePre			フィルタコマンド用のファイルを書き込んだり、外
				部diffで差分表示用のファイルを作る前。
				Vimはフィルタコマンドの出力である一時ファイル
				の名前ではなく、現在のバッファの名前に対してパ
				ターンをチェックする。
				'shelltemp' がオフのときは発生しない。
							*FocusGained*
FocusGained			Vimが入力フォーカスを得たとき。GUI版と、入力
				フォーカスを認識できるいくつかのコンソール版で
				のみ有効。|xterm-focus-event|
							*FocusLost*
FocusLost			Vimが入力フォーカスを失ったとき。GUI版と、入力
				フォーカスを認識できるいくつかのコンソール版で
				のみ有効。|xterm-focus-event|
				ダイアログがポップアップした時にも発生する可能
				性がある。
							*FuncUndefined*
FuncUndefined			ユーザー定義関数が使われたが、定義されていなかっ
				たとき。必要なときのみ関数を定義するのに便利で
				ある。パターンは関数名に対して照合される。
				<amatch> と <afile> の両方とも関数名に設定され
				る。
				これは、|autocmd-nested| なしで定義された自動
				コマンド内でもトリガーされるが、|Vim9| 関数を
				コンパイルするときにはトリガーされない。
				NOTE: Vim script を書くときには autoload 関数
				を使う方がよい。
				|autoload-functions|を参照。
							*GUIEnter*
GUIEnter			GUI の開始に成功し、ウィンドウを開いた後。
				gvim を使ったときは、VimEnter の前に発生する。
				ファイル .gvimrc からウィンドウの配置場所を設
				定するために使うことができる。 >
	:autocmd GUIEnter * winpos 100 50
<							*GUIFailed*
GUIFailed			GUIの開始に失敗した後。可能ならば、Vimはターミ
				ナル内で実行を継続する(Unix系のみ。Xサーバーへ
				接続が失敗したとき)。ここでVimを終了させるには、
				次のようにする: >
	:autocmd GUIFailed * qall
<							*InsertChange*
InsertChange			挿入・置換モードで <Insert> をタイプしたとき。
				変数 |v:insertmode| が新しいモードを示す。
				カーソルを移動したりなどユーザーが予期しないこ
				とは行わないように注意。
							*InsertCharPre*
InsertCharPre			挿入モードで文字が入力されたとき、その文字が挿
				入される前。|v:char| 変数に入力された文字が入っ
				ている。イベント内でそれを変更することで実際に
				挿入される文字を変更できる。|v:char| に 2 つ以
				上の文字を入れた場合はそのテキストはそのまま
				(literally) 挿入される。
				テキストを変更することはできない |textlock|。
				このイベントは 'paste' がオンに設定されている
				ときは発行されない。{+eval 機能が有効な場合の
				み}
							*InsertEnter*
InsertEnter			挿入モード・置換モード・仮想置換モードを開始す
				る直前。変数|v:insertmode|がモードを示す。
				ユーザーが予期しないことは行わないように注意。
				カーソルはコマンド実行後に復元される。復元され
				たくない場合は |v:char| に非空文字を設定する。
							*InsertLeavePre*
InsertLeavePre			挿入モードを抜ける前。CTRL-O |i_CTRL-O| を使っ
				た時も発生する。問題の原因になりうるのでモード
				の変更や `:normal` の使用には注意すること。
							*InsertLeave*
InsertLeave			挿入モードを抜けた直後。CTRL-O |i_CTRL-O| を
				使ったときにも発生する。|i_CTRL-C| のときは発
				生しない。
							*KeyInputPre*
KeyInputPre			マッピングが適用されてキーが処理される前。パ
				ターンは、現在のモードを示す文字列と照合され
				る。これは、`mode(1)` によって返されるものと同
				じである。
				|v:char| 変数は入力されたキーを示し、イベント
				中に変更して別のキーを処理することができ
				る。|v:char| が単一の文字または特殊キーでない
				場合は、最初の文字が使用される。
				|v:event| には以下の値が設定される:
				   typed	キーがタイプされたか否か。
				   typedchar	最後の |KeyInputPre| 呼び出し
						以降に (実際に) タイプされた
						キー。
				Note: 連続する |KeyInputPre| 自動コマンドが処
				理される場合、"typedchar" は空になることがあ
				る。
				テキスト |textlock| または現在のモードを変更す
				ることはできない。
				{+eval 機能が有効な場合のみ}
							*MenuPopup*
MenuPopup			(マウス右ボタンで)ポップアップメニューを表示す
				る直前。カーソル下やマウスポインタの下にあるも
				のによってメニューを調整するのに便利。
				パターンにはモードを表す1文字か2文字を記述する:
					n	ノーマル
					v	ビジュアル
					o	オペレータ実行待ち
					i	挿入
					c	コマンドライン
					tl	端末
							*ModeChanged*
ModeChanged			モード変更後。パターンは `'old_mode:new_mode'`
				に対してマッチングされ、例えば、|CmdlineEnter|
				をシミュレートするには、`*:c*` に対してマッチ
				させる。
				|v:event| には以下の値が設定される:
				   old_mode	変更前のモード。
				   new_mode	非0の引数で呼び出された
						|mode()| によっても返される新
						しいモード。
				ModeChanged が発行された時、old_mode は最後に
				発行された時の new_mode の値を持つ。
				各マイナーモードが変更されるたびに発行される。
				使い方の例としてビジュアルモードに入ったら相対
				行番号を使うもの: >
	:au ModeChanged [vV\x16]*:* let &l:rnu = mode() =~# '^[vV\x16]'
	:au ModeChanged *:[vV\x16]* let &l:rnu = mode() =~# '^[vV\x16]'
	:au WinEnter,WinLeave * let &l:rnu = mode() =~# '^[vV\x16]'
<							*OptionSet*
OptionSet			オプションが設定された後。パターンは長い(短縮
				しない)オプション名に対してマッチする。
				|<amatch>| は対象のオプション名が設定される。

				|v:option_type| はオプションの変更のスコープが
				グローバルかローカルかが格納される。
				|v:option_command| はどのコマンドで値が設定さ
				れたかが格納される。(タグのジャンプ先にある表
				を参照)
				|v:option_new| は新しく設定された値が格納され
				る。
				|v:option_oldlocal| は変更前のローカルの値が格
				納される。
				|v:option_oldglobal| は変更前のグローバルの値
				が格納される。
				|v:option_old| は変更前の値が格納される。

				|v:option_oldlocal| には |:set| か
				|:setlocal|、|modeline| のいずれかが使用された
				場合に値が格納される。同様に
				|v:option_oldglobal| には |:set| か
				|:setglobal| が使用された場合に値が格納される。

				これは |<abuf>| を設定しない。|bufnr()| を使う
				ことができる。

				Note |global-local| なオプションと |:set| を利
				用して文字列をセットした場合、|v:option_old|
				には古いグローバルの値が格納されるが、それ以外
				の場合(例えばローカルな文字列や |global-local|
				な数値、等)は古いローカルの値が格納されるので
				注意。

				OptionSet は起動時と 'key' の変更の際にはあえ
				てイベントが発生しないようにしている。

				使用例: 'backupdir' や 'undodir' で指定された
				ディレクトリが存在しているかチェックし、もしな
				ければディレクトリを作成する。

				Note: この自動コマンド中でオプションの値をリセ
				ットするのは、プラグインの挙動を破壊するため、
				良くない。この自動コマンドの実行は `:noa` を使
				うことで抑制することができる。

				自動コマンド内で |:set| を使用しても、イベント
				は再びトリガーされない。
							*QuickFixCmdPre*
QuickFixCmdPre			QuickFixコマンドが実行される前 (|:make|,
				|:lmake|, |:grep|, |:lgrep|, |:grepadd|,
				|:lgrepadd|, |:vimgrep|, |:lvimgrep|,
				|:vimgrepadd|, |:lvimgrepadd|, |:cscope|,
				|:cfile|, |:cgetfile|, |:caddfile|, |:lfile|,
				|:lgetfile|, |:laddfile|, |:helpgrep|,
				|:lhelpgrep|, |:cexpr|, |:cgetexpr|,
				|:caddexpr|, |:cbuffer|, |:cgetbuffer|,
				|:caddbuffer|)。
				パターンには実行されるコマンドを記述する。
				|:grep| が書かれていると、'grepprg' が
				"internal" にセットされていても実行される。
				このコマンドを使って変数 'makeprg' と
				'grepprg' を設定することはできない。
				このコマンドでエラーになるとQuickFixコマンドは
				実行されない。
							*QuickFixCmdPost*
QuickFixCmdPost			QuickFixCmdPreと同様だが、QuickFixコマンドが実
				行された後、最初の位置にジャンプする前に発生す
				る。|:cfile| コマンドと |:lfile| コマンドの場
				合はイベントはエラーファイルを読み込んだ後、最
				初のエラーに移動する前に実行される。
				|QuickFixCmdPost-example| を参照。
							*QuitPre*
QuitPre				`:quit`、`:wq` または `:qall` を使ったときで、
				カレントウィンドウを閉じるか Vim を終了するか
				を決定する前。`:wq` では QuitPre が発生する前
				にバッファが書き込まれる。カレントウィンドウが
				最後の通常のウィンドウで、余分なウィンドウを閉
				じたいときに使える。
				|ExitPre| も参照。
							*RemoteReply*
RemoteReply			サーバーとして働くVimからの応答を受け取ったとき
				|server2client()|。パターンは{serverid}に対し
				て照合される。
				<amatch> は応答が送られてきたサーバーの
				{serverid} になり、<afile> は応答の実際の内容
				になる。
				Note これに自動コマンドを定義したときも、応答
				を読み込むのには、読み込んだ応答を処理できるよ
				うに関数 |remote_read()| を使うべきであること
				に注意。
							*SafeState*
SafeState			何も保留されておらず、ユーザーの文字入力を待つ
				とき。
				次の場合はトリガーされない:
				- オペレータ待機中
				- レジスタが "r で入力された
				- コマンドの実行途中
				- マップの実行中
				- 先行入力がある
				- 挿入モード補完がアクティブ
				- コマンドライン補完がアクティブ
				`mode()` を使用して、Vimの状態を確認できる。
				それは以下かもしれない:
				- ビジュアルモード
				- ノーマルモード
				- 挿入モード
				- コマンドラインモード
				やりたいことによっては、`state()` でさらに
				チェックすることもできる。例えば、画面がメッ
				セージのためにスクロールされたかどうか。
							*SafeStateAgain*
SafeStateAgain			SafeState に似ているが、メッセージを処理し、
				コールバックを呼び出した後。これは頻繁にトリ
				ガーされる可能性があるので、時間がかかるような
				ことはしないこと。

							*SessionLoadPost*
SessionLoadPost			|:mksession|で作られたセッションファイルを読み
				込んだ後。
							*SessionWritePost*
SessionWritePost		|:mksession| コマンドを呼び出してセッションファ
				イルを書き込んだ後。
							*ShellCmdPost*
ShellCmdPost			|:!cmd|, |:shell|, |:make|, |:grep|を使って
				シェルコマンドを実行した後。変更されたファイル
				をチェックするのに使える。
							*ShellFilterPost*
ShellFilterPost			":{range}!cmd", ":w !cmd", ":r !cmd"を使って
				シェルコマンドを実行した後。変更されたファイル
				をチェックするのに使える。
							*SourcePre*
SourcePre			Vim script を読み込む前。|:source|
				<afile> は読み込まれるファイルの名前となる。
							*SourcePost*
SourcePost			Vim scriptを読み込んだ後。|:source|
				<afile>は読み込んだファイルの名前となる。読み
				込みが中断された場合はトリガーされない。
				自動コマンド SourceCmd がトリガーされた後にも
				トリガーされる。
							*SourceCmd*
SourceCmd			Vim script を読み込むとき。|:source|
				<afile>は読み込まれるファイルの名前となる。こ
				の自動コマンドはこのファイルを読み込まねばなら
				ない。
							*SpellFileMissing*
SpellFileMissing		スペルチェックファイルを読み込もうとしたが、見
				つからなかったとき。パターンは言語に対して照合
				される。<amatch>は言語。'encoding'も関係する。
				|spell-SpellFileMissing|を参照。
							*StdinReadPost*
StdinReadPost			標準入力からバッファへ読み込んだ後で、モードラ
				インを実行する前。Vimを開始したときに引数 "-"
				が使われた場合のみ使われる (|--| 参照)。
							*StdinReadPre*
StdinReadPre			標準入力からバッファへ読み込む前。Vimを開始し
				たときに引数 "-" が指定された場合のみ使われる
				(|--| 参照)。
							*SwapExists*
SwapExists			ファイルの編集を始めようとしてスワップファイル
				が存在することを検出したとき。この状況に対応す
				る方法を選択できるときだけユーザーにどうするか
				問い合わせる。
				変数|v:swapname|が見つかったスワップファイルの
				名前を保持する。<afile>は編集しようとしている
				ファイルである。|v:swapcommand|が開かれたファ
				イルで実行するコマンドを含んでいるかもしれな
				い。
				このコマンドは変数|v:swapchoice|をVimが次にど
				うするべきかを示す1文字の文字列にセットしなけ
				ればならない:
					'o'	読み込み専用で開く
					'e'	とにかくファイルを編集する
					'r'	復元する
					'd'	スワップファイルを削除する
					'q'	ファイルを編集せずに終了する
					'a'	CTRL-Cを押したのと同様に強制終
						了する
				これが空文字列にセットされると、自動コマンド
				SwapExistsが存在しないときと同様にユーザーに問
				い合わせをする。
				注意: バッファを変更しようとしてはならない。そ
				うすると予測できない結果になる。
							*E812*
				ここでは他のバッファに切り替えること、バッファ
				名を変更すること、ディレクトリを変更することは
				許可されていない。{+eval 機能が有効な場合のみ}
							*Syntax*
Syntax				オプション 'syntax' が設定されたとき。
				パターンは構文名に対して照合される。
				<afile> は 'syntax' が設定されたファイルの名前
				として使える。<amatch> は 'syntax' の新しい値
				として使える。
				|:syn-on| を参照。
							*TabClosed*
TabClosed			タブページを閉じた後。
							*TabClosedPre*
TabClosedPre			タブページを閉じる前。ウィンドウレイアウトが
				ロックされ、ウィンドウのオープンおよびクローズ
				が禁止される。
							*TabEnter*
TabEnter			タブページに入った直後 |tab-page|。WinEnterが
				発生した後、BufEnterが発生する前。
							*TabLeave*
TabLeave			タブページを離れる直前 |tab-page|。最初に
				WinLeaveが発生する。
							*TabNew*
TabNew				タブページが作成されたとき。 |tab-page|
				WinEnter イベントが最初にトリガーされ、
				TabEnter が実行される。
							*TermChanged*
TermChanged			オプション 'term' を変更した後。色やフォント等、
				ターミナル依存の設定を更新するために構文定義ファ
				イルを再読み込みするのに便利である。読み込まれ
				たバッファ全てで発生する。
							*TerminalOpen*
TerminalOpen			`:terminal` もしくは |term_start()| により端末
				バッファが生成された直後。このイベントは、
				++hidden オプションによってウィンドウなしに
				バッファが生成された場合でも発生する。
							*TerminalWinOpen*
TerminalWinOpen			`:terminal` もしくは |term_start()| により端末
				バッファが作成された直後。このイベントは、バッ
				ファがウィンドウと共に作成された場合にのみ発生
				する。端末ウィンドウのウィンドウローカルオプ
				ションの設定に使用できる。
							*TermResponse*
TermResponse			|t_RV| に対する応答をターミナルから受け取った
				とき。Vim変数 |v:termresponse| の値を使って、
				ターミナルのバージョンに応じた処理ができる。
				これは |defaults.vim| で putty 端末を検出し、
				暗い背景を設定するために使用される: >

				au TermResponse *
				\ if v:termresponse == "\e[>0;136;0c"
				\    set bg=dark
				\ endif
<
				Note: このイベントは他のイベントの処理中にも発
				行されることがある。特に、ファイル入出力、シェ
				ルコマンドの実行、時間の掛かる処理など。
							*TermResponseAll*
TermResponseAll			|t_RV|, |t_RC|, |t_RS|, |t_RB|, |t_RF|, または
				|t_u7| に対する応答をターミナルから受信した後。
				|v:termresponse|, |v:termblinkresp|,
				|v:termstyleresp|, |v:termrbgresp|,
				|v:termrfgresp|, および |v:termu7resp| の値を
				それぞれ使用できる。<amatch> は次のいずれかに
				設定される。
				    "version",
				    "cursorblink",
				    "cursorshape",
				    "background",
				    "foreground",
				    "ambiguouswidth"
				Note このイベントは、特にファイル I/O、シェル
				コマンド、またはその他の時間の掛かるものが関係
				する場合、別のイベントの実行途中でトリガーされ
				る可能性があることに注意。
							*TextChanged*
TextChanged			ノーマルモードでカレントバッファのテキストが変
				更されたとき。つまり |b:changedtick| が更新さ
				れた後。(自動コマンド TextChanged が定義される
				前にそれが起こったときも同様)
				未処理のキー入力がまだあるとき、またはオペレー
				タを待機しているときは、発生しない。
				Note: この自動イベントは `:noautocmd` を付けて
				もスキップできない。
				注意: このイベントは頻繁に発生するので、ユー
				ザーが予期しないことや時間のかかる処理は行わな
				いこと。
							*TextChangedI*
TextChangedI			挿入モードでカレントバッファのテキストが変更さ
				れたとき。
				ポップアップメニューが表示されているときは発生
				しない。
				他は TextChanged と同じ。
							*TextChangedP*
TextChangedP			挿入モードでカレントバッファのテキストが変更さ
				れたとき。ただしポップアップメニューが表示され
				ている場合に限られる。他は TextChanged と同じ。
							*TextChangedT*
TextChangedT			端末モードのカレントバッファのテキストが変更さ
				れたとき。
				他は TextChanged と同じ。
							*TextYankPost*
TextYankPost			カレントバッファでテキストがヤンクもしくは削除
				された後。|v:event| の以下の値は、この autocmd
				を発生させた操作を特定するのに使用できる:
				   inclusive	移動が |inclusive| の時に真と
						なり、|exclusive| のときはそう
						ではない。
				   operator	実行されたオペレータ。
				   regcontents	レジスタに格納された行区切りの
						テキストのリスト。以下と同様: >
						getreg(r, 1, 1)
<				   regname	レジスタの名前、もしくは無名レ
						ジスタの場合は空文字列、
						|registers| を参照。
				   regtype	レジスタの種類、|getregtype()|
						を参照。
				   visual	オペレーションが |Visual| エリ
						ア内で実行された場合Trueとなる。
				|quote_| が使用された場合、もしくは再帰的に呼
				び出された場合には発生しない。
				バッファのテキストを変更することは許されていな
				い、|textlock| を参照。 *E1064*
				また、'guioptions' または 'clipboard' に
				"autoselect" が設定されているために、Vim がビ
				ジュアル選択の所有者になろうとしたときにも間接
				的にトリガーされる。
				{+eval 機能付きでコンパイルされた場合のみ有効}

							*User*
User				自動的に実行されることはない。コマンド
				":doautocmd" によってのみ実行される自動コマン
				ドのために使用される。
				Note: 該当する自動コマンドが存在しないときに
				`:doautocmd User MyEvent` が使用された場合、エ
				ラーが発生する。これを回避したい場合、
				`exists('#User#MyEvent')` を使って定義されてい
				るかチェックするか、ダミーの自動コマンドを自身
				で定義すること。
				例: >
				    if exists('#User#MyEvent')
					doautocmd User MyEvent
				    endif
<
							*SigUSR1*
SigUSR1				SIGUSR1シグナルを受けとった後。Vimに通知する他
				の方法では実現できない場合に使われる。例えば、
				長い時間かかるビルド結果をチェックするためや、
				モーションセンサーが発火したとき。
				{Unix版のみ}

							*UserGettingBored*
UserGettingBored		ユーザーが同じキーを 42 回押したとき。
				ただの冗談！ :-)
							*VimEnter*
VimEnter			ファイル .vimrc の読み込みを含む、全てのスター
				トアップ処理を行い、"-c cmd" の引数を実行し、
				全てのウィンドウを構築し、それらにバッファを読
				み込んだ後。
				このイベントがトリガーされる直前に、
				|v:vim_did_enter| 変数が設定されているので、以
				下のことができる: >
				   if v:vim_did_enter
				     call s:init()
				   else
				     au VimEnter * call s:init()
				   endif
<							*VimLeave*
VimLeave			Vim を終了する前で、ファイル .viminfo を書き込
				んだ後。VimLeavePre のように、ただ1度だけ実行
				される。
				異常終了の検出には |v:dying| を使うこと。
				終了時に v:dying が 2 以上のときはこのイベント
				は発生しない。
				終了コードは |v:exiting| から得る。
							*VimLeavePre*
VimLeavePre			Vim を終了する前で、ファイル .viminfo を書き込
				む直前。これは終了時にたまたまカレントバッファ
				になったバッファの名前とマッチしたときに、ただ
				1度だけ実行される。大抵、パターンには "*" を使
				うと便利である。 >
	:autocmd VimLeavePre * call CleanupStuff()
<				異常終了の検出には |v:dying| を使うこと。
				終了時に v:dying が 2 以上のときはこのイベント
				は発生しない。
				終了コードは |v:exiting| から得る。
							*VimResized*
VimResized			Vimウィンドウのサイズが変わったとき。よって
				'lines' と 'columns' が変更される。しかし開始
				時には発生しない。
							*VimResume*
VimResume			Vimがサスペンドと |VimSuspend| がトリガーした
				後、Vimのインスタンスが復帰したとき。
				|:checktime| を実行してVimがサスペンド中にバッ
				ファ内容に変化がなかったことを保証するのに便利
				である: >
	:autocmd VimResume * checktime
<							*VimSuspend*
VimSuspend			Vimのインスタンスがサスペンドしたとき。Vim内で
				CTRL-Z がタイプされた時、もしくは SIGTSTP シグ
				ナルがVimに送られた時で、SIGSTOP ではない。
							*WinClosed*
WinClosed			ウィンドウが閉じる時、ウィンドウレイアウトから
				削除される直前。パターンは |window-ID| に対し
				て照合される。<amatch> と <afile> は共に
				|window-ID| を設定する。再帰的に発生しない(こ
				のイベントで自分自身を発行しない)。
							*WinEnter*
WinEnter			別のウィンドウに入った後。Vimの開始直後、1個目
				のウィンドウに入ったときは発生しない。ウィンド
				ウの高さを設定するのに便利である。
				そのウィンドウで他のバッファを開いていたときは、
				イベント WinEnter の後に BufEnter が発生する。
				Note: split と tabpage コマンドに関しては、
				WinEnter イベントが発生するのは分割もしくはタ
				ブコマンドの後だが、ファイルが読み込まれる前で
				ある。
							*WinLeave*
WinLeave			ウィンドウを離れる前。次に入るウィンドウで他の
				バッファを開いていたときは、イベント WinLeave
				の前に BufLeave が発生する (ただし ":new" を使っ
				たときはそうならない)。
				":qa" や "q" でVimを終了するときには発生しない。

							*WinNewPre*
WinNewPre			新しいウィンドウを作成する前。分割を作成して
				ウィンドウレイアウトを変更するコマンドの前にト
				リガーされる。
				ウィンドウ構造が未初期化だと大抵は安全ではない
				ため、タブページの作成や最初のウィンドウの場合
				は実行されない。
				WinNewPre イベントのコマンドの実行中にウィンド
				ウレイアウトを変更することはできない。
				カレントウィンドウのレイアウトを保存し、ウィン
				ドウの作成後に新しいレイアウトと比較するのに最
				も役立つ。

							*WinNew*
WinNew				新しいウィンドウが作成されたとき。Vim が起動し
				たばかりの最初のウィンドウでは行われない。
				WinEnter イベントの前。

							*WinScrolled*
WinScrolled			カレントのタブページのウィンドウでテキストが
				(水平または垂直)スクロールされるか、幅または高
				さが変更された後。|win-scrolled-resized| を参
				照。

				パターンは、スクロールかリサイズされた最初の
				ウィンドウの |window-ID| に対してマッチングさ
				れる。<amatch> と <afile> 両方が |window-ID|
				に設定される。

				|v:event| には、サイズとスクロールの変更情報が
				設定される。 |WinScrolled-event|

				起動が完了し、最初の画面の再描画がおこなわれた
				以降にのみ、トリガーを開始する。最初の
				WinScrolled または WinResized を定義するときに
				はトリガーされないが、さらに追加する時にはトリ
				ガーされるかもしれない。

				非再帰的: WinScrolled イベントのコマンドを実行
				している間はイベントはトリガーしない。ただし、
				コマンドによってウィンドウがスクロールまたはサ
				イズ変更される場合は、後で別の WinScrolled イ
				ベントがトリガーされる。


							*WinResized*
WinResized			カレントのタブページのウィンドウの幅または高さ
				が変更された後。|win-scrolled-resized| を参
				照。

				|v:event| にはサイズ変更に関する情報が設定され
				る。|WinResized-event|

				パターン、トリガー、再帰性については、
				|WinScrolled| と同じ挙動になる。

==============================================================================
6. パターン					*autocmd-patterns* *{aupat}*

引数 {aupat} にはコンマ区切りのリストを指定することができる。これによりコマン
ドは指定されたそれぞれのパターンについて実行される。例えばこのコマンド: >
	:autocmd BufRead *.txt,*.info set et
は下記と等しくなる: >
	:autocmd BufRead *.txt set et
	:autocmd BufRead *.info set et

ファイルパターン {aupat} がファイル名とマッチするかどうかは、2通りの方法で調べ
られる:
1. パターンに '/' が含まれないとき: Vimはファイル名の後ろの部分からのみマッチ
   を調べる (ファイル名の前につくディレクトリパスは除く)。
2. パターンに '/' が含まれるとき: Vimは短いファイル名 (ユーザーが打ち込んだも
   の) と長いファイル名 (短いファイル名をフルパスに展開し、シンボリックリンク
   ならその実体を探したもの) との両方から一致を調べる。

特別なパターンである <buffer> や <buffer=N> は、バッファローカルな自動コマンド
で使われる。|autocmd-buflocal| を参照。このパターンはバッファ名に対してマッチ
しない。

例: >
	:autocmd BufRead *.txt		set et
全てのテキストファイルに対しオプション 'expandtab' をオンにする。 >

	:autocmd BufRead /vim/src/*.c	set cindent
ディレクトリ /vim/src 内のC言語ファイルに対しオプション 'cindent' をオンにす
る。 >

	:autocmd BufRead /tmp/*.c	set ts=5
"/tmp/test.c" から "/home/nobody/vim/src/test.c" にリンクを張っていると、
"/tmp/test.c" の編集を始めたとき、この自動コマンドは実行される。

Note: パスの途中だけにマッチさせ、ルートディレクトリにマッチさせたくないとき
は、最初の1文字目に '*' を使う。例: >
	:autocmd BufRead */doc/*.txt	set tw=78
この自動コマンドは、例えば "/tmp/doc/xx.txt" や "/usr/home/piet/doc/yy.txt" に
マッチする。ここで、ディレクトリの深さは関係ない。


パターンがマッチするファイル名は、ワイルドカードを展開した後のものである。その
ため、次のコマンドを実行すると >
	:e $ROOTDIR/main.$EXT
まずコマンドの引数は、ファイル名が自動コマンドのパターンにマッチする前に、次の
ように展開される。 >
	/usr/root/main.py
イベント FileReadCmd 等を使うときにはこれに注意すること。<amatch> の値が、ユー
ザーの予期するものと違うかもしれない。


パターンの中で環境変数を使うこともできる。 >
	:autocmd BufRead $VIMRUNTIME/doc/*.txt  set expandtab
環境変数 $HOME が定義されているなら、~ をホームディレクトリとして使うこともで
きる。 >
	:autocmd BufWritePost ~/.vimrc   so ~/.vimrc
	:autocmd BufRead ~archive/*      set readonly
環境変数は、自動コマンドが定義されるときに展開される。自動コマンドが実行される
ときではない。これは command とは違っている!

							*file-pattern*
パターンの解釈方法は、ファイル名の解釈方法と大体同じである。
	*	はあらゆる文字の列にマッチ。注意: パス区切り文字も含まれる。
	?	はあらゆる1文字にマッチ
	\?	は '?' にマッチ
	.	は '.' にマッチ
	~	は '~' にマッチ
	,	はパターンを分割する
	\,	は ',' にマッチ
	{ }	は |pattern| の \( \) と同様
	,	('{' '}' の内側では) |pattern| の \| と同様
	\}	リテラルの }
	\{	リテラルの {
	\\\{n,m\}  |pattern| の \{n,m} と同様
	\	は |pattern| で使われるものと同様の特別な意味を持つ
	[ch]	は 'c' または 'h' にマッチ
	[^ch]	は 'c' と 'h' 以外の文字にマッチ

'/' という文字は、全てのシステムでパスの区切り文字に使われることに注意すること
(MS-Windowsでさえも)。これは、パターン内でバックスラッシュを使うことが難しい上
に、別々のシステムでも自動コマンドが動作するようにするためである。

|pattern| を使うことができる。上記の翻訳が行われているため、期待通りに機能しな
い可能性がある。

							*autocmd-changes*
パターンマッチの検索は、イベントの発生時に行われる。自動コマンドのどれかでバッ
ファ名を変更しても、それどころかバッファを削除しても、実行される 自動コマンド
は変わらない。例: >

	au BufEnter *.foo  bdel
	au BufEnter *.foo  set modified

これはカレントバッファを削除し、代わりにカレントバッファになったバッファ内でオ
プション 'modified' をオンにする。Vimは "*.foo" が新しいカレントバッファのバッ
ファ名にマッチしなくとも気にしない。"*.foo" はイベントが発生した時点でのバッ
ファ名にマッチする。

しかし、|:bwipe|でワイプアウトされたバッファに対しては、バッファローカルな自動
コマンドは実行されない。|:bdel|で削除されたバッファは実際にはまだ存在している
(リストされなくなっただけ)なので、自動コマンドは実行される。

==============================================================================
7. バッファローカルな自動コマンド	*autocmd-buflocal*
					*autocmd-buffer-local*
					*<buffer=N>* *<buffer=abuf>* *E680*

バッファローカルな自動コマンドは特定のバッファに結びつけられている。これは名前
を持たないバッファや特定のパターンにマッチしない名前のバッファに使うと便利であ
る。しかしそれぞれのバッファに明示的に追加する必要がある。

バッファローカルな自動コマンドはパターンの代わりに以下の形式のどれかを使う:
	<buffer>	カレントバッファ
	<buffer=99>	バッファ番号99
	<buffer=abuf>	<abuf> の使用(自動コマンドを実行するときのみ)
			|<abuf>|

例: >
    :au CursorHold <buffer>  echo 'hold'
    :au CursorHold <buffer=33>  echo 'hold'
    :au BufNewFile * au CursorHold <buffer=abuf>  echo 'hold'

自動コマンドに対するコマンドは全てバッファローカルな自動コマンドに対しても機能
する。パターンの代わりに特別な文字列を使う。例: >
    :au! * <buffer>		     " カレントバッファのバッファローカル自動
				     " コマンドを削除する
    :au! * <buffer=33>		     " バッファ#33のバッファローカル自動コマン
				     " ドを削除する。
    :bufdo :au! CursorHold <buffer>  " 全バッファから指定されたイベントに対す
				     " る自動コマンドを削除する
    :au * <buffer>		     " カレントバッファのバッファローカル自動
				     " コマンドをリストする

カレントバッファに対して自動コマンドを定義するとき、それがバッファ番号とともに
保存されることに注意。つまりカレントバッファ番号が12なら "<buffer=12>" という
形になる。例えば自動コマンドをリストするときこの形式で表示される。

バッファローカル自動コマンドが存在するかを判定するには関数|exists()|を次のよう
に使う: >
    :if exists("#CursorHold#<buffer=12>") | ... | endif
    :if exists("#CursorHold#<buffer>") | ... | endif    " for current buffer

バッファがワイプアウトされると当然バッファローカル自動コマンドも失われる。
":bdel" などでバッファを削除するときは、それがリストからなくなるだけで、自動コ
マンドはまだ存在していることに注意。バッファローカル自動コマンドの削除を表示さ
せるにはこうする: >
    :set verbose=6

存在しないバッファに対してバッファローカル自動コマンドを定義することはできな
い。

==============================================================================
8. グループ						*autocmd-groups*

自動コマンドはグループにまとめることができる。これは一連の自動コマンドを取り除
いたり実行したりする際に便利である。例えば、構文強調表示のための全ての自動コマ
ンドはグループ "highlight" に入っていて、GUIの開始時に
":doautoall highlight BufRead" で実行できる。

特定のグループが選択されないとき、既定のグループが使われる。既定のグループには
名前がない。既定のグループから個別に自動コマンドを実行することはできない。それ
らを実行できるのは、全てのグループに対する自動コマンドを実行するときのみであ
る。

普通、自動コマンドを自動的に実行するときは、全てのグループに対する 自動コマン
ドが使われる。グループが問題になってくるのは、":doautocmd" や ":doautoall" に
よって自動コマンドを実行するときと、自動コマンドを定義したり削除するときであ
る。

グループ名には空白を除く全ての文字が使える。"end" というグループ名は予約語に
なっている (大文字も)。

グループ名では大文字と小文字を区別して扱う。イベントの名前とは違うことに注意す
ること。

							*:aug* *:augroup*
:aug[roup] {name}		後に続くコマンド ":autocmd" のためのグループ名
				を定義する。{name} を "end" や "END" にすると
				既定のグループが選ばれる。
				混乱を避けるため、既存の {event} の名前とは違
				う名前をつけるべきである。これはたいてい意図し
				ない動作を引き起こす。

					*:augroup-delete* *E367* *W19* *E936*
:aug[roup]! {name}		自動コマンドのグループ {name} を削除する。その
				グループを使っている自動コマンドがまだあるな
				ら、これは使わないこと！その点はチェックされな
				い。とにかくそれをしたら、警告が表示される。グ
				ループが現在のグループの場合、エラーE936が表示
				される。

特定のグループとして自動コマンドを定義するには、次の手順に従うこと。
1. ":augroup {name}" によってグループを選択する。
2. ":au!" によって古い自動コマンドを全て消去する。
3. 自動コマンドを定義する。
4. ":augroup END" によって既定のグループに戻る。

例: >
	:augroup uncompress
	:  au!
	:  au BufEnter *.gz	%!gunzip
	:augroup END

これで自動コマンドを (例えばファイル .vimrc を再び読み込んだ後) 2回定義するこ
とが防げる。

						*FileExplorer*
Vim によって認識されるグループが1つある: FileExplorer。このグループが存在する
なら Vim はディレクトリが編集可能であると想定しディレクトリ内のファイルを列挙
するプラグインが呼ばれる。これは |netrw| プラグインによって使われる。これによ
り次のことが可能になる: >
	browse edit

==============================================================================
9. 自動コマンドの実行				*autocmd-execute*

自動コマンドは「自動的」でなくとも実行できる。これはあなたが自動コマンドを変更
したときや、間違った自動コマンドが実行されたとき (つまりファイルパターンのマッ
チングが間違っていたとき) に便利である。

NOTE オプション 'eventignore' はここにも適用されることに注意。ここに列挙された
イベントでは、どんな自動コマンドも実行されない。

				*:do* *:doau* *:doaut* *:doautocmd* *E217*
:do[autocmd] [<nomodeline>] [group] {event} [fname]
			[fname] (省略するとカレントファイルの名前) にマッチす
			る、{event} のための自動コマンドをカレントバッファに
			適用する。カレントファイル名が正しいファイルパターンに
			マッチしないときや設定を変えた後、またはあるイベントの
			ために自動コマンドを実行するために使用できる。
			これを自動コマンドの内部で実行することも可能である。
			だから、ある拡張子用の自動コマンドを元にして別の拡張子
			用のものを作ることができる。例: >
				:au BufEnter *.cpp so ~/.vimrc_cpp
				:au BufEnter *.cpp doau BufEnter x.c
<			無限の循環に陥らないよう注意すること。また
			|autocmd-nested| を参照すること。

			引数 [group] が省かれると、全てのグループの自動コマン
			ドが実行される。[group] が指定されると、それにマッチす
			るグループの自動コマンドのみが実行される。NOTE 定義さ
			れていないグループ名を使うと、エラーメッセージが表示さ
			れる。
							*<nomodeline>*
			自動コマンドを適用した後にモードラインが処理される。
			ファイルを編集するときと同じように、自動コマンドでなさ
			れた設定を上書きするためである。<nomodeline> が指定さ
			れている場合はモードラインは処理されない。バッファの
			ロード以外で使われるイベント (例えば |User|) などは
			<nomodeline> を指定したほうがよいかもしれない。
			一致する自動コマンドが実行されなかった場合も、モードラ
			インの処理はスキップされる。

						*:doautoa* *:doautoall*
:doautoa[ll] [<nomodeline>] [group] {event} [fname]
			":doautocmd" と似ているが、読み込まれたバッファそれぞ
			れに自動コマンドを適用する。カレントバッファは最後に処
			理される。

			Note [fname] は自動コマンドを選択するのに使われる。コ
			マンドを適用するバッファではない。例: >
				augroup mine
				  autocmd!
				  autocmd FileType * echo expand('<amatch>')
				augroup END
				doautoall mine FileType Loaded-Buffer
<			このスクリプトを読み込むと、読み込まれたバッファの数だ
			け "Loaded-Buffer" が表示される。

			Note: このコマンドで、バッファを削除したり、バッファを
			変えたり、バッファの内容を変えるような自動コマンドを実
			行しないこと。結果は予期できない。このコマンドは、オプ
			ションを設定したり、構文強調表示を変えたりする自動コマ
			ンドのためのものである。

==============================================================================
10. 自動コマンドを使う					*autocmd-use*

「ファイルの書き込み」には、4組のイベントが起こりうる。1回の書き込みコマンドで
は、これらのうち1組しか使われない。

BufWriteCmd	BufWritePre	BufWritePost	バッファ全体を書き込む
		FilterWritePre	FilterWritePost	フィルタ用一時ファイルに書込む
FileAppendCmd	FileAppendPre	FileAppendPost	ファイルに追加する
FileWriteCmd	FileWritePre	FileWritePost	その他の書き込み

"*Cmd" にマッチする自動コマンドがあるときは、それが書き込み作業を行うものと想
定される。書き込みはそれ以上行われず、他のイベントも発生しない。 |Cmd-event|

Note イベント *WritePost による自動コマンドは、イベント *WritePre による自動コ
マンドの引き起こしたバッファに対する変化を、どのようなものでもアンドゥすべきで
あることに注意。さもないと、ファイルの書き込みがバッファを変更するという副作用
を持ってしまう。

あるバッファの中の行をファイルに書き込むとき、自動コマンドを実行する前にその
バッファが一時的にカレントバッファになる。自動コマンドがカレントバッファを変更
したり、元のカレントバッファを消去しない限り、カレントバッファは再び元に戻る。

イベント *WritePre や *AppendPre による自動コマンドは、書き込み元のバッファを
削除してはならない。

マーク '[ と '] は特別な位置を記憶している。
- イベント *ReadPre の前に、新しい行が挿入される所の上の行にマーク '[ が設定さ
  れる。
- イベント *ReadPost の前に、読み込まれた最初の行にマーク '[ が、最後の行にマー
  ク '] が設定される。
- イベント *WriteCmd, *WritePre と *AppendPre による自動コマンドが実行される前
  に、書き込まれる最初の行にマーク '[ が、最後の行にマーク '] が設定される。
注意: バッファを変更するコマンドを使うと、'[ と '] の場所も変更される。

ファイル名を必要とするコマンドでは、読み込まれるファイル名に "<afile>" を使う
ことができる (カレントファイル名に "%" を使うこともできる) |:<afile>|。現在有
効なバッファ番号には "<abuf>" を使うことができる。これは名前を持たないバッファ
に対しても有効だが、バッファを持たないファイルには使えない (例えば、":r file"
で読み込まれたファイル)。

							*gzip-example*
圧縮されたファイルを読み書きする例: >
  :augroup gzip
  :  autocmd!
  :  autocmd BufReadPre,FileReadPre	*.gz set bin
  :  autocmd BufReadPost,FileReadPost	*.gz '[,']!gunzip
  :  autocmd BufReadPost,FileReadPost	*.gz set nobin
  :  autocmd BufReadPost,FileReadPost	*.gz execute ":doautocmd BufReadPost " .. expand("%:r")
  :  autocmd BufWritePost,FileWritePost	*.gz !mv <afile> <afile>:r
  :  autocmd BufWritePost,FileWritePost	*.gz !gzip <afile>:r
>
  :  autocmd FileAppendPre		*.gz !gunzip <afile>
  :  autocmd FileAppendPre		*.gz !mv <afile>:r <afile>
  :  autocmd FileAppendPost		*.gz !mv <afile> <afile>:r
  :  autocmd FileAppendPost		*.gz !gzip <afile>:r
  :augroup END

グループ "gzip" は、":autocmd!" で既存の自動コマンドを全て削除できるようにする
ために使われている。これはスクリプトファイルが2回読み込まれたときのためである。

("<afile>:r" は拡張子のないファイル名である。|:_%:| を参照)

イベント BufNewFile, BufRead/BufReadPost, BufWritePost, FileAppendPost,
VimLeave によって実行された自動コマンドは、バッファの被修正フラグを切り替えな
い。BufReadPost による自動コマンドで、圧縮されているバッファを解凍したときは、
":q" でVimを終了することができる。BufWritePre による自動コマンドの起こした変
更を戻すために BufWritePost で ":undo" を使ったときも、":q" を使うことができる
("ZZ" も可)。バッファが変更されたことにしたいなら、":set modified" とすること。

自動コマンドからノーマルモードのコマンドを実行したいときは、コマンド ":normal"
を使うこと。使うときは注意！ノーマルモードのコマンドが完結していないと、ユー
ザーが文字を打ち込まないといけない (例えば、":normal m" の後にはマーク名を打ち
込まないといけない)。

バッファの内容を変更した後に、変更されていないことにしたいなら、オプション
'modified' をオフにすること。こうすると ":q!" ではなく ":q" でもVimを終了でき
る。

						*autocmd-nested* *E218*
既定では、自動コマンドはネストしない (入れ子にならない)。例えば、自動コマンド
内で ":e" や ":w" を使っても、これらに対してはイベント BufRead や BufWrite に
よる自動コマンドは実行されない。もしこれを実行してほしいなら、ネストしてほしい
コマンド内でフラグ "nested" を使うこと。例: >
  :autocmd FileChangedShell *.c ++nested e!
再帰的ループを避けるために、ネストは10段階までに制限されている。

自動コマンドの中でコマンド ":au" を使うこともできる。これは自己修正的 {訳注:
原文 "self-modifying"} なコマンドになりうる! これは1回だけ実行すべき自動コマン
ドに便利である。

あるコマンドを実行するときだけ自動コマンドをスキップしたい場合は、修飾子
|:noautocmd| を使うかオプション 'eventignore' を使う。

Note (":read file" やフィルタコマンドで) 読み込んだファイルの最後の行に <EOL>
がないとき、Vimはこのことを記憶する。その次の (":write file" やフィルタコマン
ドでの) 書き込みで、先ほどの最後の行が再び最後の行として書き込まれ、かつオプ
ション 'binary' がオンになっていると、<EOL> は付け足されない。これにより、読み
込まれた行に対するフィルタコマンドで、読み込まれた通りに書き出すことができる。
また、フィルタ処理された行に対する書き込みのコマンドで、フィルタが出力した通り
に書き出すことができる。例えば、圧縮されたファイルを書き込むもう一つの例は以下
のようになる。 >

  :autocmd FileWritePre *.gz   set bin|'[,']!gzip
  :autocmd FileWritePost *.gz  undo|set nobin
<
							*autocommand-pattern*
コンマで区切られた複数のパターンを指定することもできる。以下にいくつか例を挙げ
る。 >

  :autocmd BufRead   *		set tw=79 nocin ic infercase fo=2croq
  :autocmd BufRead   .letter	set tw=72 fo=2tcrq
  :autocmd BufEnter  .letter	set dict=/usr/lib/dict/words
  :autocmd BufLeave  .letter	set dict=
  :autocmd BufRead,BufNewFile   *.c,*.h	set tw=0 cin noic
  :autocmd BufEnter  *.c,*.h	abbr FOR for (i = 0; i < 3; ++i)<CR>{<CR>}<Esc>O
  :autocmd BufLeave  *.c,*.h	unabbr FOR

Makefile (makefile, Makefile, imakefile, makefile.unix 等) にマッチさせるには
こうする。 >

  :autocmd BufEnter  ?akefile*	set include=^s\=include
  :autocmd BufLeave  ?akefile*	set include&

Cソースファイルを編集するとき、常に最初の関数から始めるにはこうする。 >

  :autocmd BufRead   *.c,*.h	1;/^{

上の "1;" がないと、検索が始まる場所はファイルの最初ではなく、ファイルの挿入さ
れた場所になる。

						*skeleton* *template*
新しいファイルを作るときにスケルトン (テンプレート) ファイルを読み込むにはこう
する。 >

  autocmd BufNewFile  *.c	0r ~/vim/skeleton.c
  autocmd BufNewFile  *.h	0r ~/vim/skeleton.h
  autocmd BufNewFile  *.java	0r ~/vim/skeleton.java

HTMLファイルを書き込むときに現在の日付と時刻を挿入したいならこうする {訳注:
KoRoN氏作成のautodate.vimを使った方がよい} >

  :autocmd BufWritePre,FileWritePre *.html   ks|call LastMod()|'s
  :fun LastMod()
  :  if line("$") > 20
  :    let l = 20
  :  else
  :    let l = line("$")
  :  endif
  :  exe "1," .. l .. "g/Last modified: /s/Last modified: .*/Last modified: " ..
  :  \ strftime("%Y %b %d")
  :endfun

これを機能させるためには、ファイルの先頭から20行以内に "Last modified: <date
time>" という行を入れる必要がある。Vimは <date time> (とその行内のそれ以後を)
を現在の日付と時刻に置き換える。説明:
	ks		現在の位置をマーク 's' に設定する
	call LastMod()  関数 LastMod() を呼び出して実際の作業を行う
	's		カーソルを元の位置に戻す
関数 LastMod() はファイルの長さが20行以下であるかを調べ、キーワード
"Last modified: " の含まれる行を探すためにコマンド ":g" を実行する。キーワード
の含まれる行に対しては ":s" が実行され、既存の日付を現在のものに置き換える。
":execute" は ":g" や ":s" で expression を使えるようにするためのものである。
日付は関数 strftime() から得られる。strftime() の引数を変更して、別の形の日付
を得ることもできる。

コマンドラインから自動コマンドを入力すると、(<Tab> や CTRL-D などで) イベント
とコマンド名が適切に補完される。

Vimはマッチする全ての自動コマンドをユーザーの指定した順に実行する。ユーザーが
実行させる最初の自動コマンドにはファイルパターンに "*" を使い、全てのファイル
に適用されるようにするとよい。これはつまり、あらゆる設定のための既定を好きなよ
うに定義することができ、もしマッチする自動コマンドが別にあれば、そちらの方が設
定を上書きできるということである。しかしマッチする自動コマンドが他になければ、
少なくともあなたの設定した既定は回復される (もし自動コマンドがマッチした別の
ファイルから、マッチしなかったファイルに移っても)。 Note Unixのシェルと違い、
"*" は "." で始まるファイルにもマッチすることに注意。

						    *autocmd-searchpat*
自動コマンドは現在の検索パターンを変更しない。Vimは自動コマンドの実行前に現在
の検索パターンを保存し、自動コマンドが終了してから復元する。つまり自動コマンド
はオプション 'hlsearch' で強調表示されている文字列に影響しないということである。
自動コマンド内でも、例えばコマンド "n" 等で、検索パターンは普通に使用できる。
もし自動コマンドの中で終了後に使う検索パターンを設定したいなら、":let @/ =" と
すること。
自動コマンドの中で ":nohlsearch" を使って、検索語の強調表示を無効にすることは
できない。Vimの開始時に検索語の強調表示を行わないためには、'viminfo' のフラグ
'h' を使うこと。

							*Cmd-event*
イベント "*Cmd" のうちどれかを使うと、それによる自動コマンドが読み込み、書き込
み、またはsourceを行うものと想定される。これは特殊なファイル、例えばリモートシ
ステム上のファイルに作業をするときに使える。
注意: これらのイベントを誤った方法で使うと、そのイベントが発生するファイルの読
み書きが不可能になってしまう。自分の自動コマンドをしっかりテストすること。最良
の方法は、普通のファイル名には決してマッチしないパターン (例えば "ftp://*") を
使うことである。

BufReadCmd に対して自動コマンドを定義すると、クラッシュしたセッションの復旧が
難しくなる。元のファイルから復旧するとき、Vimはスワップファイル内に見つからな
かった部分のみを読み込む。それは BufReadCmd の自動コマンドを使ったときは不可能
なので、コマンド |:preserve| を使って元のファイルが復旧に必要ないようにするこ
と。そうするのはファイルが変更を受けたと判断したときのみでもよい。

読み込みと書き込みのコマンドの場合、Vim変数 |v:cmdarg| は引数 "++enc=" と
"++ff=" の、有効だったものを保持している。これらはファイルを読み書きするコマン
ドで使われるべきである。Vim変数 |v:cmdbang|はコマンドに "!" が使われたときに
1、そうでないときに 0 が設定される。

例は標準プラグイン $VIMRUNTIME/plugin/netrwPlugin.vim を参照。

==============================================================================
11. 自動コマンドを無効にする				*autocmd-disable*

一時的に自動コマンドを無効にするにはオプション 'eventignore' を使う。これは予
期しない振るまいを引き起こす可能性がある。|:finally|つきの|:try|ブロックを使っ
て後で 'eventignore' を元に戻すようにすること。

特定のウィンドウで autocmds を無期限に無効にするには、'eventignorewin' オプショ
ンを使用する。これは、ウィンドウとバッファ関連のイベントを無視する場合にのみ使
用できる。

							*:noautocmd* *:noa*
1つのコマンドを実行する間だけ自動コマンドを無効にするには修飾子 ":noautocmd"
を使う。これは後に続くコマンドを実行する間だけ、'eventignore' を "all" にセッ
トする。例: >

	:noautocmd w fname.gz

これはgzipプラグインで定義された自動コマンドを発生させずにファイルを書き込む。

Note 処理の最中ではなく、終わった後で呼び出される自動コマンドもある。特に
|CursorMoved| や |TextChanged| があてはまる。


 vim:tw=78:ts=8:noet:ft=help:norl:
