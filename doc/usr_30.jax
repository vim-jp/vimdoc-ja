*usr_30.txt*	For Vim バージョン 9.1.  Last change: 2025 Jun 10

		     VIM USER MANUAL - by Bram Moolenaar

			       プログラムの編集


プログラミングに役立つ機能が Vim にはたくさんあります。プログラムをコンパイル
してエラーが出た行にジャンプしたり、言語に合わせて自動的にインデントしたり、コ
メントを整形したりできます。

|30.1|	コンパイル
|30.2|	C 言語系インデント
|30.3|	インデント設定の自動化
|30.4|	その他のインデント
|30.5|	タブとスペース
|30.6|	コメントの整形

次章: |usr_31.txt|  GUI を活用する
前章: |usr_29.txt|  プログラムの中を移動する
目次: |usr_toc.txt|

==============================================================================
*30.1*	コンパイル

Vim にはquickfix機能があります。これは、Vim の中でプログラムをコンパイルして、
エラーになった場所に移動し、エラーを修正するための機能です。そうして、正常にコ
ンパイルできるまでコンパイルとエラー修正を繰り返します。

次のコマンドは "make" を実行し、その出力を読み込みます (引数はそのまま渡されま
す): >

	:make {arguments}

エラーが発生するとそれが認識され、最初のエラーにカーソルが移動します。
":make" の使い方を実際に見てみましょう。(典型的な :make セッションはもっと多く
のエラーあるいは少しのゴミを出力しますが) ":make" を実行すると次のような出力が
画面に表示されます:

	:!make | &tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~

	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Hit ENTER or type command to continue ~

"main.c" の中でエラーが発生していることが確認できると思います。<Enter> を押す
と "main.c" ファイルが開き、6 行目 (最初のエラー) にカーソルが移動します。自分
でファイルを開く必要はありません。Vim はエラーメッセージを認識できます。

		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      cursor -> |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+

このコマンドで次のエラーに移動できます: >

	:cnext

カーソルが 10 行目に移動します。ファイルの最終行に余分な '}' がありますね。長
すぎるエラーメッセージは省略して表示されます。全部を表示するには次のコマンドを
使います: >

	:cc

すべてのエラーメッセージを表示するには ":clist" コマンドを使います。次のような
出力が表示されます: >

	:clist
<	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~

ファイル名と行番号が認識された行だけが表示されますが、それは、重要なのはそのよ
うな行だけで、他の行は無駄なメッセージであると判断されるからです。しかし時に
は、認識されなかった行が重要な情報を含んでいることもあります。例えばリンカが未
解決の関数をエラー表示した場合などです。すべてのメッセージを表示するにはコマン
ドに "!" を付けます: >

	:clist!
<	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~

現在のエラーは強調表示されます。前のエラーに戻るには次のコマンドを使います: >

	:cprevious

エラーリストを移動するコマンドは他にもあります:

	:cfirst		最初のエラー
	:clast		最後のエラー
	:cc 3		3つ目のエラー


☆他のコンパイラを使う

":make" コマンドが実際に実行するプログラムは 'makeprg' オプションで設定しま
す。通常は "make" に設定されていますが、例えば Visual C++ を使う場合は "nmake"
に設定する必要があります: >

	:set makeprg=nmake

オプションにはプログラムの引数も含めることができます。特殊文字はバックスラッ
シュでエスケープしてください。例: >

	:set makeprg=nmake\ -f\ project.mak

プログラムの設定には特殊なキーワードが使えます。文字 % はカレントファイルの名
前に展開されます。例えば次のように設定すると: >

	:set makeprg=make\ %:S

main.c を編集しているときに ":make" を実行すると次のコマンドが実行されます: >

	make main.c

これ自体はそれほど便利ではありませんが、すこし変更して :r (root) 修飾子を使う
とどうでしょう: >

	:set makeprg=make\ %:r:S.o

これで、実行されるコマンドは次のようになります: >

	make main.o

修飾子については |filename-modifiers| を参照してください。


☆古いエラーリスト

例えば ":make" を実行したときに、一つのファイルで警告メッセージが出て、他の
ファイルではエラーが出たとします。エラーを修正し、本当に直ったかどうかを確認す
るためにもう一度 ":make" を実行しました。さて、ここで先程の警告メッセージを確
認しようとしても、エラーリストには警告メッセージありません。なぜなら、警告メッ
セージを出したファイルは再コンパイルされなかったからです。次のコマンドで古いエ
ラーリストに戻ることができます: >

	:colder

":clist" と ":cc {nr}" を使って、警告が発生した場所にジャンプしましょう。
次のコマンドで新しいエラーリストに戻れます: >

	:cnewer

全部で 10 個までのエラーリストを保持しておくことができます。


☆他のコンパイラを使う

コンパイラが出力するエラーメッセージの書式を調べ、'errorformat' オプションを設
定する必要があります。このオプションの構文は非常に複雑ですが、どのようなコンパ
イラにも対応できます。詳しい説明は |errorformat| を参照してください。

複数のコンパイラを使うとき、コンパイラを変更するたびに 'makeprg' や
'errorformat' を設定するのは面倒ですよね。簡単な方法が用意されています。例え
ば、Microsoft Visual C++ なら次のように設定します: >

	:compiler msvc

"msvc" 用のスクリプトが検索され、適切なオプションが設定されます。
自分で設定スクリプトを書くこともできます。|write-compiler-plugin| 参照。


☆出力のリダイレクト

":make" コマンドは、実行したプログラムの出力をエラーファイルにリダイレクトしま
す。その動作はいろいろな要因に依存しています (例えば 'shell' オプション)。
":make" コマンドがプログラムの出力を拾えていないようなら、'makeef' オプション
と 'shellpipe' オプションを確認してみてください。'shellquote' オプションと
'shellxquote' オプションも関係あるかもしれません。

どうしても ":make" コマンドのリダイレクトが機能しない場合は、シェルからコンパ
イルを実行して、その出力をファイルにリダイレクトしてください。そして、次のコマ
ンドでそのファイルを読み込みます: >

	:cfile {filename}

":make" コマンドと同様にエラーにジャンプできます。

==============================================================================
*30.2*	C 言語系インデント

プログラムを適切にインデントするとコードが読みやすくなります。Vim の機能を使え
ばインデントするのは簡単です。C 言語、あるいは C++ や Java などの C スタイルの
プログラムなら 'cindent' オプションをオンに設定してください。C 言語のインデン
トは組み込みで用意されていて、複雑な構文でも適切にインデントできます。インデン
トに使うスペースの数は 'shiftwidth' オプションで設定します。スペース 4 個くら
いが適切でしょうか。次のコマンドで設定できます: >

	:set cindent shiftwidth=4

このオプションを設定すると、例えば "if (x)" と入力したときに、次の行が自動的に
インデントされます。

				    if (flag)
	インデントが増える --->		do_the_work();
	インデントが減る   <--	    if (other_flag) {
	インデントが増える --->		do_file();
	インデントそのまま		do_some_more();
	インデントが減る   <--	    }

波カッコ ({}) の中でテキストを入力すると、最初の行でインデントが増え、最後の行
でインデントが減ります。インデントが減るのは '}' を押したタイミングです (入力
を予測することはできないので)。

自動インデントには、コーディングのミスを早く発見できるという副作用があります。
例えば、関数の最後で } を入力したときに、インデントが本来よりも多くなったとし
たら、どこかで } を入力し忘れています。"%" コマンドを使って、最後に入力した }
と対になっている { を探しましょう。
同様に、) や ; を忘れると、次の行のインデントが増えます。もし予想よりもインデ
ントが多くなってしまった場合は直前の行を確認してください。

書式が汚いコードを編集するとき、あるいは編集によってインデントが崩れてしまった
場合、コードを再インデントする必要があります。それには "=" オペレータを使いま
す。最も単純なのは次の使い方です: >

	==

現在行がインデントされます。他のオペレータと同様、使い方は三通りあります。ビ
ジュアルモードで "=" を使うと、選択範囲の行がインデントされます。テキストオブ
ジェクトで便利なのは "a{" です。これは現在のブロックを選択します。つまり、次の
コマンドでコードのブロックをインデントできます: >

	=a{

コードが根本的に汚い場合は、次のコマンドでファイル全体を再インデントできます:
>
	gg=G

ただし、手作業で丁寧にインデントされたファイルに対してこれを実行してはいけませ
ん。自動インデントは良い仕事をしてくれますが、場合によってはそのルールを破る必
要もあるからです。


☆インデントスタイルの設定

インデントスタイルは人によってさまざまです。初期設定では 90% のプログラマが満
足するようなスタイルに設定されています。しかし、世の中にはいろいろなスタイルが
あるので、必要なら、'cinoptions' を設定することで、インデントスタイルをカスタ
マイズできます。
'cinoptions' の初期設定は空です。その場合はデフォルトのスタイルが使われます。
このオプションに値を追加していくことでスタイルを変更できます。例えば、波カッコ
の位置を次のようにしたい場合は:

	if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~

次のコマンドを使います: >

	:set cinoptions+={2

設定できる項目はたくさんあります。|cinoptions-values| 参照。

==============================================================================
*30.3*	インデント設定の自動化

C ファイルを開くたびに 'cindent' オプションを設定するのは面倒ですよね。インデ
ントの設定は自動化できます: >

	:filetype indent on

実際には、C ファイルに対して 'cindent' をオンにする以外の機能も有効になりま
す。まず最初に、ファイルタイプの認識が有効になります。認識機能は構文強調表示で
使われているものと同じです。
ファイルタイプが認識されると、そのファイルタイプ用のインデントファイルが検索さ
れます。Vim にはさまざまな言語に対応したインデントファイルが付属しています。イ
ンデントファイルが読み込まれ、自動インデントのための設定が行われます。

インデント設定の自動化は次のコマンドでオフにできます: >

	:filetype indent off

特定のファイルタイプだけインデントを無効にしたい場合は、次のような一行だけの
ファイルを作成してください: >

	:let b:did_indent = 1

これを、決められた名前で保存します:

	{directory}/indent/{filetype}.vim

{filetype} は "cpp" や "java" といったファイルタイプの名前です。次のコマンドで
Vim が使っている名前を確認できます: >

	:set filetype

例えばこのヘルプファイルなら次のように表示されます:

	filetype=help ~

したがって、{filetype} には "help" が入ります。
{directory} はランタイムディレクトリです。次のコマンドの出力を調べてください:
>
	set runtimepath

ここでは先頭のパスを使います。つまり、出力が次のようなら:

	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~

{directory} には "~/.vim" が入ります。したがって、ファイル名は次のようになりま
す:

	~/.vim/indent/help.vim ~

インデントをオフにするのではなく、自分のインデントファイルを作成したい場合は、
|indent-expression| を参照してください。

==============================================================================
*30.4*	その他のインデント

最もシンプルな自動インデントは 'autoindent' オプションを使う方法です。これは直
前の行と同じインデントを使います。'smartindent' はもう少しスマートです。これは
インデントファイルが用意されていないような場合に使います。'smartindent' は
'cindent' より低機能ですが、'autoindent' よりは高機能です。
'smartindent' をオンにすると、{ でインデントが一つ増え、} で減ります。さらに、
'cinwords' オプションに設定された単語が現れた場合もインデントが増えます。# で
始まる行は特別扱いされ、一切インデントされません。つまり、プリプロセッサーディ
レクティブの行はインデントされません。その次の行は通常通りインデントされます。


☆インデントの訂正

'autoindent' や 'smartindent' を設定すると、直前の行と同じインデントを使うこと
ができますが、自分でインデントを ('shiftwidth' の幅ずつ) 増やしたり減らしたり
する必要も多々あります。それには挿入モードで CTRL-D と CTRL-T を使うと簡単で
す。例えば、次のようなシェルスクリプトを入力してみましょう:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~

まず、次のオプションを設定します: >

	:set autoindent shiftwidth=3

一行目を入力し、<Enter> を押して二行目を開始します:

	if test -n a; then ~
	echo ~

二行目にはインデントが必要ですね。CTRL-T を押します:

	if test -n a; then ~
	   echo ~

挿入モードの CTRL-T コマンドは、'shiftwidth' の幅だけインデントを増やします。
カーソルの位置は関係ありません。
二行目を入力し、<Enter> を押して三行目を開始します。三行目のインデントは問題あ
りません。<Enter> を押して最後の行を入力します。テキストは次のようになりまし
た:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~

最後の行の余分なインデントを削除するには CTRL-D 押します。これは 'shiftwidth'
の幅だけインデントを減らします。カーソルの位置は関係ありません。
ノーマルモードでは ">>" コマンドと "<<" コマンドで同様の操作ができます。">" と
"<" はオペレータなので、他のオペレータと同様に、インデントを変更する範囲を三通
りの方法で指定できます。次の組み合わせが特に便利です: >

	>i{

現在のブロックのインデントが増えます。変更されるのは {} の中だけで、{ と } 自
体の行は変更されません。">a{" なら {} も含まれます。次の例では、カーソルは
"printf" の上にあります:

	original text		after ">i{"		after ">a{"

	if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~

==============================================================================
*30.5*	タブとスペース

☆タブ導入の背景の簡単な歴史

(Vim の祖先である) `vi` は Bill Joy によって開発されました。当時、彼はメモリと
I/O 操作能力が限られた PDP-11 を使用していました。当時は、次のようなトリックを
使ってソースコードのサイズを最適化するのが一般的でした。
  ASCII テーブルは、もともとテレプリンターを遠隔制御するために設計されました。
制御文字 9 (水平タブ、キャレット表記: ^I) をテレプリンターに送信すると、キャ
リッジは次のタブストップに移動します。タブストップが 8 桁 (一般的な標準) で区
切られていると仮定すると、1 つの制御文字で最大 8 つのスペース文字と同じ視覚効
果を生み出すことができます。例えば、次の 2 行は同じように表示されます >

	1234^I9
	1234    9
<
<Tab> キーを使用する方が、<Space> キーを複数回入力するよりも高速でした。<BS>
キーの場合も同様です。


☆タブとインデントの問題

Vim では、2 つの (仮想的な) 水平タブストップ間の列数は 'tabstop' で制御され、
デフォルトでは 8 に設定されています。この値は変更できますが、後ですぐに問題に
遭遇します。他のプログラムは、あなたが設定したタブストップ値を認識できないから
です。おそらくデフォルト値の 8 が使用されるため、テキストの見た目が突然大きく
変わってしまいます。また、ほとんどのプリンタは固定のタブストップ値 8 を使用し
ます。したがって、'tabstop' はそのままにしておくのが最善です。異なるタブストッ
プ設定で作成されたファイルを編集する場合は、|25.3| を参照して修正してください。
   プログラム内の行をインデントする場合、8 桁の倍数を使用するとすぐにウィンド
ウの右端にぶつかってしまいます。スペース 1 つでは見た目の違いが十分に出ません。
多くの人は、妥協案として 4 桁のスペースを使うことを好みます。
   行の先頭のタブ文字は視覚的に 8 つのスペースとして表され、4 つのスペースのイ
ンデントを使用したいので、タブ文字を使用してインデントを作成することはできませ
ん。
  これを改善するために、`vi` には 'shiftwidth' オプションがありました。これを
4 に設定すると、挿入モードで新しい行に <C-t> を押すと行が 4 スペース分インデン
トされます。これは、<Tab> キーと 'tabstop' を 8 に設定しただけでは実現できない
結果です。
 スペースを最適化するために、`vi` は暗黙的にスペースの塊を削除し、タブ文字に置
き換えます。以下は、<C-t> を数回押したときに何が起こるかを示しています。
  "." はスペース文字を表し、"------->" はタブ文字を表します。

	入力				結果 ~
	<C-t>				....
	<C-t><C-t>			------->
	<C-t><C-t><C-t>			------->....

  同様に、挿入モードで <C-d> を押すとインデントが減ります。したがって、
`set tabstop=8 shiftwidth=2` とすると、以下のようになります

	入力				結果 ~
	<C-t><Tab><C-t>			..----->..
	<C-t><Tab><C-t><C-d>		------->

  `vi` で設定できる 3 つ目のオプションは 'autoindent' です。これは前の行のイン
デントレベルをコピーします

	入力				結果 ~
	<Space><Tab>hello		.------>hello
	<Space><Tab>hello<Enter>	.------>hello
					------->

ただし、新しい行は、使用される文字数を最適化することによって生成されます。


☆スペースだけ

しかし、タブストップを 8 桁で区切るという方法は普遍的ではありませんでした。IBM
では 10 桁が標準であり、今日では Go 開発者の中には `tabstop=4` でコードを記述
する人もいます。テキストが毎回異なる 'tabstop' 値で表示されると、特にファイル
を共有して別のマシンで開いた場合、テキストの位置がずれる危険性があります。
  その間にコンピュータの性能は飛躍的に向上し、タブ文字の使用によって節約された
数オクテットはもはや実質的な効果を持たなくなっていました。スペースのみを使用す
ることで、どこでも同じ結果のテキストを保証できるようになりました。しかし、`vi`
では機能を犠牲にすることなくスペースのみを使用することは不可能でし
た。'autoindent' は、可能な場合はタブ文字を体系的に入力しようとしていたことを
思い出してください。
  Vim 4.0 では、'expandtab' オプションが導入され、スペースのみの操作がタブのみ
(またはタブとスペースの混合) の操作と同じくらい便利になりました。このオプショ
ンを有効にすると、Vim は通常挿入する水平タブ文字を同数のスペースに置き換え、視
覚効果を同じにします。<BS> は、これまでと同様に一度に 1 文字のみを削除します。

	入力				結果 ~
	<Tab>				........
	<Tab><BS>			.......


☆タブをスペースに変換 (およびその逆)

'expandtab' を設定しても、既存のタブ文字にはすぐには影響しません。ファイル内の
水平タブ文字をすべて削除するには、Vim 5.3 で |:retab| コマンドが導入されまし
た。以下のコマンドを使用してください: >

	:set expandtab
	:retab

これは少し危険です。文字列内のタブも変更されてしまう可能性があるからです。その
ようなタブが存在するかどうかを確認するには、次のようにします: >

	/"[^"\t]*\t[^"]*"

文字列内でタブ文字そのものを使用することは推奨されません。問題を回避するには、
タブ文字を "\t" に置き換えてください。

  逆の場合も同様に機能します: >

	:set noexpandtab
	:retab!


☆ソフトタブストップ

スペースだけを使用する場合、またはスペースと水平タブを組み合わせて使用する場
合、タブ文字だけを使用する場合のように、<Tab> キーと<BS> キーが対称的に動作し
ないという不快な感覚を覚えます。
  Vim 5.4 では 'softtabstop' オプションが導入されました。テキスト内の水平タブ
文字を表示するために使われる (ハード) タブストップに加え、Vim はカーソル専用の
ソフトタブストップを追加します。'softtabstop' が正の値に設定されている場合、
<Tab> キーを押すとカーソルが次のソフトタブストップに移動します。Vim はタブ文字
とスペースの適切な組み合わせを挿入し、視覚的な効果を実現します。同様に <BS>
キーを押すと、カーソルは最も近いソフトタブストップに到達しようとします。以下の
例では、`:set softtabstop=4` を使用しています。

	入力			結果 ~
	<Tab>			....
	<Tab><Tab>a		------->a
	<Tab><Tab>a<Tab>	------->a...
	<Tab><Tab>a<Tab><BS>	------->a

  全体的な一貫性を維持するために、`:set softtabstop=-1` を設定し
て、'shiftwidth' の値を 2 つのソフトタブストップ間の桁数として使用するようにす
ることができます。

  'shiftwidth' と 'softtabstop' に異なる値を設定したい場合でも、'shiftwidth'
でインデントするには <C-t> を使用できます。または、'smarttab' オプションを使用
して、さまざまな状況で何を行うかを認識する統合された <Tab> キーを有効にするこ
ともできます。


☆可変タブストップ

前述の通り、ASCII テーブルはテレプリンターを遠隔制御するために設計されました。
特定のテレプリンターでは、物理的なタブストップの間隔を可変に設定できます。結局
のところ、制御文字 ^I は次のタブストップがどこであっても次のタブストップへ移動
するという指示を出すだけだったのです。
  Vim 7.3 では、同じ機能をエミュレートする 'vartabstop' が導入されました。例え
ば、Vim を `+vartabs` でコンパイルし、`:set vartabstop=2,4` とすると、以下のよ
うになります

	実際の文字		結果 ~
	^I			->
	^I^I			->--->
	^I^I^I			->--->--->

  同様に、可変間隔のソフトタブストップを設定するための 'varsofttabstop' も導入
されました。`:set varsofttabstop=2,4` とすると、以下のようになります。

	入力			  結果 ~
	<Tab>			  ..
	<Tab><Tab>		  ......
	<Tab><Tab><Tab>		  ------->....


☆構成例

デフォルトでは、Vim はタブのみを使用するように設定されています: >

	:set tabstop=8
	:set shiftwidth=8
	:set noexpandtab
	:set softtabstop=0
	:set nosmarttab
<
  C コードを Python のように記述したい場合 (スペースのみ、インデントは 4 スペー
ス)、以下のように記述します: >

	:set shiftwidth=4
	:set softtabstop=-1
	:set expandtab
<
  同じ動作をしたいが、配置をより適切に制御したい場合 (例えば、パラメータまたは
コメントを 2 の倍数のスペースで整列させる) は、以下のようにします: >

	:set shiftwidth=4
	:set softtabstop=2
	:set expandtab
	:set smarttab
<
  代わりに、Bram Moolenaar のような C コード (タブとスペースの組み合わせを使用)
を記述したい場合は、以下のようにします >

	:set shiftwidth=4
	:set softtabstop=-1
<

==============================================================================
*30.6*	コメントの整形

Vim のすばらしいところはコメントを解釈できるところです。コメントの整形を指示す
るだけで適切に処理してくれます。
例えば、次のようなコメントがあるとします:

	/* ~
	 * This is a test ~
	 * of the text formatting. ~
	 */ ~

最初の行に移動して次のコマンドを実行すると、コメントを整形できます: >

	gq]/

"gq" はテキスト整形のためのオペレータです。"]/" はコメントの末尾に移動するコマ
ンドです。次のような結果になります:

	/* ~
	 * This is a test of the text formatting. ~
	 */ ~

各行の行頭が適切に処理されていますね。
ビジュアルモードでテキストを選択してから "gq" を使う方法でも構いません。

新しい行を追加したい場合は、真ん中の行に移動して "o" を押します。次のような結
果になります:

	/* ~
	 * This is a test of the text formatting. ~
	 * ~
	 */ ~

行頭のスペースと * は自動的に挿入されるので、そのままコメントを入力することが
できます。テキストが 'textwidth' より長くなると自動的に改行されます。そのとき
も、行頭の * は自動的に挿入されます:

	/* ~
	 * This is a test of the text formatting. ~
	 * Typing a lot of text here will make Vim ~
	 * break ~
	 */ ~

この機能を使うには 'formatoptions' の設定が必要です:

	r	挿入モードで <Enter> を押したときに * を挿入する
	o	ノーマルモードで "o" または "O" を使ったときに * を挿入する
	c	コメントを 'textwidth' の幅で改行する

詳しくは |fo-table| 参照。


☆コメントの定義

コメントの書式は 'comments' オプションで設定します。一行コメントと三部コメント
(開始、中間、終端からなるコメント) は分けて処理されます。
ほとんどの一行コメントは特定の文字で始まります。C++ は //、メイクファイルは #、
Vim は " です。例えば、C++ のコメントなら次のように設定します: >

	:set comments=://

コロンはフラグとコメント文字の区切りです。'comments' の設定は次のような形式で
指定します:

	{flags}:{text}

この例のように、{flags} は空でも構いません。
複数のアイテムを指定するときはコンマで区切ります。アイテムを複数指定できるの
で、同じファイルの中でいろんな種類のコメントを使うことができます。例えばメール
を返信するときに、相手のメッセージに ">" や "!" を付けて引用する場合は、次のよ
うに設定します: >

	:set comments=n:>,n:!

二つのアイテムが設定されました。一つは ">" で開始するコメント、もう一つは "!"
で開始するコメントです。"n" フラグが使われているので、コメントを入れ子にできま
す。つまり、">" で開始する行は、">" の後ろに他のコメントを含んでいても構いませ
ん。この設定により、次のようなメッセージを整形することができます:

	> ! Did you see that site? ~
	> ! It looks really great. ~
	> I don't like it.  The ~
	> colors are terrible. ~
	What is the URL of that ~
	site? ~

'textwidth' の設定を変更して (例えば 80 にして)、テキストを整形してみましょ
う。ビジュアルモードでテキストを選択してから "gq" を押します:

	> ! Did you see that site? It looks really great. ~
	> I don't like it.  The colors are terrible. ~
	What is the URL of that site? ~

違う種類のコメントテキストは混ざっていませんね。
二行目の "I" は一行目の末尾に入れることも可能ですが、しかし、一行目は "> !" で
始まり、二行目は ">" で始まっているため、それらのコメントは別のものであると判
断されます。


☆三部コメント

C のコメントは "/*" で始まり、中間には "*" が付き、"*/" で終わります。このよう
なコメントは次のように設定します: >

	:set comments=s1:/*,mb:*,ex:*/

開始部分は "s1:/*" です。"s" は三部コメントの開始を示します。フラグとコメント
文字 "/*" をコロンで区切っています。フラグには "1" が指定されていますが、これ
により中間部分がスペース一個分、字下げされます。
中間部分は "mb:*" です。"m" は三部コメントの中間を示します。"b" フラグは、コメ
ント文字の後ろに空白が必要であることを示します。これを指定しないと、"*pointer"
などもコメントとして認識されてしまいます。
終端部分は "ex:*/" です。"e" は三部コメントの終端を示します。"x" は特殊なフラ
グです。中間の * が自動的に挿入された直後に "/" を押すと、余計なスペースが削除
されます。

詳細は |format-comments| を参照してください。

==============================================================================

次章: |usr_31.txt|  GUI を活用する

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
