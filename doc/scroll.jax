*scroll.txt*    For Vim バージョン 9.1.  Last change: 2024 Jul 06


		  VIM リファレンスマニュアル    by Bram Moolenaar


スクロール						*scrolling*

これらのコマンドはウィンドウの内容を移動する。カーソルがウィンドウの外に移動し
ようとすると、カーソルはウィンドウに留まるように振舞う ('scrolloff' のスクリー
ン行をカーソルの周囲に確保する)。1ページとはウィンドウの行数から2引いた行数と
定義する。これらのコマンドを覚えるのは少し厄介かもしれない。ウィンドウをバッ
ファのうち貴方が見ている一部分と捉えて、ウィンドウの動きをバッファ内での上下の
移動に関連付けてコマンドを覚えると良いだろう。例えばバッファの中でウィンドウが
上に動くと、ウィンドウのテキストはスクリーンの下の方へ移動していくことになる。

手始めにユーザーマニュアルの|03.7|を読むこと。

1. 下方スクロール		|scroll-down|
2. 上方スクロール		|scroll-up|
3. カーソル相関スクロール	|scroll-cursor|
4. 水平スクロール		|scroll-horizontal|
5. 同期スクロール		|scroll-binding|
6. マウスホイールスクロール	|scroll-mouse-wheel|

==============================================================================
1. 下方スクロール					*scroll-down*

以下のコマンドは編集ウィンドウ(バッファ内の貴方が見ている一部分)を下に移動する
(つまりテキストバッファのより下にある行を見ることができる):

							*CTRL-E*
CTRL-E			バッファの下へ[count]行ウィンドウをスクロールする。
			テキストはスクリーン上で上方に移動する。
			覚え方: Extra lines {訳注: Extra=割増}

							*CTRL-D*
CTRL-D			ウィンドウをバッファ内で下にスクロールする。スクロール
			する行数は 'scroll' オプションで指定される(省略した場
			合: スクリーンの半分の行数)。[count]が指定された場合、
			'scroll' オプションに[count]が設定されてからスクロール
			する。カーソルもファイル内で同じ行数だけ下へ移動する
			(もし可能ならば; 行が折り返されている場合やファイルの
			終端に達した時は違ってくる)。カーソルがバッファの最終
			行にある時は何も起こらずビープ音が鳴る。'startofline'
			オプションも参照。

<S-Down>	or				*<S-Down>* *<kPageDown>*
<PageDown>	or				*<PageDown>* *CTRL-F*
<S-CR>	or					*<S-CR>* *<S-NL>*
<S-+>	or					*SHIFT-+* *<S-Plus>*
CTRL-F			ウィンドウをバッファ内で[count]ページ前方(下方)にスク
			ロールする。'startofline' オプションも参照。
			ウィンドウが1つだけのときはオプション 'window' の値が
			使われる。

							*z+*
z+			[count]が無い時: 現在のウィンドウの最下行を最上行にし
			て再描画する。カーソルはその行の、最初の非空白文字に合
			わせられる。
			[count]が有る時: ちょうど "z<CR>" と同じ。

==============================================================================
2. 上方スクロール					*scroll-up*

以下のコマンドは編集ウィンドウ(バッファ内の貴方が見ている一部分)を上に移動する
(つまりテキストバッファのより上にある行を見ることができる):

							*CTRL-Y*
CTRL-Y			バッファの上へ[count]行ウィンドウをスクロールする。
			テキストはスクリーン上で下方に移動する。
			Note: MS-Windowsのキーバインディングを使っているときは
			CTRL-Yはredoにマッピングされている。

							*CTRL-U*
CTRL-U			ウィンドウをバッファ内で上にスクロールする。スクロール
			する行数は 'scroll' オプションで指定される(省略した場
			合: スクリーンの半分の行数)。[count]が指定された場合、
			'scroll' オプションに[count]が設定されてからスクロール
			する。カーソルもファイル内で同じ行数だけ上へ移動する
			(もし可能ならば; 行が折り返されている場合やファイルの
			先頭に達した時は違ってくる)。カーソルがバッファの先頭
			行にある時は何も起こらずビープ音が鳴る。
			'startofline' オプションも参照。

<S-Up>		or					*<S-Up>* *<kPageUp>*
<PageUp>	or					*<PageUp>* *CTRL-B*
<S-->		or				*<S-Minus>* *SHIFT-MINUS*
CTRL-B			ウィンドウをバッファ内で[count]ページ後方(上方)にスク
			ロールする。'startofline' オプションも参照。
			ウィンドウが1つだけのときはオプション 'window' の値が
			使われる。

							*z^*
z^			[count]が無い時: 現在のウィンドウの最上行を最下行にし
			て再描画する。カーソルはその行の、最初の非空白文字に合
			わせられる。
			[count]が有る時: まず[count]行がウィンドウの最下行に
			なるようにスクロールし、次にウィンドウの最上行になっ
			た行を最下行にして再描画する。カーソルはその行の最初
			の非空白文字に合わせられる。

==============================================================================
3. カーソル相関スクロール				*scroll-cursor*

下記のコマンドはカーソルの位置は変えずに編集ウィンドウ(バッファの見えている一
部)の位置を変える。'scrolloff' オプションを設定していると、カーソルの上または
下の周辺行が表示されることに注意。

							*z<CR>*
z<CR>			[count]行(省略時はカーソルのある行)をウィンドウの最上
			行にして再描画する。カーソルは行内の最初の非空白文字に
			置かれる。

							*zt*
zt			"z<CR>" と同様だが、カーソルは同じカラムに留める。

							*zN<CR>*
z{height}<CR>		ウィンドウを高さ{height}行に変更して再描画する。スク
			リーンの更新が非常に遅い時に、高さを減らすと有効であ
			る。物理的なスクリーンの高さよりも高くすることはできな
			い。

							*z.*
z.			[count]行(省略時はカーソルのある行)をウィンドウの中心
			にして再描画する。カーソルは行内の最初の非空白文字に置
			かれる。

							*zz*
zz			"z." と同様だが、カーソルは同じカラムに留める。注意:
			caps-lockが有効になっていると、このコマンドは "ZZ" に
			なり、バッファを書き出し終了してしまう。

							*z-*
z-			[count]行(省略時はカーソルのある行)をウィンドウの最下
			行にして再描画する。カーソルは行内の最初の非空白文字に
			置かれる。

							*zb*
zb			"z-" と同様だが、カーソルは同じカラムに留める。

==============================================================================
4. 水平スクロール					*scroll-horizontal*

次の4つのコマンドはスクリーンに応じてカーソルが移動する。カーソルのある文字が
スクリーンが動いたために消えると、カーソルはスクリーン上の一番近い文字に移動す
る。'sidescroll' の値は使用されない。

z<Right>    or						*zl* *z<Right>*
zl			スクリーンを[count]文字右へ移動する。従ってテキストは
			[count]文字左へスクロールする。これは 'wrap' がオフの
			時にだけ働く。

z<Left>      or						*zh* *z<Left>*
zh			スクリーンを[count]文字左へ移動する。従ってテキストは
			[count]文字右へスクロールする。これは 'wrap' がオフの
			時にだけ働く。

							*zL*
zL			スクリーンの幅の半分右へスクロールする。従ってテキスト
			はスクリーンの幅の半分左へスクロールする。これは 'wrap'
			がオフの時にだけ働く。

							*zH*
zH			スクリーンの幅の半分左へスクロールする。従ってテキスト
			はスクリーンの幅の半分右へスクロールする。これは 'wrap'
			がオフの時にだけ働く。

次の2つのコマンドではテキスト上でカーソルは移動せず、スクリーンのテキストだけ
がスクロールする。

							*zs*
zs			カーソルのある位置がスクリーンの始まり(左側)に来るよう
			にテキストを水平にスクロールする。これは 'wrap' がオフ
			の時にだけ働く。

							*ze*
ze			カーソルのある位置がスクリーンの終わり(右側)に来るよう
			にテキストを水平にスクロールする。これは 'wrap' がオフ
			の時にだけ働く。

==============================================================================
5. 同期スクロール					*scroll-binding*

時折、2つかそれ以上のウィンドウを結びつけて、1つがスクロールしたら他のウィンド
ウもスクロールして欲しいと思うことがある。Vimではウィンドウごとに 'scrollbind'
オプションを設定することでこのような振る舞いをさせることが可能である。
'scrollbind' が設定されたあるウィンドウがスクロールした場合、他の 'scrollbind'
が設定されたウィンドウが可能なら同じ量だけスクロールする。'scrollbind' の振る
舞いは 'scrollopt' オプションによって変更することができる。

スクロールバーやマウスホイールを使っているとき、マウスでスクロールバーを操作し
ても他のウィンドウはスクロールされない。これは少しの間だけ同期スクロールを使わ
ないでスクロールしたい時に使える。

ウィンドウに 'diff' オプションも設定されているとき、同期スクロールは位置を正確
に同期するために二つのバッファの差分を利用する。それ以外の場合は以下の方法が使
われる。

							*scrollbind-relative*
'scrollbind' された各々のウィンドウは "相対的なオフセット" --すなわち、現在の
ウィンドウの垂直スクロール位置とその他のウィンドウの垂直スクロール位置の間の差
分と考えることができる--を追跡する。'scrollbind' ウィンドウの1つがテキストの最
初もしくは最後を超えてスクロールしようとすると、そのウィンドウはそれ以上スク
ロールはしないが、どれだけ限界を超えて移動しようとしたかは記憶される。そのウィ
ンドウは同じ相対オフセットを維持するために、そのバッファの限界を超えてスクロー
ルを要求されたかにかかわらず、この情報を保持し続ける。

しかしながら、そのバッファの限界を超えるような相対オフセットを持つウィンドウに
カーソルフォーカスが与えられると、その他の 'scrollbind' されたウィンドウは現在
のウィンドウの有効な相対オフセットの位置にジャンプすることになる。この振る舞い
は 'scrollopt' オプションから "jump" フラグを削除することで変えることができる。

						*syncbind* *:syncbind* *:sync*
:syncbind		すべての 'scrollbind' ウィンドウが同じ相対オフセットを
			持つように強制する。すなわち 'scrollbind' ウィンドウが
			そのバッファの先頭にスクロールされた時、その他の
			'scrollbind' ウィンドウもまたそれぞれのバッファの先
			頭に持っていかれる。

							*scrollbind-quickadj*
'scrollbind' フラグは、キーボードコマンドを使ってウィンドウを垂直スクロールす
る時に意味を持ち、カーソルがフォーカスされているウィンドウで垂直スクロールバー
やマウスホイールを使う時にも意味を持つ。しかし、カーソルにフォーカスのないウィ
ンドウで垂直スクロールバーやマウスホイールを使う場合は、'scrollbind' は無視さ
れる。
これにより、'scrollbind' されたウィンドウの相対オフセットを素早く調整できる。

==============================================================================
6. マウスホイールスクロール				*scroll-mouse-wheel*

マウスにスクロールホイールがあるときは、GUI の Vim でそれを使うことができる。
どのように動作するかはシステムに依存する。ホイールは xterm でも動作する
|xterm-mouse-wheel|。デフォルトでは垂直スクロールホイールのみサポートされてい
る。いくつかの GUI では水平スクロールホイールもサポートされている。

MS-Windowsにおいて、スクロールの動作が入力フォーカスの問題を引き起こす場合は、
|intellimouse-wheel-problems| を参照。

Win32 および X11 GUI (Motif、GTK) ではホイールを回すと <ScrollWheelUp>、
<ScrollWheelDown>、<ScrollWheelLeft>、<ScrollWheelRight> などのキー入力が発生
する。例えば、スクロールホイールを上に回すと <ScrollWheelUp> キーが生成され、
ウィンドウが上にスクロールする (つまりテキストが下に移動する)。これらのキーの
デフォルトの動作は次の通り:
    <ScrollWheelUp>	    N 行上にスクロール		*<ScrollWheelUp>*
    <S-ScrollWheelUp>	    1 画面上にスクロール	*<S-ScrollWheelUp>*
    <C-ScrollWheelUp>	    1 画面上にスクロール	*<C-ScrollWheelUp>*
    <ScrollWheelDown>	    N 行下にスクロール		*<ScrollWheelDown>*
    <S-ScrollWheelDown>	    1 画面下にスクロール	*<S-ScrollWheelDown>*
    <C-ScrollWheelDown>	    1 画面下にスクロール	*<C-ScrollWheelDown>*
    <ScrollWheelLeft>	    N 列左にスクロール		*<ScrollWheelLeft>*
    <S-ScrollWheelLeft>	    1 画面左にスクロール	*<S-ScrollWheelLeft>*
    <C-ScrollWheelLeft>	    1 画面左にスクロール	*<C-ScrollWheelLeft>*
    <ScrollWheelRight>	    N 列右にスクロール		*<ScrollWheelRight>*
    <S-ScrollWheelRight>    1 画面右にスクロール	*<S-ScrollWheelRight>*
    <C-ScrollWheelRight>    1 画面右にスクロール	*<C-ScrollWheelRight>*
これはコマンドラインを編集する以外の、全てのモードで動作するだろう。

値のNはシステムに依存する。デフォルトのVimのスクロールは垂直な移動では3行、水
平な移動では6桁になる。MS-Windows では、各スクロールアクションでの行と桁の量は
システムの全体設定から取得する。

Note: 水平スクロールは 'nowrap' が設定されているときのみ機能する。また、
'guioptions' の "h" フラグが設定されていない場合は、スクロールするとカーソル行
が画面外になってしまうようなときに、表示されている範囲の一番長い行にカーソルが
移動する (水平スクロールバーの動作に似た感じ)。

キーマッピングによりデフォルトの振る舞いを変更することができる。例えば、ノーマ
ルモードでホイールによるスクロールを1行にしたり半画面にしたりできる: >
    map <MouseDown> <C-Y>
    map <S-MouseDown> <C-U>
    map <MouseUp> <C-E>
    map <S-MouseUp> <C-D>
AltやCtrlといった修飾も可能である。

これはもちろん、Vimがスクロールホイールのイベントを取得している時にだけ働く。
この機能が働くかどうかは "xev" プログラムを使用すればチェックできる。
							*mouse-scrolling-off*
マウスでスクロールさせたくない場合(例えば、手のひらをタッチパッドに置くとス
クロールイベントが発生するため)、次のようにして無効にできる: >
	:map <ScrollWheelDown> <Nop>
	:map! <ScrollWheelDown> <Nop>
	:map <ScrollWheelUp> <Nop>
	:map! <ScrollWheelUp> <Nop>
	:map <ScrollWheelLeft> <Nop>
	:map! <ScrollWheelLeft> <Nop>
	:map <ScrollWheelRight> <Nop>
	:map! <ScrollWheelRight> <Nop>

XFree86を使っているときには、/etc/XF86Configに貴方のマウスの正しいエントリがな
ければならない。FreeBSDでは、このようなエントリがロジテックのスクロールマウス
用に必要である。 >
    Protocol     "MouseMan"
    Device       "/dev/psm0"
    ZAxisMapping 4 5
詳しくはXFree86のドキュメントを参照すること。

						*<MouseDown>* *<MouseUp>*
<MouseDown> と <MouseUp> は廃止された。<MouseDown> の代わりに <ScrollWheelUp>
を、<MouseUp> の代わりに <ScrollWheelDown> を使うこと。

							*xterm-mouse-wheel*
新しいxtermでマウスホイールを使うには、上で書かれているようにXserverでスクロー
ルホイールマウスが動作するようにするだけで良い。

古いxtermでマウスホイールを使うにはこうする:
1. 上に書かれているように、Xserverで使えるようにする。
2. xtermに変換を追加し、スクロールイベントをVimへエスケープシーケンスとして渡
   すようにする。
3. Vimにマッピングを追加し、エスケープシーケンスを <ScrollWheelDown> もしくは
   <ScrollWheelUp> キーとして解釈できるようにする。

次のような内容をあなたの~/.Xdefaults(もしくは別名の貴方のXリソースファイル)に
追加すれば変換ができる。 >

  XTerm*VT100.Translations:		#override \n\
		s<Btn4Down>: string("0x9b") string("[64~") \n\
		s<Btn5Down>: string("0x9b") string("[65~") \n\
		<Btn4Down>: string("0x9b") string("[62~") \n\
		<Btn5Down>: string("0x9b") string("[63~") \n\
		<Btn4Up>: \n\
		<Btn5Up>: 

以下のマッピングを vimrc ファイルに追加すること: >
	:map <M-Esc>[62~ <ScrollWheelUp>
	:map! <M-Esc>[62~ <ScrollWheelUp>
	:map <M-Esc>[63~ <ScrollWheelDown>
	:map! <M-Esc>[63~ <ScrollWheelDown>
	:map <M-Esc>[64~ <S-ScrollWheelUp>
	:map! <M-Esc>[64~ <S-ScrollWheelUp>
	:map <M-Esc>[65~ <S-ScrollWheelDown>
	:map! <M-Esc>[65~ <S-ScrollWheelDown>
<
 vim:tw=78:ts=8:noet:ft=help:norl:
