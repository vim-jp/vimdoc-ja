*terminal.txt*	For Vim バージョン 8.0.  Last change: 2017 Sep 14


		VIMリファレンスマニュアル    by Bram Moolenaar


端末ウィンドウサポート					*terminal*


WARNING: THIS IS ONLY PARTLY IMPLEMENTED, ANYTHING CAN STILL CHANGE

端末機能はオプションなので、あなたのVimが対応しているかは次のコマンドを使って
確認できます: >
	echo has('terminal')
結果が "1" ならば対応しています。


1. 基本的な使い方		|terminal-use|
2. リモートテスト		|terminal-testing|
3. デバッグ			|terminal-debug|

{Vi にはこれらのコマンドはありません}
{only: |+terminal| の機能は、コンパイル時に有効にされていなければ使えません}

端末機能を使うには |+multi_byte|, |+job| そして |+channel| 機能が必要です。

==============================================================================
1. 基本的な使い方					*terminal-use*

これは Vim のウィンドウ内で端末エミュレーターを実行する機能です。端末エミュ
レーターに接続すると1つのジョブが開始されます。例としてシェルを実行するならば
以下のようになります: >
     :term bash

またビルドコマンドを実行するにはこうなります: >
     :term make myprogram

ジョブはVimとは非同期的に動作し、他のウィンドウで編集中であってもジョブからの
出力は随時端末ウィンドウに反映されます。


キー入力 ~
							*terminal-typing*
端末ウィンドウにキーボードのフォーカスがある時には、入力したキーはジョブに送ら
れます。これには可能ならば pty を使用します。端末ウィンドウ外をクリックすれ
ば、キーボードフォーカスを外に動かせます。

ウィンドウや他の CTRL-W コマンドを操作するために CTRL-W を使えます。例えば:
	CTRL-W CTRL-W 	次のウィンドウにフォーカスを移動する
	CTRL-W :	Exコマンドに入る
他のコマンドについては |CTRL-W| 参照してください。


端末ウィンドウでの特別な操作:			*CTRL-W_.*  *CTRL-W_N* 
	CTRL-W .	端末内のジョブに CTRL-W を送る
	CTRL-W N	Terminal-Normal モードに移行, |Terminal-mode| を参照
	CTRL-\ CTRL-N   Terminal-Normal モードに移行, |Terminal-mode| を参照
	CTRL-W " {reg}  レジスタ {reg} の内容を貼り付け	*CTRL-W_quote*
			式の評価結果を挿入するためのレジスタ = も機能する。
	CTRL-W CTRL-C	ジョブを停止する, 下記の |t_CTRL-W_CTRL-C| を参照

CTRL-W の代わりに別のキーを使うにはオプション 'termkey' を参照してください。し
かし 'termkey' を2回タイプすると 'termkey' が job へ送信されます。例:
	'termkey' CTRL-W    次のウィンドウにフォーカスを移動する
	'termkey' :	    Exコマンドに入る
	'termkey' 'termkey' 端末内のジョブに 'termkey' を送信する
	'termkey' .	    端末内のジョブに CTRL-W を送信する
	'termkey' N  	    Terminal-Normal モードへ移行、以下を参照
	'termkey' CTRL-N    CTRL-W N と同じ
	'termkey' CTRL-C    |t_CTRL-W_CTRL-C| と同じ
							*t_CTRL-\_CTRL-N*
他のモードと同じように、ノーマルモードへ移行するための特別なキーの組み合わせで
ある CTRL-\ CTRL-N が利用できます。
							*t_CTRL-W_CTRL-C*
ジョブを強制停止するのに CTRL-W CTRL-C を使えます。MS-Windowsでは CTRL-BREAK
でも同様にジョブを停止できます。

CTRL-C を入力した場合、その効果は pty がどのように構成されているかに従います。
シンプルなコマンドにおいては SIGINT がジョブに送られ、結果的にジョブが停止する
でしょう。中には SIGINT を無視するコマンドもあるでしょうし、また (Vim がそうし
ているように) CTRL-C をプログラム自身で取り扱うものもあるでしょう。

入力したキーを別のものに読み返させるには端末モードマッピング、詳細は |:tmap|を
使用してください。これはどのようなマッピングでも定義できますが、端末内で実行さ
れているジョブに送信されるキー入力にのみ作用します。


サイズと色 ~

端末ウィンドウのサイズを制御するにはオプション 'termsize' を参照してください。
(TODO: 端末がウィンドウよりも大きい場合にはスクロールすることを記述する)

端末内のジョブは端末の色を変更できます。デフォルトの前景色及び背景色はVimの
Normal ハイライトグループにより決定されます。

カラー端末を開始する際に、背景に白と黒どちらの系統の色を使用するかは、オプショ
ン 'background' を用いて決定します。

異なる色を使う場合には Terminal ハイライトグループを利用できます: >
    hi Terminal ctermbg=lightgrey ctermfg=blue guibg=lightgrey guifg=blue


文法 ~

:[range]ter[minal] [options] [command]			*:ter* *:terminal*
			新しい端末ウィンドウを開きます。

			[command] が指定された場合、それをジョブとして実行し、
			端末の入出力を接続します。
			[command] が指定されなかった場合、オプション 'shell'
			を使用します。
			[command] が NONE の場合ジョブは開始されず、端末の pty
			は gdb のようなコマンドによって利用できます。

			新しいバッファが作られ、 [command] もしくは 'shell' に
			"!" が前置された名前が与えられます。すでに同じ名前の
			バッファが存在する場合には、カッコに囲まれた番号が付与
			されます。例えば "gdb" が存在して2つ目の端末には "!gdb
			(1)" という名前が使われます。

			[range] が与えられた場合は、指定された範囲の行がジョブ
			の入力として使われます。その際の端末ウィンドウではキー
			入力ができなくなります。MS-Windows においては以下の
			++eof オプションも参照してください。

			コンマで分けられた2つの数字は "行数,桁数" のように利用
			されます。例えば `:24,80gdb` は 24 行かつ 80 桁の端末
			を開きます。しかし端末ウィンドウが Vim のウィンドウを
			またがる場合には、垂直分割は起こさずに Vim のウィンド
			ウの幅を利用します。
						*term++close* *term++open*
			サポートされる [options] は以下の通り:
			++close		ジョブが終了した際には自動的に端末ウィ
					ンドウを閉じる。
			++open		ジョブが終了した際にウィンドウが表示さ
					れていない場合に、ウィンドウを表示す
					る。割り込み的に発生しうることに留意。
			++curwin	現在のウィンドウで端末を開き、現在の
					ウィンドウを分割しない。現在のバッファ
					を放棄( |abandon| )できない場合は失敗
					する。
			++hidden	端末を隠しバッファとして開く。ウィンド
					ウは使用されない。
			++rows={height} 端末ウィンドウの高さとして {height} を
					使う
			++cols={width}  端末ウィンドウの幅として {width} を使
					う
			++eof={text}	[range] を使った場合: 最後の行を送信し
					たあとに指定したテキストが送られる。空
					白を含むことはできない。 CR が 1 つ付
					け加えられる。MS-Windows ではデフォル
					トでは CTRL-D が送られる。
					例: シェルには "++eof=exit" を、Python
					には "++eof=exit()" を指定する。特殊
					コードが `:map` と同様に利用できる。
					例: "<C-Z>" は CTRL-Z を示す。


			より詳細なオプションを使いたいならば |term_start()| 関
			数を使ってください。

端末に関連付けられたバッファがアンロードもしくは削除された場合には、
`job_stop(job, "kill")` を呼んだのと同じようにそのジョブが殺されます。

ジョブが実行され続けるとウィンドウはそのバッファが変更されたかのように振る舞い
ます。 `CTRL-W :quit` でウィンドウを閉じようとしても失敗します。 `CTRL-W :quit!`
を使うとジョブは終了します。ウィンドウのテキストは失われます。バッファは依然存
在しますが、 `:buffer` でウィンドウに割り当てても空のバッファが表示されます。

`CTRL-W :close` で閉じようとしてもまた失敗します。 `CTRL-W :close!` はウィンド
ウを閉じ、バッファを隠し状態にします。

`CTRL-W :hide` を使うとジョブを実行したまま、端末ウィンドウを閉じバッファを隠
し状態にできます。`:buffer` コマンドで現在のウィンドウを端末ウィンドウにするこ
とができます。未保存の変更があった場合にはこれは失敗しますが、通常と同じように
! で強制できます。

バックグラウンドジョブをウィンドウ無しで実行し、終了したらウィンドウに表示する
には、次のようにオプションを指定します: >
	:term ++hidden ++open make
ウィンドウが予期せぬタイミングで開かれ、あなたが行っている操作に割り込む可能性
があることに留意してください。

							*E947* *E948*
ジョブが実行され続けると、バッファが変更されたとみなされ Vim を簡単には終了で
きなくなります。 |abandon| を参照してください。

ジョブが終了しバッファになんの変更も及ぼさなかった場合、そのウィンドウを閉じる
とバッファは削除されます。

端末バッファを変更するにはオプション 'modifiable' をセットする必要があります。
これはジョブが終了した後にのみ行なえます。バッファを最初に変更した瞬間に普通の
バッファになりハイライトは削除されます。バッファを保存可能にするために |:file|
でバッファの名前を、コマンド名から変更することもできます。


サイズ変更 ~

端末のサイズは3つのモードのいずれか1つで決まります:

1. オプション 'termsize' が空の場合: 端末サイズはウィンドウのサイズに従う。最
   小で2行、10桁。

2. オプション 'termsize' が "rows*cols" の場合、 "rows" を最小行数、 "cols" を
   最小桁数とする。

3. オプション 'termsize' が "rowsXcols" ("X" は大文字小文字を問わない) の場合:
   端末サイズは指定された行数と桁数で固定される。もしもウィンドウがそれよりも
   大きい場合には、使用されない空の領域ができる。

ウィンドウサイズが端末サイズよりも小さい場合、端末の一部の領域(左下に相当する
部分)のみが描画されます。

端末の現在のサイズを取得するのに関数 |term_getsize()| が使えます。
|term_setsize()| は 1 か 2 のモードの時にだけ、すなわち 'termsize' が
"rowsXcols" 形式ではない時に使えます。


Terminal-Job と Terminal-Normal モード ~
							*Terminal-mode*
ジョブが実行中には端末の内容はジョブの制御下にあります。それにはカーソルの位置
も含まれます。入力したキーはジョブに送られます。端末の内容はいつでも更新されえ
ます。これを Terminal-Job モードと呼びます。

CTRL-W N (もしくは 'termkey' N) を入力すると Terminal-Normal モードに遷移しま
す。このモードでは端末ウィンドウのコンテンツはVimの制御下に置かれ、ジョブの出
力は一時保留されます。 CTRL-\ CTRL-N でも同じようになります。

|tmap| のマッピングは Terminal-Job モードにおいて作用します。
|term_sendkeys()| で送ったキーには tmap は適用されませんが、
|feedkeys()| で送ったキーには適用されます。

							*E946*
Terminal-Normal モードでは、Vimの普通のコマンドでカーソルを自由に動かせます。
視覚的にテキストをマークしたり、テキストをヤンクしたり思いのままです。しかし
バッファの内容を変更することはできません。 'i' や 'a' など挿入モードを開始する
コマンドを使うと Terminal-Job モードに戻ります。結果としてウィンドウは端末のコ
ンテンツを反映させるために更新されます。

Terminal-Normal モードではステータスラインとウィンドウタイトルには
"(Terminal)" と表示されます。 Terminal-Normal モード中にジョブが終了してしまっ
た場合にはそれが "(Terminal-finished)" に変わります。

Terminal-Job モードから挿入モードに移る方法はありません。


カーソルスタイル ~

デフォルトでは端末ウィンドウのカーソルには点滅しないブロックが使われます。カー
ソルの点滅状態や形を変更するのに、普通の xterm のエスケープシーケンスが使われ
ます。端末ウィンドウからフォーカスが外れる際に Vim は元々のカーソルを復元しま
す。

xterm を "-bc" 引数で起動した場合、または他の方法でカーソルの点滅を発生させた
場合、が1つの例外となります。それらにより点滅フラグが逆転したことが問題の引き
金となります。なぜなら Vim はその逆転を検出できず、端末ウィンドウのカーソルの
点滅も逆転します。


Unix ~

UNIX ではすべての種類のコマンドを実行可能とするために pty を用いています。端末
内で Vim ですら実行できるのです! これは以下のようにデバッグに利用できます。

実行中のジョブに情報を伝えるのに以下の環境変数が利用できます:
    TERM		端末の名前 'term'
    ROWS		端末の初期行数
    LINES		ROWS と同じ
    COLUMNS		端末の初期桁数
    COLORS		色数 't_Co' (GUIでは 256*256*256)
    VIM_SERVERNAME	v:servername

ジョブを開始した Vim インスタンスと通信するのに |client-server| 機能を使えま
す。この方法は v:servername が空ではないときのみ機能します。必要ならば次のよう
にしてそれを設定できます: >
	call remote_startserver('vim-server')

ジョブの中で以下の様なことができます: >
	vim --servername $VIM_SERVERNAME --remote +123 some_file.c
これは "some_file.c" の 123 行目を開かせます。


MS-Windows ~

MS-Windows ではすべての種類のコマンドを実行可能とするために winpty を用いてい
ます。あたりまえのことですが、ここで実行するコマンドは端末の中で動くもので、独
自のウィンドウを開くものであってはいけません。

winpty 内の以下の2つのファイルが必要です:

    winpty.dll
    winpty-agent.exe

これらは以下のページからダウンロードできます:

    https://github.com/rprichard/winpty

ファイルを環境変数 PATH のいずれかに置くだけです。必要ならばオプション
'winptydll' でファイルの場所を指定できます。もしも32ビット版と64ビット版を同じ
ディレクトリに置きたいのであれば、Vimのビルドに合わせてそれぞれを winpty32.dll
もしくは winpty64.dll という名前に変更してください。

==============================================================================
2. リモートテスト					*terminal-testing*

VimのほとんどのテストはVimのなかでスクリプトを実行しています。テスト対象のコー
ドと干渉してしまうような、幾つかのテストではこれは機能しません。これを避けるた
めに端末ウィンドウ内でさらにVimを実行しています。そのテストではキーストローク
を端末に送信し、その結果として端末画面の状態が変わるのを検査します。

関数 ~

term_sendkeys()		端末にキーストロークを送信する (tmap の影響を受けない)
term_wait()		端末画面が更新されるのを待つ
term_scrape()		端末画面の内容を検査する


==============================================================================
3. デバッグ					*terminal-debug*

Vim のウィンドウでソースコードを表示しながらプログラムを gdb でデバッグするの
に、端末デバッグプラグインが利用できます。これは Vim の中だけで完結するので、
SSH 接続が1つあればリモートで機能します。


はじめに ~

以下のコマンドでプラグインを読み込みます: >
	packadd termdebug
<							*:Termdebug*
デバッグを開始するには `:Termdebug` に続けてコマンド名を入力します。例: >
	:Termdebug vim

これにより2つのウィンドウが開きます:
gdb のウィンドウ
		"gdb vim" を実行した端末ウィンドウ。ここでは直接 gdb とやりと
		りできる。バッファ名は "!gdb"
プログラムのウィンドウ
		実行したプログラムの端末ウィンドウ。 gdb 内で "run" をしてプロ
		グラムの I/O が発生するとこのウィンドウに反映される。その内容
		は gdb の制御下にない。バッファ名は "gdb program"

現在のウィンドウはソースコードを表示するのに使われます。gdb が一時停止した際
に、可能ならばその場所が表示されます。現在の位置を示すためにサインが利用されま
す (ハイライトグループ debugPC を使う)。

現在のウィンドウの内容が変更されると、現在の gdb の位置を表示するために別の
ウィンドウが開きます。

実行中のプログラムを操作するにはその端末にフォーカスを合わせます。以降の操作は
普通の端末ウィンドウと同様です。

デバッガが終了すると、通常は gdb のウィンドウで "quit" とタイプすることで終了
しますが、2つのウィンドウは閉じます。


コードをステップ実行する ~

gdb ウィンドウにフォーカスを移しコマンドを入力します。一般的なものは以下:
- CTRL-C    プログラムを中断する
- next      現在の行を実行し、次の行(の手前)で停止する
- step      現在の行を実行し、次の文(の手前)で停止する。関数の内側に入る
- finish    現在の関数を抜けるまで実行する
- where     スタックを表示する
- frame N   N 番目のスタックフレームに移動する
- continue  実行を再開する

ソースコードを表示しているウィンドウでは gdb を制御するのに幾つかのコマンドが
使えます:
 :Break     現在の行にブレークポイントを設定する。サインが表示される
 :Delete    現在の行のブレークポイントを削除する
 :Step      gdb の "step" コマンドを実行する
 :Over      gdb の "next" コマンドを実行する
            (:Next だと Vim のコマンドとかぶるので)
 :Finish    gdb の "finish" コマンドを実行する
 :Continue  gdb の "continue" コマンドを実行する


変数を検査する ~

 :Evaluate          カーソルの下の式を評価する
 K                  上に同じ
 :Evaluate {expr}   {expr} を評価する
 :'<,'>Evaluate     ビジュアル選択したテキストを評価する
 
これは gdb ウィンドウで "print" コマンドを使ったのに相当します。


その他のコマンド ~

 :Gdb          gdb ウィンドウに移動する
 :Program      デバッグ中のプログラムウィンドウに移動する


通信 ~

Vim が gdb と通信するために他に隠されたバッファを利用します。バッファ名は "gdb
communicate" です。このバッファは消さないでください。消してしまうとデバッガが
動作しなくなってしまうでしょう。


カスタマイズ ~

gdb コマンド以外のデバッガを使うには、 `:Termdebug` を実行する前に
"termdebugger" 変数を変更してください: >
	let termdebugger = "mygdb"
gdb と完全互換のあるデバッガのみが使えます。Vim は gdb の操作に GDB/MI イン
ターフェイスを利用しています。

サインの色は以下のハイライトグループで調整できます:
- debugPC		現在の位置
- debugBreakpoint	ブレークポイント

'background' オプションが "light" の時のデフォルトは以下のとおりです:
  hi debugPC term=reverse ctermbg=lightblue guibg=lightblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red

'background' オプションが "dark" の時は以下のとおりです:
  hi debugPC term=reverse ctermbg=darkblue guibg=darkblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red

デバッグを開始した際に Vim のウィンドウ幅を変更し、垂直分割を利用するには次の
ように設定します: >
  let g:termdebug_wide = 163
これは :Termdebug を実行した際に &columns を 163 に設定します。元の値はデバッ
ガが終了する際に復元されます。



 vim:tw=78:ts=8:ft=help:norl:
