*tagsrch.txt*   For Vim バージョン 9.1.  Last change: 2025 Apr 26


		  VIMリファレンスマニュアル    by Bram Moolenaar


タグと特別な検索					*tags-and-searches*

初めにユーザーマニュアルのセクション|29.1|を参照すること。

1. タグへのジャンプ		|tag-commands|
2. タグスタック			|tag-stack|
3. タグマッチリスト		|tag-matchlist|
4. タグの詳細			|tag-details|
5. タグファイルの書式		|tags-file-format|
6. インクルードファイルの検索	|include-search|
7. 'tagfunc' を使う		|tag-function|

==============================================================================
1. タグへのジャンプ					*tag-commands*

							*tag* *tags*
タグとは "tags" ファイルに現われる識別子である。タグはラベルのようなものであ
り、そこにジャンプすることができる。例えば: Cのプログラムではそれぞれの関数名
をタグとして使うことができる。タグ機能を使う前には、ctagsのようなプログラムに
よって "tags" ファイルを生成しなければならない。

":tag" コマンドはカーソルをタグ上に移動する。CTRL-]コマンドはカーソルの下にあ
るキーワードをタグとして使用する。もしカーソルがキーワード上になければ、カーソ
ル位置から右側で最初に現れるキーワードを使用する。

":tag" コマンドはCプログラムでよく機能する。もし関数呼び出しを見つけた時にその
関数が何をするのか疑問に思ったら、カーソルを関数名の上に置いてCTRL-]を叩けばよ
い。これで関数定義に導いてもらえるだろう。簡単に戻る方法はCTRL-Tコマンドを使う
ことである。後述するタグスタックについても読むとよい。

						*:ta* *:tag* *E426* *E429*
:[count]ta[g][!] {name}
			tagsファイル内の情報を用いて、{name}の定義へジャンプす
			る。{name}はタグスタックに積まれる。[!]については
			|tag-!|を参照。
			{name}は正規表現を使用できる。|tag-regexp|を参照。
			{name}に対してマッチするタグが複数ある場合、[count]番
			目のタグへジャンプする。[count]が指定されないときは最
			初のタグへジャンプする。他のマッチするタグへジャンプす
			るには|tag-matchlist|を参照。

g<LeftMouse>						*g<LeftMouse>*
<C-LeftMouse>					*<C-LeftMouse>* *CTRL-]*
CTRL-]			カーソルの下のキーワードを定義している場所にジャンプす
			る。":tag {name}" と同様であるが、{name}はカーソルの
			下、もしくは次に現われるキーワードである。
			{name}に対してマッチするタグが複数ある場合、[count]番
			目のタグへジャンプする。[count]が指定されないときは最
			初のタグへジャンプする。他のマッチするタグへジャンプす
			るには|tag-matchlist|を参照。

							*v_CTRL-]*
{Visual}CTRL-]		":tag {name}" と同様であるが、{name}はハイライトされて
			いるテキストである。

							*telnet-CTRL-]*
CTRL-]はtelnetの標準エスケープキーである。タグにジャンプしようとCTRL-]を打つと、
代わりにtelnetのプロンプトが立ち上がるだろう。telnetのたいていのバージョンは、
標準エスケープキーを変更、もしくは使用不可能にできる。telnetのマニュアルを参照
すること。エスケープキーを使用不可能にするには 'telnet -E {ホスト名}'、エスケー
プ文字を他の文字にするには 'telnet -e {エスケープ文字} {ホスト名}' を使用する。
もし可能ならtelnetの代わりにsshを使うことで、この問題を回避できる。

							*tag-priority*
タグのマッチが複数ある場合、以下の優先度が使われる:
1. "FSC"  カレントファイル内の全一致するstaticタグ。
2. "F C"  カレントファイル内の全一致するglobalタグ。
3. "F  "  別のファイル内の全一致するglobalタグ。
4. "FS "  別のファイル内の全一致するstaticタグ。
5. " SC"  カレントファイル内の大文字、小文字を無視した一致をするstaticタグ。
6. "  C"  カレントファイル内の大文字、小文字を無視した一致をするglobalタグ。
7. "   "  別のファイル内の大文字、小文字を無視した一致をするglobalタグ。
8. " S "  別のファイル内の大文字、小文字を無視した一致をするstaticタグ。

カレントファイルが変わっても、優先度のリストはほとんどの場合変化しないので注意
すること。これは ":tnext" を使うときの混乱を避けるためである。優先度のリストは
":tag {name}" を使ったときに変化する。

以下の場合は ":tag " で大文字小文字を無視した検索は行われない:
- 'tagcase' が "followic" で 'ignorecase' オプションがオフの時
- 'tagcase' が "followscs" で 'ignorecase' オプションがオフで 'smartcase' オプ
  ションがオフであるか、パターンに大文字が含まれている時
- 'tagcase' が "match" である
- 'tagcase' が "smart" でパターンに大文字が含まれる時

以下の場合は大文字小文字を無視した検索が行われる:
- パターンが使用される時 ("/" で始まる)
- ":tselect" の時
- 'tagcase' が "followic" で 'ignorecase' がオンの時
- 'tagcase' が "followscs" で 'ignorecase' がオン、または 'smartcase'
  オプションがオンでパターンに大文字が含まれていない時
- 'tagcase' が "ignore" の時
- 'tagcase' が "smart" でパターンに大文字が含まれていない時

Note 大文字小文字を無視したタグ検索はタグファイル内での二分探索を無効にし速度
の低下を引き起こす。これは大文字小文字を保持したままタグファイルを並び替える事
で回避できる。'tagbsearch' オプションの説明を参照。

==============================================================================
2. タグスタック				*tag-stack* *tagstack* *E425*

タグスタック上にはジャンプ先のタグと、どこから来たのかという情報が記憶される。
タグは 'tagstack' オプションが設定されているときにだけ積まれる。

g<RightMouse>						*g<RightMouse>*
<C-RightMouse>					*<C-RightMouse>* *CTRL-T*
CTRL-T			タグスタック中の[count]分だけ古いエントリにジャンプす
			る(デフォルトは1)。

						*:po* *:pop* *E555* *E556*
:[count]po[p][!]	タグスタック中の[count]分だけ古いエントリにジャンプす
			る(デフォルトは1)。
			[!]については|tag-!|を参照。

:[count]ta[g][!]	タグスタック中の[count]分だけ新しいエントリにジャンプ
			する(デフォルトは1)。
			[!]については|tag-!|を参照。

							*:tags*
:tags			タグスタックの内容を表示する。現在のエントリは '>' で
			マークされる。

":tags" の出力は以下のようになる:

   # TO tag      FROM line  in file/text
   1  1 main		 1  harddisk2:text/vim/test
 > 2  2 FuncA		58  i = FuncA(10);
   3  1 FuncC	       357  harddisk2:text/vim/src/amiga.c

このリストはジャンプ先のタグとジャンプ前のカーソル位置を表示する。上から順に古
いタグが並び、一番下が最も新しいタグである。

'>' は現在のエントリを指している。これは次の ":tag" コマンドで使われるタグであ
る。CTRL-Tと ":pop" コマンドは１つ上のタグを使う。

"TO" の列にはマッチリスト中の現在のマッチ数を表示する。これは ":pop" や ":tag"
を使っても変化しないので注意すること。

行番号とファイル名は、タグコマンドを実行する前にいた位置に戻ることができるよう
に記憶される。行番号は行の削除や挿入が行われた時にも正しく維持される。ただし、
別のプログラム(例えば、Vimの別インスタンス)で編集した場合を除く。

ジャンプ前の位置がカレントファイル内であれば、"file/text" の列にその行が表示さ
れる。インデントは取り除かれ、長い行はウィンドウに収まるように切り詰められる。

前に使ったタグにジャンプするコマンドはいくつかある。例えば:

	":pop" or CTRL-T	ひとつ前に使われたタグにジャンプする。
	{count}CTRL-T		{count}分だけ前のタグにジャンプする。
	":tag"			現在のエントリより新しいタグにジャンプする。
	":0tag"			最後に使われたタグにジャンプする。

これらの最も明白な利用方法は、プログラムの関数呼び出しをあちこち拾い読みすると
きである。次のような呼び出し図を考える:

	main  --->  FuncA  --->  FuncC
	      --->  FuncB

(解説: mainはFuncAとFuncBを呼び出し、FuncAはFuncCを呼び出す)。
FuncAの呼び出し部分の上でCTRL-]を使うことによって、mainからFuncAに行くことがで
きる。同様にCTRL-]を使ってFuncCへ行くことができる。mainに戻るにはCTRL-Tを２回
使う。そこでCTRL-]を使ってFuncBに行くことができる。

":ta {name}" やCTRL-]コマンドは、タグスタック上の現在の位置にタグを追加する。
もしスタックが満たされていた場合(スタックは20エントリまで保持できる)、最も古い
エントリが削除され、古いものから順にひとつずつ上に移動する(インデックス番号は1
ずつ減る)。もし最後に使われたエントリが一番下になかった場合、最後に使われたエ
ントリより下にあるものは削除される。つまり古いタグ経路は失われる。上のパラグラ
フの説明を実行したあとのタグスタックは次のような状態になる:

   # TO tag	FROM line  in file/text
   1  1 main		1  harddisk2:text/vim/test
   2  1 FuncB	       59  harddisk2:text/vim/src/main.c

|gettagstack()| 関数は、指定されたウィンドウのタグスタックを返す。
|settagstack()| 関数は、ウィンドウのタグスタックを変更する。

							*tagstack-examples*
ちょうど `:tag` でタグスタックを書き込んだかの様に動く jumper#jump_to_tag 関数
をユーザー定義するなら: >
	" ジャンプする前にジャンプ元の位置を保存する。
	let tag = expand('<cword>')
	let pos = [bufnr()] + getcurpos()[1:]
	let item = {'bufnr': pos[0], 'from': pos, 'tagname': tag}
	if jumper#jump_to_tag(tag)
		" ジャンプが成功だったら、前の位置をタグスタックに書き込む。
		let winid = win_getid()
		let stack = gettagstack(winid)
		let stack['items'] = [item]
		call settagstack(winid, stack, 't')
	endif
<
現在のタグスタックのインデックスを4にするには: >
	call settagstack(1005, {'curidx' : 4})
<
新しいアイテムをタグスタック上にプッシュするなら: >
	let pos = [bufnr('myfile.txt'), 10, 1, 0]
	let newtag = [{'tagname' : 'mytag', 'from' : pos}]
	call settagstack(2, {'items' : newtag}, 'a')
<
							*E73*
タグスタックを使おうとしたとき、タグスタックに何も入っていないとエラーが表示さ
れる。

==============================================================================
3. タグマッチリスト				*tag-matchlist* *E427* *E428*

以下のコマンドは複数のタグがマッチしたときに、タグの間を移動するために使うこと
ができる。これらのコマンドはタグスタックを変更せず、同じエントリを保つことに注
意すること。

							*:ts* *:tselect*
:ts[elect][!] [name]	タグファイルの情報を用いて、[name]にマッチするタグをリ
			スト表示する。
			[name]を省略した場合、タグスタック上の最後のタグが使わ
			れる。
			[!]に関しては|tag-!|を参照。
			最初の列に '>' があるものはリスト中の現在の位置を指し
			示している(それがあるならば)。
			[name]は正規表現を取り得る。|tag-regexp|を参照。
			リストに使われているプロパティは|tag-priority|を参照。
			出力例:

>
	  # pri kind tag		file
	  1 F	f    mch_delay		os_amiga.c
			mch_delay(msec, ignoreinput)
	> 2 F	f    mch_delay		os_msdos.c
			mch_delay(msec, ignoreinput)
	  3 F	f    mch_delay		os_unix.c
			mch_delay(msec, ignoreinput)
	Type number and <Enter> (empty cancels):
<
			"pri" については|tag-priority|を参照。この例は現在の
			ファイルに依存しているため、":tselect xxx" を使ったと
			きには違う結果が得られることに注意すること。
			"kind" はタグファイルからタグの種類が得られる場合のみ、
			その情報を示す。
			"info" はタグファイルから得られる情報が表示される。こ
			の情報はタグファイルを生成したプログラムに依存する。
			リストが長い場合には|more-prompt|が表示される。もしす
			でに使いたいタグを見つけているのなら、'q' のあとに
			"nr" の番号を入力すればよい。

							*:sts* *:stselect*
:sts[elect][!] [name]	":tselect[!] [name]" を実行し、ウィンドウを分割して選
			択されたtagを表示する。

							*g]*
g]			CTRL-]と動作は似ているが、":tag" の代わりに ":tselect"
			を用いる。

							*v_g]*
{Visual}g]		"g]" と同じ。ただし、選択されたテキストが検索に使われ
			る。
							*:tj* *:tjump*
:tj[ump][!] [name]	":tselect" と動作は似ているが、適合するtagが１つだけの
			ときには直接移動する。

							*:stj* *:stjump*
:stj[ump][!] [name]	":tjump[!] [name]" を実行し、ウィンドウを分割して選択
			されたtagを表示する。

							*g_CTRL-]*
g CTRL-]		CTRL-]と動作は似ているが、":tag" の代わりに ":tjump"
			を用いる。

							*v_g_CTRL-]*
{Visual}g CTRL-]	"g CTRL-]" と同じ。ただし、選択されたテキストが検索に
			使われる。
							*:tn* *:tnext*
:[count]tn[ext][!]	適合するtagのうち、[count]番目のtagに移動する。(省略時
			は1。)[!]に関しては|tag-!|を参照。

							*:tp* *:tprevious*
:[count]tp[revious][!]	適合するtagのうち、[count]分だけ前のtagに移動する。(
			省略時は1。)[!]に関しては|tag-!|を参照。

							*:tN* *:tNext*
:[count]tN[ext][!]	":tprevious" と同様。

							*:tr* *:trewind*
:[count]tr[ewind][!]	適合したtagのうち最初のtagに移動する。もし[count]が与
			えられていたら、[count]番目のtagに移動する。[!]につい
			ては|tag-!|を参照。

							*:tf* *:tfirst*
:[count]tf[irst][!]	":trewind" と同じ。
							*:tl* *:tlast*
:tl[ast][!]		適合したtagのうち最後のtagに移動する。[!]に関しては
			|tag-!|を参照。

							*:lt* *:ltag*
:lt[ag][!] [name]	タグ[name]にジャンプし、マッチするタグ全てをカレント
			ウィンドウの新しいlocationリストに追加する。
			[name]は正規表現でもよい(|tag-regexp|を参照)。[name]が
			指定されないときはタグスタックにある最後のタグ名が使わ
			れる。タグにマッチする行を特定するための検索パターンに
			は、特別な文字を全てエスケープするために "\V" がつけら
			れる(very nomagic)。マッチするタグを保持するlocationリ
			ストはタグスタックとは独立している。[!]について
			は|tag-!|を参照。

他にメッセージがないとき、Vimは今までに移動したtagとtagの数を表示する: >
	tag 1 of 3 or more
" or more" は、Vimがまだすべてのtagファイルを検索していないことを示すために用
いられる。":tnext" を数回用いるか、":tlast" を使用したとき、さらにtagが見つけ
られるだろう。

他のメッセージがあったときや、現在の場所を知りたいときには次のコマンドで再び
表示することができる。(最後に行った移動と同じtagに移動する。): >
	:0tn
<
							*tag-skip-file*
マッチしたタグに対するファイルが見つからなかった場合、スキップされて次にマッチ
するタグが使われる。Vimはファイルがないことを通知する。もしリストの終端に達し
ていたならば、エラーメッセージが与えられる。

							*tag-preview*
タグマッチリストはプレビューウィンドウ内でも使用できる。そのコマンドは上記のも
のに似ているが、先頭に "p" がつく。
{|+quickfix|が無効なときは利用できない}

							*:pts* *:ptselect*
:pts[elect][!] [name]	":tselect[!] [name]" を実行し、"Preview" ウィンドウに
			新しいタグを表示する。詳細は|:ptag|を参照すること。

							*:ptj* *:ptjump*
:ptj[ump][!] [name]	":tjump[!] [name]" を実行し、"Preview" ウィンドウに新
			しいタグを表示する。詳細は|:ptag|を参照すること。

							*:ptn* *:ptnext*
:[count]ptn[ext][!]	プレビューウィンドウで ":tnext" を実行する。|:ptag|を
			参照すること。

							*:ptp* *:ptprevious*
:[count]ptp[revious][!]	プレビューウィンドウで ":tprevious" を実行する。
			|:ptag|を参照すること。

							*:ptN* *:ptNext*
:[count]ptN[ext][!]	":ptprevious" と同じ。

							*:ptr* *:ptrewind*
:[count]ptr[ewind][!]	プレビューウィンドウで ":trewind" を実行する。|:ptag|
			を参照すること。

							*:ptf* *:ptfirst*
:[count]ptf[irst][!]	":ptrewind" と同じ。

							*:ptl* *:ptlast*
:ptl[ast][!]		プレビューウィンドウで ":tlast" を実行する。|:ptag|を
			参照すること。

==============================================================================
4. タグの詳細						*tag-details*

							*static-tag*
staticタグは特別なファイルのために定義されたタグである。Cプログラムではstatic
関数が当てはまる。

Viはタグにジャンプするときに現在の検索パターンを設定する。これはタグにジャンプ
したあとの "n" コマンドは、その前の検索パターンと同じ検索を行わないということ
である。Vimではこのようなバグとも考えられることはしない。もし古いViの振る舞い
を望むならば、'cpoptions' に 't' を設定する。

							*tag-binary-search*
Vimは希望のタグをすばやく見つけるために、タグファイル内で二分探索を行う
(|+tag_binary|がコンパイル時に有効になっていれば)。しかしこれはタグファイルが
ASCIIコードでソートされている場合にのみ機能する。したがって、もし適合しないも
のが見つかった場合は、その他の方法として線形探索が行われる。もし線形探索のみを
利用したいならば、'tagbsearch' オプションをリセットすればよい。そうでなければ:
タグファイルをソートすること!

検索が明確な名前をもったタグでない場合は二分探索は利用できないことに注意するこ
と。これは大文字小文字を無視した検索や固定文字列で始まらない正規表現による検索
で発生する。そのときはタグ検索はかなり遅くなるだろう。先人はタグファイルを大文
字と小文字を区別せずにソートすることで回避できた。詳細は 'tagbsearch' を参照の
こと。

							*tag-regexp*
":tag" と ":tselect" コマンドは引数に正規表現を受け付ける。使用できる特殊文字
については|pattern|を参照すること。引数が '/' で始まる場合はパターンとして使わ
れる。もし引数が '/' で始まらなければ、完全なタグ名の文字列として扱われる。
例: >
    :tag main
<	最も優先度の高い "main" というタグにジャンプする。 >
    :tag /^get
<	最も優先度の高い "get" で始まるタグにジャンプする。 >
    :tag /norm
<	"norm" を含むすべてのタグを列挙する。これは "id_norm" というタグも含ま
	れる。
もし引数と全く同じタグと、正規表現によってマッチしたタグがあった場合、引数と同
じタグが優先される。例えば、":tag /open" は "open_file" や "file_open" よりも
前に "open" にマッチする。
正規表現を使うときは大文字・小文字は区別されない。大文字・小文字を区別したいな
ら正規表現の中で "\C" を使うこと。

							*tag-!*
タグが現在のファイル内にある場合、これは常に動作する。それ以外の場合、実行され
る動作は、現在のファイルが変更されたかどうか、コマンドに ! が追加されているか
どうかと、'autowrite' および 'winfixbuf' オプションに依存する:

タグが現在の  ファイル	    winfixbuf   autowrite			~
 ファイル内   変更あり	!   オプション  オプション    動作	~
 -----------------------------------------------------------------------------
    yes		x	x      off	  x	    タグに行く
    no		no	x      off	  x	    対象ファイルを読み込み、タ
						    グに行く
    no		yes	yes    off	  x	    現在のファイルを捨て、
						    対象ファイルを読み込んでタ
						    グに行く
    no		yes	no     off	  on	    現在のファイルを保存し、
						    対象ファイルを読み込んでタ
						    グに行く
    no		yes	no     off	  off	    失敗する
    yes		x	yes    x	  x	    タグに行く
    no		no	no     on	  x	    失敗する
    no		yes	no     on	  x	    失敗する
    no		yes	no     on	  on	    失敗する
    no		yes	no     on	  off	    失敗する
 -----------------------------------------------------------------------------

- タグが現在のファイル上にある場合は、コマンドはいつも機能する。
- タグが他のファイル上にあり、現在のファイルが変更されていないならば、対象とな
  るファイルがバッファに読み込まれる。
- タグが他のファイル上にあり、現在のファイルが変更されていて、かつ!がコマンド
  につけられている場合には、現在のファイルに対する変更は失われ、対象となるファ
  イルがバッファに読み込まれる。
- タグが他のファイル上にあり、現在のファイルが変更されていて、かつ 'autowrite'
  オプションが設定されている場合には、現在のファイルは保存され、対象となるファ
  イルがバッファに読み込まれる。
- タグが他のファイル上にあり、現在のファイルが変更されていて、かつ 'autowrite'
  オプションが設定されていない場合には、コマンドは失敗する。変更を保存したいな
  らば ":w" コマンドを使用し、そのあとで ":tag" を引数なしで実行する。これはタ
  グがスタック上に残っているためにうまく機能する。変更を失ってもよいのならば、
  ":tag!" コマンドを使用できる。
- タグが他のファイル上にあり、ウィンドウに 'winfixbuf' が含まれている場合、コ
  マンドは失敗する。タグが同じファイル内にある場合は、成功する可能性がある。

							*tag-security*
Vimはセキュリティの都合上、いくつかのコマンドを禁止していることに注意すること。
これはちょうど現在のディレクトリにあるexrc/vimrcファイルに 'secure' オプション
が使われているのと同じように機能する。|trojan-horse|と|sandbox|を参照すること。
{tagaddress}がバッファを変更したとき、次のようなエラーメッセージが表示される:
	"WARNING: tag command changed a buffer!!!"
将来のバージョンではバッファを変更することは不可能になるだろう。これらはすべて
セキュリティの理由である: 誰かが気づかれないように実行される厄介なコマンドをタ
グファイルに隠しているかもしれない。例えば: >
	:$d|/tag-function-name/

Viでは ":tag" コマンドによってタグを検索すると、最新の検索パターンを上書きする。
Vimでは 'cpoptions' に 't' フラグが設定されていなければ、前の検索パターンは引
き続き記憶される。

					*emacs-tags* *emacs_tags* *E430*
Emacsスタイルのタグファイルは、Vimのコンパイル時に|+emacs_tags|機能を有効にし
た場合にのみ使用できる。すまないが、Emacsタグファイルについての説明はここでは
しない。それは下位互換のためにのみ提供している :-)。

Emacs タグファイルの行は非常に長くなることがある。Vim は行の約510バイトまでし
か扱わない。行が無視されたかどうかは 'verbose' を5以上にしていればわかる。
Emacs ではないタグファイルの行はどのような長さでもよい。

							*tags-option*
'tags' オプションはファイル名のリストで構成される。これらのファイルからタグが
検索される。デフォルトの "tags" ファイルよりも、異なるtagsファイルがよく使われ
るだろう。共通のtagsファイルにもよくアクセスするだろう。

以下のようなときは、リストの次のファイルを使わない:
- 現在のバッファに対するstaticタグが見つかった場合。
- globalタグが見つかった場合。
これは大文字小文字が無視されるかどうかにも依存する。大文字小文字は以下の場合に
無視される:
- 'tagcase' が "followic" で 'ignorecase' が設定されている
- 'tagcase' が "ignore" である
- 'tagcase' が "smart" でパターンに小文字だけが含まれている
- 'tagcase' が "followscs" で 'smartcase' が設定されておりパターンに小文字のみ
  が含まれている
大文字小文字が無視されず、タグファイルが大文字小文字を除外したマッチのみとなる
場合、続くタグファイルは大文字小文字をマッチして検索される。大文字小文字をマッ
チしてタグファイルが見つからない場合、大文字小文字を除外してマッチした最初の結
果が使用される。もし大文字小文字が無視されグローバルのタグでマッチした、もしく
は大文字小文字を除外してマッチした場合、タグファイルの検索は行われず見付かった
そのファイルが使用される。

タグファイル名が "./" で始まるとき、'.' は現在のファイルのパスで置き換えられ
る。これにより、現在のファイルがあるディレクトリのtagsファイルを使用することが
できる(たとえ現在のディレクトリがどこであろうと)。"./" を使用する概念は、どの
タグファイルを最初に検索するかを決定することである: 現在のディレクトリにするか
("tags,./tags")、現在のファイルがあるディレクトリにするか("./tags,tags")であ
る。

例: >
	:set tags=./tags,tags,/home/user/commontags

この例では、現在のファイルがあるディレクトリの "tags" ファイルがまず検索され
る。次に現在のディレクトリにある "tags" ファイルが検索される。もしまだ見つから
なければ、"/home/user/commontags" が検索される。

これは 'cpoptions' に 'd' フラグを含めることでVi互換のようにすることができる。
"./tags" は現在のファイルがあるディレクトリのtagsファイルではなく、現在のディ
レクトリのtagsファイルを意味するようになる。

コンマの代わりにスペースを使用してもよい。文字列オプションに含めるためにはスペー
スの前にバックスラッシュが必要となる: >
	:set tags=tags\ /home/user/commontags

ファイル名にスペースを含めるにはバックスラッシュを３つ並べる。コンマをファイル
名に使用する場合にはバックスラッシュを２つ並べる。例えば: >
	:set tags=tag\\\ file,/home/user/common\\,tags

"tag file" と "/home/user/common,tags" というファイルが指定できる。'tags' オプ
ションは "tag\ file,/home/user/common\,tags" という値を持つだろう。

'tagrelative' オプションをオンにし(デフォルト)、他のディレクトリでタグファイル
を使用すると、タグファイル内に記述されたファイル名はタグファイルがあるディレク
トリを基準として相対パスになる。

==============================================================================
5. タグファイルの書式				*tags-file-format* *E431*

						*ctags* *jtags*
tagsファイルは "ctags" のような外部コマンドによって生成される。それはそれぞれ
の関数へのタグを含んでいる。"ctags" のあるバージョンでは "#defined" マクロや
typedef、enumなどに対してもタグを作ることができる。

tagsファイルを生成するプログラム:
ctags			ほとんどのUnixシステムにある。C言語のみ対応し、基本的
			な機能を提供する。
universal ctags		exuberant ctags をベースにメンテナンスされているバー
			ジョンの ctags。https://ctags.io を参照。
							*Exuberant_ctags*
exuberant ctags		これはとてもよいものだ。C言語、C++、Java、Fortran、
			Eiffel、そしてその他に対応している。多くの項目にタグを
			生成することができる。
			http://ctags.sourceforge.net を参照。
			2009年から新しいバージョンが出ていない。
etags			Emacsに連携する。多言語に対応している。
JTags			Java 用、Java で書かれている。
			http://www.fleiner.com/jtags/で入手できる。
ptags.py		Python 用、Python で書かれている。
			PythonのソースディレクトリTools/scripts/ptags.pyにある。
ptags			Perl 用、Perl で書かれている。これはここで見つかる (リ
			ンク切れのようだ):
			http://www.eleves.ens.fr:8080/home/nthiery/Tags/
gnatxref		Ada用。http://www.gnuada.org/ を参照。
			gnatxrefはgnatパッケージの一部である。


tags ファイルは次の 2 つの形式のどれかで構成されなければならない:

1.  {tagname}		{TAB} {tagfile} {TAB} {tagaddress}
2.  {tagname}		{TAB} {tagfile} {TAB} {tagaddress} {term} {field} ..

以前には古い形式がサポートされていた、|tag-old-static| を参照。

最初の形式は通常のタグで、Viで完全に互換性がある。伝統的なctagsによってのみ作
られる形式である。これはしばしばグローバルな関数や他のファイルを参照する場合に
使用される。

タグファイルの行は<NL>または<CR><NL>で終わる。Macintoshでは<CR>も機能する。
<CR>と<NL>は行内に決して現れない。

2番目の形式は新しい。各行の末尾にある任意的なフィールドに追加の情報を含む。こ
れは以前のViとも互換性がある。新しいバージョンのctagsにのみサポートされている
(Universal ctags や Exuberant ctags など)。

{tagname}	識別子。普通は関数名であるが、どんな識別子でも構わない。<Tab>
		を含めることはできない。
{TAB}		1文字の<Tab>。 Note: 以前のバージョンではここでどんな空白文字
		も許可していた。これは{tagfile}内にスペースを許可するために放
		棄された。
{tagfile}	{tagname}の定義を含むファイル名。絶対パスでも相対パスでも構わ
		ない。環境変数やワイルドカードを含んでもよい(ワイルドカードの
		使用方法はあいまいだが)。<Tab>を含むことはできない。
{tagaddress}	カーソルをタグ上に移動するExコマンド。制限(|tag-security|を参
		照)はあるが、どんなExコマンドでも使用可能である。
		Posixでは主に使われる行番号と検索コマンドのみ許可する。
{term}		;" セミコロンとダブルクォートの2文字。これはViによってコメント
		とみなされ、続く文字列は無視される。以前のViとの互換性を保つた
		めにある。これは続くフィールドを無視する。例: >
			APP	file	/^static int APP;$/;"	v
<		{tagaddress} が行番号または検索パターンではない場合、{term} は
		|;" でなければならない。ここで、バーはコマンドを終了させる(バー
		を除く)。そして ;" はViに残りの行を無視させるために使われる。
		例: >
			APP	file.c	call cursor(3, 4)|;"	v

{field} ..	任意のフィールドのリスト。各フィールドは次の書式を持つ:

			<Tab>{fieldname}:{value}

		{fieldname}はフィールドの識別子であり、アルファベットのみ使用
		可能である[a-zA-Z]。
		{value}は任意の文字列であるが、<Tab>は使用できない。
		以下の特殊文字が使用できる:
			"\t" は<Tab>を表す
			"\r" は<CR>を表す
			"\n" は<NL>を表す
			"\\" は\を表す

		':' を持たないフィールドがある。これはタグの一種である。
		"kind:" を先頭につけたものとして扱われる。
		上記の例では、これは "kind:v" (通常は変数) だった。生成される
		kinds については ctags のドキュメントを参照。ctags では
		`ctags --list-kinds` を使用できる。

		現在Vimが認識できるその他のフィールドは "file:" (値はなし)だけ
		である。これはstaticタグに使われる。


tagsファイルの先頭行には、
	!_TAG_
で始まる行を含めることができる。
これらは極稀な "!" で始まるタグを除けば先頭行にソートされる。Vimは2つのタグを
認識する。1つはファイルがソートされているかどうかを示す行で、この行が見つかっ
た場合には、Vimはtagsファイルに対して二分探索を使用する:
	!_TAG_FILE_SORTED<TAB>1<TAB>{anything} ~

大文字小文字を無視する設定の時、線形探索を避けるためにタグファイルは大文字小文
字を区別せずにソートされることがある。('ignorecase' がセットされかつ 'tagcase'
が "followic" の時、または 'tagcase' が "ignore" の時に大文字小文字は無視され
る。) 詳細は 'tagbsearch' を参照のこと。
その時、値として '2' が使われる:
	!_TAG_FILE_SORTED<TAB>2<TAB>{anything} ~

Vimが認識するもう1つのタグはタグファイルのエンコーディングを指定するものである:
	!_TAG_FILE_ENCODING<Tab>utf-8<Tab>{anything} ~
ここで "utf-8" はタグのエンコーディングである。Vimはタグを検索するときに検索す
るタグを 'encoding' からタグファイルのエンコーディングに変換する。そして、タグ
をリストするときに元に戻す。変換が失敗したときは元のままのタグが使われる。

							*tag-search*
コマンドはどんなExコマンドでも使用可能であるが、検索コマンドがよく使われるであ
ろう。
例:
	tag1	file1	/^main(argc, argv)/ ~
	tag2	file2	108 ~

コマンドは常に 'magic' がセットされない状態で実行される。検索パターンで使用で
きる特殊文字は "^" (行頭) と "$" (<EOL>) だけである。|pattern|を参照すること。
Note 検索文字列中のバックスラッシュの前にはバックスラッシュをつけなければなら
ないことに注意すること。これは以前のViと互換性がある。

							*E434* *E435*
もしコマンドが普通の検索コマンド ("/" か "?" で始まり、終わる) であるならば、
いくつかの特別な扱いをされる:
- 検索はファイルの1行目から開始する。
  検索方向は "/" で前方、"?" で後方となる。
  Note 'wrapscan' は問題にならず、いつもファイル全体を検索することに注意。
- 検索が失敗した場合は、大文字小文字を無視してもう一度検索する。それも失敗した
  場合には次の検索が行われる: >
	"^tagname[ \t]*("
<  (タグの先頭に '^'、末尾に "[ \t]*(" が追加される)。関数名の検索の場合には、
  これはカラム0の位置にある関数名を見つけるだろう。関数の引数がtagsファイルを
  作成したときから変更になったときなどに役立つだろう。この検索でも見つからない
  場合にはさらに次の検索が行われる: >
	"^[#a-zA-Z_].*\<tagname[ \t]*("
<  この意味は: '#' もしくは識別子で始まり、空白文字と '(' が続くタグを含む行で
  ある。これは型が先頭にあるマクロ名や関数名を見つけるだろう。


							*tag-old-static*
旧式のフォーマットは 2019 年 3 月 (patch 8.1.1092) までサポートされていた:
    {tagfile}:{tagname} {TAB} {tagfile} {TAB} {tagaddress}

この形式は static タグにのみ使用できる。現在では廃れており、2 番目の形式に置き
換えられている。これは Elvis 1.x と古いバージョンの Vim、それといくつかのバー
ジョンの ctags によってのみサポートされている。static タグはローカル関数によく
用いられ、{tagfile} 内のみ参照する。static タグでは 2 つの {tagfile} は正確に
一致していなければならないことに注意すること。static タグがどのように使われる
かについては |tags-option| を参照すること。

新しいバージョンの Vim に更新するときに、2 番目の形式をサポートする ctags に更
新できるべきでもあるので、このサポートは削除された。

==============================================================================
6. インクルードファイルの検索		*include-search* *definition-search*
							*E387* *E388* *E389*

これらのコマンドは対象となる文字列を現在のファイルと、遭遇するすべてのインクルー
ドファイルを再帰的に探す。これは変数や関数、マクロの定義を探すのに利用できる。
現在のバッファに対してだけ検索をしたいのならば、|pattern-searches|に列挙されて
いるコマンドを使うとよい。

これらのコマンドは、コンパイル時に|+find_in_path|機能を使用不可にした場合には
利用できない。

他のファイルをインクルードする行に遭遇すると、現在のバッファを続けて検索する前
にインクルードファイルを検索する。インクルードファイルによってインクルードされ
るファイルも同様に検索される。インクルードファイルが見つからなかった場合は黙っ
て無視する。見つからなかったファイルを知りたいときは|:checkpath|コマンドを使う。
たぶん 'path' オプションが正しく設定されていないのだろう。Note: インクルード
ファイルはファイルが検索され、そのファイルを編集中のバッファが存在しても対象に
ならない。バッファにある行は、現在のファイルにのみ適用される。

検索文字列は任意のキーワードや定義されたマクロが指定できる。キーワードの場合は
マッチするものを見つける。定義されたマクロの場合は 'define' オプションにマッチ
する行だけが見つけられる。デフォルトはCプログラム用の "^#\s*define" である。他
の言語の場合はおそらく変更したいだろう。C++用の例は 'define' を参照。その文字
列に改行を含めることはできない。一行内にマッチするものだけが見つかる。

定義されたマクロが見つかった場合、行末がバックスラッシュのときは次の行も表示す
る。

"[" で始まるコマンドは現在のファイルの先頭から検索を開始する。"]" で始まるコマ
ンドは現在のカーソル位置から検索を開始する。

'include' オプションは他のファイルをインクルードする行を定義する。デフォルトは
Cプログラム用の "\^#\s*include" である。Note: VimはCの構文を認識しない。もし
'include' オプションにマッチする行が "#ifdef/#endif" の間やコメント行であって
も、とにかく検索される。'isfname' オプションはマッチパターンに続くファイル名を
認識するために使用される。

'path' オプションは絶対パスを持たないインクルードファイルを探すためのディレク
トリを指定する。

'comments' オプションは単一行を表示するコマンド、もしくは行にジャンプするコマ
ンドで使用される。これはコメントの開始パターンを定義する。それらの行は [!] を
使用しない限り検索において無視される。ひとつの例外: 行が "^# *define" というパ
ターンにマッチしたとき、コメントであるとはみなされない。

もしマッチしたリストを表示して、その中からジャンプ先を選択したいならば、マッピ
ングが利用できる。例: >

  :map <F4> [I:let nr = input("Which one: ")<Bar>exe "normal " .. nr .. "[\t"<CR>
<
							*[i*
[i			カーソルの下にあるキーワードを含む１行を表示する。検索
			はファイルの先頭から開始する。コメントとみなせる行は無
			視される('comments' オプションを参照すること)。数字が
			与えられた場合は、先頭から指定した個数目にマッチした行
			を表示する。この場合はコメント行は無視されない。

							*]i*
]i			"[i" と同様だが、検索が現在のカーソル位置から開始され
			る。

							*:is* *:isearch*
:[range]is[earch][!] [count] [/]pattern[/]
			"[i" や "]i" と同様だが、[range]で指定された範囲から検
			索する(デフォルト: ファイル全体)。
			[/]と[!]については|:search-args|を参照。

							*[I*
[I			カーソルの下にあるキーワードを含む行をすべて表示する。
			結果にはファイル名と行番号が表示される。検索はファイル
			の先頭から開始される。

							*]I*
]I			"[I" と同様だが、検索が現在のカーソル位置から開始され
			る。

							*:il* *:ilist*
:[range]il[ist][!] [/]pattern[/]
			"[I" や "]I" と同様だが、[range]で指定された範囲から検
			索する(デフォルト: ファイル全体)。
			[/]と[!]については|:search-args|を参照。

							*[_CTRL-I*
[ CTRL-I		カーソルの下にあるキーワードを含む最初の１行にジャンプ
			する。検索はファイルの先頭から開始する。コメントとみな
			せる行は無視される ('comments' オプションを参照するこ
			と)。数字が与えられた場合は、先頭から指定した個数目に
			マッチした行にジャンプする。この場合はコメント行は無視
			されない。

							*]_CTRL-I*
] CTRL-I		"[ CTRL-I" と同様だが、検索が現在のカーソル位置から開
			始される。

							*:ij* *:ijump*
:[range]ij[ump][!] [count] [/]pattern[/]
			"[ CTRL-I" や "] CTRL-I" と同様だが、[range]で指定され
			た範囲から検索する(デフォルト: ファイル全体)。
			[/]と[!]については|:search-args|を参照。

CTRL-W CTRL-I					*CTRL-W_CTRL-I* *CTRL-W_i*
CTRL-W i		新しいウィンドウを開き、カーソルの下にあったキーワード
			を含む最初の１行に移動する。検索はファイルの先頭から開
			始する。コメントとみなせる行は無視される('comments' オ
			プションを参照すること)。数字が与えられた場合は、先頭
			から指定した個数目にマッチした行にジャンプする。この場
			合はコメント行は無視されない。

							*:isp* *:isplit*
:[range]isp[lit][!] [count] [/]pattern[/]
			"CTRL-W i" や "CTRL-W i" と同様だが、[range]で指定され
			た範囲から検索する(デフォルト: ファイル全体)。
			[/]と[!]については|:search-args|を参照。

							*[d*
[d			カーソルの下にあるマクロを含む最初のマクロ定義を表示す
			る。検索はファイルの先頭から開始する。数字が与えられた
			場合は、先頭から指定した個数目にマッチした行を表示する。

							*]d*
]d			"[d" と同様だが、検索が現在のカーソル位置から開始され
			る。

							*:ds* *:dsearch*
:[range]ds[earch][!] [count] [/]string[/]
			"[d" や "]d" と同様だが、[range]で指定された範囲から検
			索する(デフォルト: ファイル全体)。
			[/]と[!]については|:search-args|を参照。

							*[D*
[D			カーソルの下にあるマクロを含むすべてのマクロ定義を表示
			する。結果にはファイル名と行番号が表示される。検索はファ
			イルの先頭から開始される。

							*]D*
]D			"[D" と同様だが、検索が現在のカーソル位置から開始され
			る。

							*:dli* *:dlist*
:[range]dli[st][!] [/]string[/]
			`[D` や `]D` と同様だが、[range]で指定された範囲から検
			索する(デフォルト: ファイル全体)。
			[/]と[!]については|:search-args|を参照。
			Note: `:dl` は `:dlist` ではなく、`:delete` に "l" レ
			ジスタを指定したものとして機能する。

							*[_CTRL-D*
[ CTRL-D		カーソルの下にあるキーワードを含む最初のマクロ定義にジャ
			ンプする。検索はファイルの先頭から開始する。数字が与え
			られた場合は、先頭から指定した個数目にマッチした行にジャ
			ンプする。

							*]_CTRL-D*
] CTRL-D		"[ CTRL-D" と同様だが、検索が現在のカーソル位置から開
			始される。

							*:dj* *:djump*
:[range]dj[ump][!] [count] [/]string[/]
			"[ CTRL-D" や "] CTRL-D" と同様だが、[range]で指定され
			た範囲から検索する(デフォルト: ファイル全体)。
			[/]と[!]については|:search-args|を参照。

CTRL-W CTRL-D					*CTRL-W_CTRL-D* *CTRL-W_d*
CTRL-W d		新しいウィンドウを開き、カーソルの下にあったキーワード
			を含む最初のマクロ定義に移動する。検索はファイルの先頭
			から開始する。数字が与えられた場合は、先頭から指定した
			個数目にマッチした行にジャンプする。

							*:dsp* *:dsplit*
:[range]dsp[lit][!] [count] [/]string[/]
			"CTRL-W d" と同様だが、[range]で指定された範囲から検索
			する(デフォルト: ファイル全体)。
			[/]と[!]については|:search-args|を参照。

					*:che* *:chec* *:check* *:checkpath*
:che[ckpath]		ファイルが見つからないすべてのインクルードファイル名を
			リスト表示する。

:che[ckpath]!		すべてのインクルードファイル名をリスト表示する。

								*:search-args*
上記コマンドに共通の引数:
[!]	使用した場合は、コメントとみなせる行に対しても検索をする。使用しなかっ
	た場合は 'comments' によってコメントとみなされる行やCコメント ("//" の
	後ろか /* */ の間)にあるものは無視される。コメントとみなされた行が、途
	中からコメントでなくなるようなときは見逃すかもしれないことに注意。
	また、コメント行であっても、('comments' によって)認識されないでとにか
	くマッチするかもしれない。例: >
		/* comment
		   foobar */
<	"foobar" に対する検索はマッチする。これは行がコメントとして認識されな
	いためである(たとえ構文強調表示が認識したとしても)。
	Note: マクロ定義はたいていコメントと誤認されることはないので、":dlist"
	や ":dsearch"、":djump" に[!]を使用することは大差がない。
[/]	パターンは '/' で囲むことができる。'/' なしの場合、"\<pattern\>" とい
	うパターンを使うことによって、完全な語だけがマッチする。2つ目の '/' の
	後にだけ、'|' を使うことによって次のコマンドを追加できる。例: >
	:isearch /string/ | echo "the last one"
<	":djump", ":dsplit", ":dlist", ":dsearch" コマンドではパターンは検索パ
	ターンとしてではなく文字通りに使われる。

==============================================================================
7. 'tagfunc' を使う						*tag-function*

|:tag|、|:tselect| のようなコマンド、および |CTRL-]| のようなノーマルモードタ
グコマンドに使われるタグのリストを生成する関数をVimに提供することが可能である。

タグリストの生成に使用される関数は、'tagfunc' オプションを設定することによって
指定される。関数は3つの引数で呼び出される:
   pattern	タグ検索中に使用されたタグ識別子もしくはパターン。
   flags	関数の挙動を制御するためのフラグを含む文字列。
   info		以下のエントリを含む辞書:
		    buf_ffname	  F優先順位のために使用できる完全ファイル名。
		    user_data	  カスタムデータ文字列。以前の tagfunc によっ
				  てタグスタックに格納されている場合。

Note 旧来の関数では使用時に引数名の前に "a:" を追加する必要がある。

現在、タグ関数には最大3つのフラグを渡すことができる:
  'c'		この関数は、処理中の通常のコマンドによって呼び出された。
		(ニーモニック: タグ関数は、カーソルの周りのコンテキストを使用
		して、タグリストを生成するためのより良い作業を実行できる。)
  'i'		挿入モードで、ユーザーはタグを補完していた (|i_CTRL-X_CTRL-]|
		もしくは 'complete' が "`t`" または "`]`" を含む場合)。
  'r'		tagfunc の最初の引数は、|pattern| (|tag-regexp| を参照) として
		解釈され、使用時には: >
		  :tag /pat
<		また挿入モードの補完時にも提供される。
		このフラグが存在しない場合、引数は常に文字通りの完全なタグ名と
		して扱われる。

Note 'tagfunc' が設定されている場合、|tag-priority| に記述されているタグの優先
順位は適用されない。代わりに、優先順位は、関数によって返されるリスト内の要素の
順序とまったく同じである。
								*E987*
関数は辞書エントリのリストを返すべきである。各辞書は少なくとも次のエントリを含
み、各値は文字列でなければならない:
	name		タグ名。
	filename	タグが定義されているファイルの名前。カレントディレクト
			リからの相対パスか、フルパスのどちらかである。
	cmd		ファイル内のタグを見つけるために使用されるExコマンド。
			これはEx検索パターンまたは行番号のどちらかである。
Note フォーマットは |taglist()| のものと似ており、これにより、結果を生成するた
めにその出力を使用することが可能になる。
以下のフィールドはオプションである:
	kind		タグの種類。
	user_data	オペレーション間でタグの曖昧さを解消するために使用でき
			る、タグスタックに格納されたカスタムデータの文字列。

関数がリストの代わりに、|v:null| を返した場合、標準のタグ検索が代わりに実行さ
れる。

タグスタックを 'tagfunc' の内部から変更することはできない。  *E986*
'tagfunc' の内部からウィンドウを閉じたり変更したりすることはできない。 *E1299*

以下は、'tagfunc' に使用される関数の仮定の例である。結果(ファイル名の逆順のタ
グのリスト)を生成するために |taglist()| の出力を使用している。
>
	function TagFunc(pattern, flags, info)
	  function CompareFilenames(item1, item2)
	    let f1 = a:item1['filename']
	    let f2 = a:item2['filename']
	    return f1 >=# f2 ?
			\ -1 : f1 <=# f2 ? 1 : 0
	  endfunction

	  let result = taglist(a:pattern)
	  call sort(result, "CompareFilenames")

	  return result
	endfunc
	set tagfunc=TagFunc
<

 vim:tw=78:ts=8:noet:ft=help:norl:
