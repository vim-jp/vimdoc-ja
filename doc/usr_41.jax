*usr_41.txt*	For Vim バージョン 9.1.  Last change: 2025 Apr 27

		     VIM USER MANUAL - by Bram Moolenaar

			      Vim script 書法


Vim script 言語は vimrc ファイルや構文ファイルなど、さまざまな目的に使われま
す。この章では Vim script の書き方を説明します。説明することがたくさんあるので
大きな章になってます。

|41.1|	はじめに
|41.2|	変数
|41.3|	式
|41.4|	条件式
|41.5|	式を実行する
|41.6|	関数を使う
|41.7|	関数を定義する
|41.8|	リストと辞書
|41.9|	空白
|41.10|	行継続
|41.11|	コメント
|41.12|	ファイルフォーマット

次章: |usr_42.txt|  新しいメニューを追加する
前章: |usr_40.txt|  新しいコマンドを作る
目次: |usr_toc.txt|

==============================================================================
*41.1*	はじめに				*vim-script-intro* *script*

まず、いくつかの命名法から始めましょう。Vim script とは、Vim が解釈して実行で
きるファイルのことです。これには、例えば .vim ファイルや .vimrc や .gvimrc 等
の構成ファイル等、Vim のスクリプト言語で記述されたファイルが含まれます。
これらのスクリプトは、Vim が動作をカスタマイズおよび拡張するために使用する、関
数、コマンド、および設定を定義するでしょう。

						*vim-script-notation*
正しい表記は "Vim script" (または、新しい Vim9 言語 |Vim9-script| を指す場合は
"Vim9 script") です。そのため、このドキュメントでは Vim のスクリプト言語を指す
際には "Vim script" を使用します。この略称は、Vim を使ったスクリプト作成に関す
る説明や議論を簡潔にするのに役立ちます。

Vim プラグインは、1 つ以上の Vim script と、ヘルプドキュメント、構成ファイル、
その他のリソース等の追加ファイルのコレクションであり、Vim に特定の特性や機能を
追加するように設計されています。プラグインは、新しいコマンドを提供したり、既存
の機能を強化したり、外部ツールやサービスを Vim 環境に統合したりできます。

誰もが最初に触れる Vim script は vimrc ファイルです。Vim が起動するときに読み
込まれ、書かれているコマンドが実行されます。それにより好きなように設定の変更、
マッピングの定義、プラグインの選択、そしてより多くのことができます。vimrc の中
ではすべてのコロンコマンドが使えます (":" で始まるコマンドのこと。Ex コマンド
やコマンドラインコマンドと呼ばれることもある)。

シンタックスファイルも Vim script です。シンタックスファイルは、ファイルタイプ
別にオプションを設定するファイルの一種です。複雑なマクロ定義を別ファイルに分け
て保存しておくこともできます。このように、いろいろな使用方法が考えられます。

Vim script は2種類になりました: 旧来のものと |Vim9| です。このヘルプファイルは
新規ユーザーのためなので、より新しくより便利な |Vim9| の文法を教えます。
旧来のスクリプトは Vim に特有ですが、|Vim9| script は JavaScript や TypeScript
などの他の言語により似ています。

Vim script を試すのに最適な方法はスクリプトファイルを編集して実行することです。
基本型: >
	:edit test.vim
	[あなたが望むだけスクリプト行を挿入します]
	:w
	:source %

簡単な例から始めましょう: >

	vim9script
	var i = 1
	while i < 5
	  echo "count is" i
	  i += 1
	endwhile
<

出力は次のようになります:

	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~

最初の行の `vim9script` コマンドで、これが新しい |Vim9| script ファイルである
と明確にしています。これは、ファイルの残りの部分がどのように使用されるかという
ことで重要です。コメントの前の、最初の行に配置することを推奨します。
							*vim9-declarations*
`var i = 1` コマンドは変数 "i" の宣言と初期化になります。
書式は次のとおりです: >

	var {変数名} = {式}

例では、変数名が "i"、式が 1 です。
`:while` コマンドでループを開始します。書式は次のとおりです: >

	while {条件式}
	  {ステートメント}
	endwhile

条件式が真である間、`endwhile` に到達するまでのステートメントが実行されます。
例では、条件式は "i < 5" です。これは、i が 5 より小さい場合に真になります。
	Note:
	何かのミスで while ループが止まらなかった場合は、CTRL-C を押せば中断で
	きます (MS-Windows では CTRL-Break)。

`echo` コマンドは引数を出力します。例では、"count is" という文字列と、変数 i
の値を出力しています。i が 1 なら、次のように表示されます:

	count is 1 ~

`i += 1` は "i = i + 1" と同じ意味です。変数 i に 1 を加算し、新しい値を同じ変
数に代入します。

上述の例は、実際にはもっと簡潔に書くことができます: >

	for i in range(1, 4)
	  echo $"count is {i}"
	endfor

`for`, `range()`, `$"string"` の説明はもっと先です。すぐに知りたい人はリンク先
にジャンプしてください。


☆例を試す

コマンドをファイルに保存しなくても、これらのヘルプファイルのほとんどの例を簡単
に試すことができます。例えば、上記の "for" ループを試すには:
1. カーソルを "for" 上へ置く
2. "v" でビジュアルモードを開始する
3. "endfor" まで移動する
4. コロンを押し、その後 "so" とエンターを押す

コロンを押した後、ビジュアル選択したテキストの範囲である ":'<,'>" が表示されま
す。

いくつかのコマンドは、|Vim9| scriptとして実行されることが重要です。しかし、入
力されたコマンドは通常、旧来のスクリプトの文法が使われるので、以下の例のような
場合にはそれが原因で E1004 エラーになります。そのような場合は、この4番目の手順
を使用してください:
4. コロンを押し、その後 "vim9 so" とエンターを押す

"vim9" は `vim9cmd` の短縮形で、|Vim9| の文法内で以降のコマンドを実行するコマ
ンド修飾子です。

Note スクリプトのコンテキストが要求される例については動作しません。


☆4種類の数値

数値は10進数、16進数、8進数そして2進数で表記できます。

16進数は "0x" か "0X" で開始します。例えば "0x1f" は10進数の 31 で "0x1234" は
10進数の 4660 です。

8進数は "0o" か "0O" で開始します。"0o17" は10進数の 15 です。

2進数は "0b" か "0B" で開始します。例えば "0b101" は10進数の 5 です。

10進数は数値そのままです。注意: 旧来のスクリプトで10進数で書くときは先頭に "0"
を付けないでください。8進数として扱われてしまいます！ これが |Vim9| script を
使う理由のひとつです。

`echo` コマンドは引数を評価し、数値の場合は常に10進数形式で出力します。例: >

	echo 0x7f 0o36
<	127 30 ~

数値にマイナス記号を付けると負数になります。8進数、16進数や2進数も負数にできま
す: >

	echo -0x7f
<	-127 ~

マイナス記号は減算記号としても使われます。これは時々混乱を招いてしまいます。
もし、マイナス記号を両方の数字の前に置いたならエラーになります: >

	echo -0x7f -0o36
<	E1004: White space required before and after '-' at "-0o36" ~

Note: |Vim9| script を使わずにこれらのコマンドを試すと、旧来のスクリプトとして
実行されてしまいます。そして echo コマンドは2つめのマイナス記号を減算と見なし
ます。このエラーを確認するには、コマンドのプリフィックスとして `vim9cmd` を付
けてください: >

	vim9cmd echo -0x7f -0o36
<	E1004: White space required before and after '-' at "-0o36" ~

式中の空白は可読性を高めるためとエラーの回避によく必要になります。上の "-0o36"
は負数を作ると考えらえれますが、実際には減算と見られてしまいます。

実際にマイナス記号を負数のために使うには、2番目の式を括弧で囲みます: >

	echo -0x7f (-0o36)
<	-127 -30 ~

==============================================================================
*41.2*	変数

変数名にはアルファベット、数字、アンダースコアが使えます。変数名を数字で開始す
ることはできません。次のような変数名が使えます:

	counter
	_aap3
	very_long_variable_name_with_underscores
	CamelCaseName
	LENGTH

"foo.var" や "6var" のような名前は使えません。

いくつかの変数はグローバルです。現在定義されているグローバル変数のリストを見る
にはこのコマンドを入力します: >

	:let

グローバル変数はどこでも使用できます。ただし、2つの無関係なスクリプトで同じ名
前を使用するのはとても簡単です。したがって、スクリプトで宣言された変数は、その
スクリプトに対してローカルです。例えば、これが "script1.vim" にあって: >

	vim9script
	var counter = 5
	echo counter
<	5 ~

"script2.vim" で変数を使おうとすると: >

	vim9script
	echo counter
<	E121: Undefined variable: counter ~

スクリプトローカル変数を使用すると、そのスクリプト内でのみ変更され、他の場所で
は変更されないことを明確にできます。

スクリプト間で変数を共有したい場合は、"g:" プリフィックスを使用して値を直接割
り当てます。`var` は使用しないでください。そして間違いを防止するために特定の名
前を使います。したがって、"script1.vim" では: >

	vim9script
	g:mash_counter = 5
	echo g:mash_counter
<	5 ~

そして "script2.vim" では: >

	vim9script
	echo g:mash_counter
<	5 ~

グローバル変数はコマンドラインからもアクセスできます、例えばこう打ちます: >
	echo g:mash_counter
これはスクリプトローカル変数では動作しません。

スクリプトローカル変数についての詳細は |script-variable| を参照してください。

変数の種類は他にもあります。|internal-variables| 参照。次の変数がよく使われま
す:

	b:name		バッファローカル変数
	w:name		ウィンドウローカル変数
	g:name		グローバル変数 (関数内では g: 必須)
	v:name		Vim が定義する変数


☆変数の削除

変数はメモリを消費します。`let` コマンドの出力にも表示されます。グローバル変数
を削除するには `unlet` コマンドを使います。例: >

	unlet g:counter

これは、グローバル変数 "g:counter" を削除し、使用するメモリを解放します。その
変数が存在するかどうか分からず、存在しない場合のエラーメッセージが必要なけれ
ば、! を付けてください: >

	unlet! g:counter

|Vim9| script 内ではスクリプトローカル変数を `unlet` できず、できるのは旧来の
スクリプトの中のみです。

スクリプトを最後まで処理しきったとき、宣言したローカル変数は削除されません。そ
のスクリプトで定義された関数が使うことができます。例: >

	vim9script
	var counter = 0
	def g:GetCount(): number
	  counter += 1
	  return counter
	enddef

関数を呼ぶたびに次のカウントを返します: >
	:echo g:GetCount()
<	1 ~
>
	:echo g:GetCount()
<	2 ~

スクリプトローカル変数が大量のメモリを消費していることが心配な場合は、不要に
なった後で空かnullの値を設定してください。例: >
	var lines = readfile(...)
	...
	lines = []

Note: 以下では、関連するコマンドに集中するため、例から `vim9script` の行を省略
しますが、スクリプトファイルの先頭には、この行を記述する必要があります。

☆文字列変数と定数

ここまでは変数の値に数値だけを使っていましたが、文字列を使うこともできます。
Vim は数値と文字列を基本型としてサポートしています。
例: >

	var name = "Peter"
	echo name
<	Peter ~

すべての変数には型があります。多くの場合、この例のように値を代入することで型が
定義されます。これは型推論と呼ばれます。まだ変数に値を与えたくない場合は、型を
指定する必要があります: >

	var name: string
	var age: number
	if male
	   name = "Peter"
	   age = 42
	else
	   name = "Elisa"
	   age = 45
	endif

間違えて誤った型の値を代入しようとした場合はエラーになります: >

	age = "Peter"
<	E1012: Type mismatch; expected number but got string ~

型についてのより詳細は |41.8| を参照。

変数に文字列値を割り当てるには、文字列定数を使うことができます。それには2種類
あります。1つめはすでに使用したように、ダブルクォート文字列です。文字列の中に
ダブルクォートを含める場合は、その前にバックスラッシュを付けます: >

	var name = "he is \"Peter\""
	echo name
<	he is "Peter" ~

バックスラッシュを使いたくない場合はシングルクォート文字列を使ってください: >

	var name = 'he is "Peter"'
	echo name
<	he is "Peter" ~

シングルクォート文字列の中ではすべての文字がそのまま使われます。ただし、シング
ルクォートだけは特別で、一つのシングルクォートを表すためには二つのシングル
クォートを書く必要があります。バックスラッシュはそのまま使われるので、特殊文字
は使えません: >

	var name = 'P\e''ter'''
	echo name
<	P\e'ter' ~

ダブルクォート文字列の中では特殊文字が使えます。次のようなものがあります:

	\t		<Tab>
	\n		<NL>, 改行
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, バックスペース
	\"		"
	\\		\, バックスラッシュ
	\<Esc>		<Esc>
	\<C-W>		CTRL-W

最後の二つはただの一例です。"\<name>" 形式で "name" という特殊キーを使うことが
できます。

文字列で使える特殊表記については |expr-quote| を参照してください。

==============================================================================
*41.3*	式

Vim は式の取り扱いはかなり標準的です。式の定義については |expression-syntax|
を参照してください。ここでは基本的なことだけを説明します。

数値と文字列と変数はそれ自体が式です。つまり、式が必要なところでは数値でも文字
列でも変数でも使えます。他にも次のようなものが使えます:

	$NAME		環境変数
	&name		オプション値
	@r		レジスタの内容

例: >

	echo "The value of 'tabstop' is" &ts
	echo "Your home directory is" $HOME
	if @a == 'text'

&name 形式は、オプションの値を設定し、何かを行い、古い値を復元するために使用す
ることもできます。例: >

	var save_ic = &ic
	set noic
	s/The Start/The Beginning/
	&ic = save_ic

'ignorecase' オプションをオフにしてから "The Start" パターンを検索しています。
しかし設定は変更されません。(パターンに "\C" を加える方法でも同じことができま
す。|/\C| 参照。)


☆数値計算

基本的な要素を組み合わせると面白くなってきます。まずは数値計算です:

	a + b		加算
	a - b		減算
	a * b		乗算
	a / b		除算
	a % b		剰余演算(余りを得る)

演算子の優先順位は一般的な規則と同じです: >

	echo 10 + 5 * 2
<	20 ~

カッコを使って優先順位を変更できます: >

	echo (10 + 5) * 2
<	30 ~


☆その他

文字列は ".." で連結できます(|expr6| 参照)。例: >

	echo "Name: " .. name
	Name: Peter

"echo" コマンドに複数の引数を指定すると、スペースで区切られて表示されます。こ
れらの例では一つの式しか使われていないので、スペースは挿入されていません。

連結が気に入らない場合は、波括弧で囲んだ式を受け付ける $"string" 形式を使用す
ることができます: >
	echo $"Name: {name}"

詳細は |interpolated-string| を参照してください。

C 言語と同じ条件演算子も使えます: >

	a ? b : c

"a" が真なら "b" が使われ、そうでなければ "c" が使われます。例: >

	var nr = 4
	echo nr > 5 ? "nr is big" : "nr is small"
<	nr is small ~

被演算子の部分は優先的に評価されるので、次のように見なすことができます: >

	(a) ? (b) : (c)

また Falsy 演算子もあります: >
	echo name ?? "No name given"
|??| を参照してください。

==============================================================================
*41.4*	条件式

`if` コマンドは条件が真の場合に `endif` までのステートメントを実行します。書式
は次のとおり:

	if {condition}
	   {statements}
	endif

{condition} を評価した結果が真あるいは 1 であれば、{statements} の内容が実行さ
れます。{statements} は実行されなくても正しいコマンドである必要があります。不
正な記述があると `endif` にマッチする所までたどり着けません。

`else` を使うこともできます。書式は次のとおり:

	if {condition}
	   {statements}
	else
	   {statements}
	endif

二つ目の {statements} ブロックは条件が偽の場合にだけ実行されます。

最後に、`elseif` を使うこともできます:

	if {condition}
	   {statements}
	elseif {condition}
	   {statements}
	endif

これは `else` に続けて `if` 文を使うのと同じ動作ですが、余計な `endif` を使わ
なくて済みます。

vimrc ファイルで便利に使える例を示しましょう。'term' オプションの値を調べ、そ
の値に応じて処理を分けます: >

	if &term == "xterm"
	  # xterm 用の設定
	elseif &term == "vt100"
	  # vt100 端末用の設定
	else
	  # その他の端末用の設定
	endif

"#" で開始するコメントを使っています、これについては後程詳しく。


☆論理演算子

今までの説明で既に論理演算子を使いました。次の演算子がよく使われます:

	a == b		等しい
	a != b		等しくない
	a >  b		より大きい
	a >= b		より大きいか等しい
	a <  b		より小さい
	a <= b		より小さいか等しい

条件が成立するなら true、そうでなければ false が返ります。例: >

	if v:version >= 800
	  echo "おめでとう"
	else
	  echo "古いバージョンを使っています。更新してね!"
	endif

"v:version" は Vim によって定義されている変数で、Vim のバージョンが入っていま
す。バージョン 8.0 なら 800、バージョン 8.1 なら 801 です。これは複数のバージョ
ンに対応するスクリプトを書くときに便利です。|v:version|。`has()` で特定の機能
や特定のパッチを確認することもできます。|has-patch| を参照してください。

論理演算子は数値でも文字列でも扱えます。文字列どうしを比較するときは数学的な差
が比較されます。文字のバイト値を比較するので、一部の言語では正しい結果にならな
いかもしれません。

文字列と数字を比較した場合はエラーになります。

文字列にはさらに2つの便利な論理演算子があります:

	str =~ pat		パターンにマッチする
	str !~ pat		パターンにマッチしない

左辺の "str" は文字列として扱われます。右辺の "pat" は検索パターンとして扱われ
ます。例: >

	if str =~ " "
	  echo "str にはスペースが含まれている"
	endif
	if str !~ '\.$'
	  echo "str の末尾はピリオドではない"
	endif

パターンにシングルクォート文字列を使用していることに注意してください。これは便
利です。なぜなら、パターンには多くのバックスラッシュが含まれる傾向があり、ダブ
ルクォート文字列ではバックスラッシュを2重にする必要があるためです。

マッチ位置は固定されません。文字列全体を一致させたい場合は、"^" で始めて、"$"
で終わります。

文字列を比較するときは 'ignorecase' オプションが使われません。大文字小文字の区
別なしを明示的に指定したい場合 "?" をつけます。大文字小文字を区別せずに等しい
かどうかを比較したい場合は "==?" を使います。これは大文字小文字を区別せずに2つ
の文字列全体の比較をします。演算子の一覧は |expr-==| を参照してください。


☆他のループコマンド

`while` コマンドは既に説明しました。`while` と `endwhile` の中では二つのス
テートメントが使えます:

	continue		ループの先頭にジャンプしてループを継続する。
	break			`endwile` までジャンプしてループを脱ける。

例: >

	var counter = 1
	while counter < 40
	  if skip_number(counter)
	    continue
	  endif
	  if last_number(counter)
	    break
	  endif
	  sleep 50m
	  ++counter
	endwhile

`sleep` コマンドは Vim を一定時間停止します。"50m" は 50 ミリ秒です。`sleep 4`
なら 4 秒間スリープします。

`for` と `endfor` の間では `continue` と `break` も使えます。
`for` コマンドを使ってループすることもできます。|41.8|を参照。

==============================================================================
*41.5*	式を実行する

今まではコマンドを直接書いてきました。`execute` コマンドを使うと、式の評価結果
をコマンドとして実行できます。これによってコマンドを動的に生成することができま
す。

例えば、変数に格納された文字列を使ってタグジャンプするには次のようにします: >

	execute "tag " .. tag_name

文字列 "tag " と変数 "tag_name" の値を ".." で連結しています。仮に "tag_name"
の値が "get_cmd" だった場合、次のコマンドが実行されることになります: >

	tag get_cmd

`execute` コマンドはExコマンドのみ実行できます。`normal` コマンドでノーマルモー
ドコマンドを実行できますが、このコマンドの引数は文字がそのまま使われ、式として
は評価されません。例: >

	normal gg=G

このコマンドは一行目にジャンプしてから "=" オペレータですべての行を整形します。

`normal` コマンドで式の値を使いたい場合は `execute` と組み合わせてください。
例: >

	execute "normal " .. count .. "j"

これはカーソルを "count" 行下へ移動させます。

`normal` には完結したコマンドを指定するようにしてください。引数の最後まで到達
した段階でコマンドは静かに中断されます。例えば、削除のオペレータを開始した場合
は、移動のコマンドも与えなくてはなりません。次のコマンドは正しく動作します:
>

	normal d$

これは何もしません: >

	normal d

挿入モードを始めて Esc で終了しない場合でも、とにかく終了はします。次のコマン
ドは "new text" を挿入します: >

	execute "normal inew text"

テキストの挿入後に何かしたい場合は挿入モードを終了する必要があります: >

	execute "normal inew text\<Esc>b"

これは "new text" を挿入し単語 "text" の最初の文字の上にカーソルを置きます。注
目すべきは特殊キーの "\<Esc>" です。これはあなたのスクリプト内に実際の <Esc>
文字を入力するのを回避します。そこでダブルクォート文字列での `execute` が役に
立ちます。

文字列をコマンドとして実行するのではなく、その式の結果を得たい場合は、eval()
関数を使います: >

	var optname = "path"
	var optvalue = eval('&' .. optname)

文字 "&" と "path" を連結しているので eval() の引数は "&path" になります。戻り
値は 'path' オプションの値です。

==============================================================================
*41.6*	関数を使う

たくさんの関数があらかじめ定義され、豊富な機能が提供されています。このセクショ
ンの説明にもいくつか登場します。関数の一覧は以下の |function-list| を参照して
ください。

関数は引数をカッコで囲み、それぞれをコンマで区切って呼び出します。例: >

	search("Date: ", "W")

これは "Date: " と "W" を引数にして search() 関数を呼び出しています。search()
関数は一つ目の引数を検索パターンとして使い、二つ目の引数をフラグとして使いま
す。"W" フラグを指定するとファイル末尾で検索が終了します (折り返さない)。

|Vim9| script では、`call` コマンドの使用はオプションです。旧来のスクリプトと
コマンドラインでは必要となります: >

	call search("Date: ", "W")

関数は式の中で使うこともできます。例: >

	var line = getline(".")
	var repl = substitute(line, '\a', "*", "g")
	setline(".", repl)

getline() 関数はカレントバッファから行を取得する関数です。引数には行番号を指定
します。この例では "." ですが、これはカーソルのある行を示します。

substitute() 関数は `:substitute` コマンドとほぼ同じです。最初の引数 "line" は
置換対象の文字列、二つ目の引数 '\a' はパターン、三つ目の引数 "*" は置き換え文
字列、最後の引数は "g" はフラグです。

setline() 関数は行の内容を置き換えます。最初の引数は行番号、二つ目の引数は置き
換える文字列です。この例では、substitute() の結果で現在行を置き換えています。
上記の三行のコマンドは次のコマンドと同じことをしています: >

	:substitute/\a/*/g

substitute() の呼び出しの前後にいろいろな処理を入れたりするときに、関数を使え
ば面白いことができるようになります。


☆関数一覧						*function-list*

たくさんの関数があります。ここでは機能別に分類して紹介します。アルファベット順
の一覧は |builtin-function-list| を参照してください。関数名の上で CTRL-] を押
すと、詳細な説明にジャンプできます。

文字列繰作:						*string-functions*
	nr2char()		数値から文字を得る
	list2str()		数値のリストから文字列を得る
	char2nr()		文字の数値を得る
	str2list()		文字列から数値のリストを得る
	str2nr()		文字列を数値に変換する
	str2float()		文字列を浮動小数点数に変換する
	printf()		書式付き文字列を整形する
	escape()		文字列の特定の文字を '\' でエスケープ
	shellescape()		シェルコマンドで使えるように文字列をエスケープ
	fnameescape()		Vim コマンド用にファイル名をエスケープ
	tr()			ある文字の集合から別の文字の集合へ置換する
	strtrans()		文字列を印字可能な状態とする
	keytrans()		内部キーコードから |:map| で使用可能な表記にす
				る
	tolower()		文字列を小文字にする
	toupper()		文字列を大文字にする
	charclass()		文字のクラス
	match()			文字列の中でパターンにマッチした位置
	matchbufline()		バッファ内のパターンのすべてのマッチ
	matchend()		文字列の中でパターンにマッチした末尾の位置
	matchfuzzy()		リスト内の文字列についてファジーマッチした文字列
	matchfuzzypos()		リスト内の文字列についてファジーマッチした文字列
	matchstr()		文字列の中でパターンにマッチした文字列
	matchstrlist()		文字列のリスト内のパターンにマッチするすべての
				文字列
	matchstrpos()		文字列の中でパターンにマッチした文字列と位置
	matchlist()		matchstr()と同様だが、部分マッチも返す
	stridx()		文字列の中で部分文字列が見つかった最初の位置
	strridx()		文字列の中で部分文字列が見つかった最後の位置
	strlen()		文字列のバイト単位での長さ
	strcharlen()		文字列の文字単位での長さ
	strchars()		文字列内の文字数
	strutf16len()		文字列内の UTF-16 コード単位の数
	strwidth()		表示された文字列のサイズ
	strdisplaywidth()	表示された文字列のサイズ、タブを扱う
	setcellwidths()		文字の幅の上書き設定
	getcellwidths()		文字の幅の上書き設定値を取得する
	getcellpixels()		文字のセルのピクセルサイズを得る
	reverse()		文字列内の文字の順序を逆にする
	substitute()		パターンにマッチする文字列を置換
	submatch()		":s" と substitute() の中で部分マッチを得る
	strpart()		文字列の一部分を得る(バイト数指定)
	strcharpart()		文字のインデックスで指定された部分文字列を得る
	slice()			Vim9 script での文字インデックスを用いて、文字
				列のスライスを取る
	strgetchar()		文字のインデックスで指定された文字コードを得る
	expand()		特殊キーワードを展開する
	expandcmd()		`:edit` のようにコマンドを展開する
	iconv()			テキストのエンコーディングを変換する
	byteidx()		文字列中の文字のバイトインデックス
	byteidxcomp()		byteidx() と同様だが合成文字を数に入れる
	charidx()		文字列中のバイト値の文字インデックス
	utf16idx()		文字列内のバイトの UTF-16 インデックス
	repeat()		文字列を複数回繰り返す
	eval()			文字列を式として評価する
	execute()		Ex コマンドを実行し出力を得る
	win_execute()		execute() に似ているが指定ウィンドウで実行する
	trim()			文字列から文字を取り除く
	bindtextdomain()	メッセージの翻訳検索のベースパスを設定する
	gettext()		翻訳メッセージの検索
	ngettext()		単一/複数の翻訳メッセージのの検索
	str2blob()		文字列のリストを blob に変換する
	blob2str()		blob を文字列のリストに変換する

リスト操作:						*list-functions*
	get()			要素を取得。存在しないインデックスでもエラーを
				出さない
	len()			リスト中の要素の個数
	empty()			リストが空であるか判定する
	insert()		リストの任意の位置に要素を挿入する
	add()			リストに要素を追加する
	extend()		リストにリストを連結する
	extendnew()		あるリストとリストを結合して新しいリストを作成
				する
	remove()		リストから1個以上の要素を取り除く
	copy()			リストの浅いコピーを作成する
	deepcopy()		リストの完全なコピーを作成する
	filter()		リストから選択された要素を取り除く
	map()			リストの各要素を変換する
	mapnew()		変換した要素で新しいリストを作成する
	foreach()		リスト項目に関数を適用する
	reduce()		リストの畳み込みの値を算出する
	slice()			リストのスライスを取る
	sort()			リストをソートする
	reverse()		リスト内の要素の並び順を反転させる
	uniq()			隣接して繰り返される要素のコピーを削除する
	split()			文字列を分割し、リストにする
	join()			リストの要素を連結し、文字列にする
	range()			数列リストを返す
	string()		リストの文字列表現
	call()			リストを引数として関数を呼ぶ
	index()			リストあるいは Blob 中の要素のインデックス
	indexof()		リストあるいは Blob で式の評価が真となった位置
				のインデックス
	max()			リスト中の最大値
	min()			リスト中の最小値
	count()			ある要素がリスト中に出現する回数を返す
	repeat()		リストを複数回繰り返す
	flatten()		リストの平坦化
	flattennew()		リストのコピーを平坦化
	items()			リストのインデックスと値のペアのリストを取得す
				る

Tuple 操作:						*tuple-functions*
	copy()			Tuple の浅いコピーを作成する
	count()			Tuple 内で値が出現する回数を返す
	deepcopy()		Tuple の完全なコピーを作成する
	empty()			Tuple が空であるか判定する
	foreach()		Tuple の項目に関数を適用する
	get()			Tuple の項目を取得。間違ったインデックスでもエ
				ラーにならない
	index()			Tuple 内の値のインデックス
	indexof()		Tuple で式の評価が真となった位置のインデックス
	items()			Tuple のインデックスと値のペアのリストを取得す
				る
	join()			Tuple の項目を連結し、文字列にする
	len()			Tuple 中の項目の個数
	list2tuple()		項目のリストを Tuple に変換する
	max()			Tuple 中の最大値
	min()			Tuple 中の最小値
	reduce()		Tuple を値に縮める
	repeat()		Tuple を複数回繰り返す
	reverse()		Tuple 内の項目の並び順を反転させる
	slice()			Tuple のスライスを取る
	string()		Tuple の文字列表現
	tuple2list()		Tuple をリストに変換する

辞書操作:						*dict-functions*
	get()			辞書の要素を返す。存在しないキーでもエラーを出
				さない
	len()			辞書の要素の個数
	has_key()		あるキーが辞書に含まれているか判定する
	empty()			辞書が空であるか判定する
	remove()		辞書から要素を取り除く
	extend()		ある辞書の要素をすべて別の辞書に追加する
	extendnew()		ある辞書の要素と別の辞書を合せて新しい辞書を作
				成する
	filter()		辞書から選択された要素を取り除く
	map()			辞書の各要素を変換する
	mapnew()		変換した要素で新しい辞書を作成する
	foreach()		辞書項目に関数を適用する
	keys()			辞書の全キーのリストを取得する
	values()		辞書の全値のリストを取得する
	items()			辞書の全キー・値のペアを取得する
	copy()			辞書の浅いコピーを作成する
	deepcopy()		辞書の完全なコピーを作成する
	string()		辞書の文字列表現
	max()			辞書中の最大値
	min()			辞書中の最小値
	count()			ある値が出現する回数を返す

浮動小数点数の計算:					*float-functions*
	float2nr()		Float を Number に変換
	abs()			絶対値 (Numberも処理可能)
	round()			丸め
	ceil()			切り上げ
	floor()			切り下げ
	trunc()			小数点以下切り捨て
	fmod()			除法の余り
	exp()			指数
	log()			自然対数 (eを底とする対数)
	log10()			10 を底とする対数
	pow()			x の y 乗
	sqrt()			平方根
	sin()			正弦 (サイン)
	cos()			余弦 (コサイン)
	tan()			正接 (タンジェント)
	asin()			逆正弦 (アークサイン)
	acos()			逆余弦 (アークコサイン)
	atan()			逆正接 (アークタンジェント)
	atan2()			逆正接 (アークタンジェント)
	sinh()			双曲線正弦 (ハイパボリックサイン)
	cosh()			双曲線余弦 (ハイパボリックコサイン)
	tanh()			双曲線正接 (ハイパボリックタンジェント)
	isinf()			無限大かのチェック
	isnan()			数値でないかどうかのチェック

Blob 操作:						*blob-functions*
	blob2list()		blobから数値のリストを取得する
	list2blob()		数値のリストからblobを取得する
	reverse()		blob 内の数値の順序を逆にする

その他の計算:						*bitwise-function*
	and()			ビットごとの論理積
	invert()		ビットごとの否定
	or()			ビットごとの論理和
	xor()			ビットごとの排他的論理和
	sha256()		SHA-256 ハッシュ
	rand()			疑似乱数を得る
	srand()			rand() を使うためのシード値の初期化

変数:							*var-functions*
	instanceof()		変数が指定されたクラスのインスタンスであるかど
				うかを確認する
	type()			数値による変数の型
	typename()		テキストによる変数の型
	islocked()		変数がロックされているか判定する
	funcref()		関数参照へのFuncrefを取得する
	function()		関数名からFuncrefを取得する
	getbufvar()		指定バッファの変数値を得る
	setbufvar()		指定バッファに変数を設定する
	getwinvar()		指定ウィンドウの変数値を得る
	gettabvar()		指定タブページから変数値を得る
	gettabwinvar()		指定ウィンドウ・タブページから変数値を取得する
	setwinvar()		指定ウィンドウに変数を設定する
	settabvar()		指定タブページに変数を設定する
	settabwinvar()		指定ウィンドウ・タブページに変数を設定する
	garbagecollect()	解放可能なメモリを解放する

カーソルとマークの位置:			*cursor-functions* *mark-functions*
	col()			カーソルやマークの列番号を取得する
	virtcol()		カーソルやマークの画面上の列番号を得る
	line()			カーソルやマークの行番号を取得する
	wincol()		カーソルのウィンドウでの列番号
	winline()		カーソルのウィンドウでの行番号
	cursor()		カーソルを指定した位置に移動させる
	screencol()		カーソルのスクリーン列を取得する
	screenrow()		カーソルのスクリーン行を取得する
	screenpos()		テキスト文字のスクリーン行と列
	virtcol2col()		テキスト文字のスクリーンのバイト位置
	getcurpos()		カーソルの位置を取得する
	getpos()		カーソルやマークなどの位置を取得する
	setpos()		カーソルやマークなどの位置を設定する
	getmarklist()		グローバル/ローカルのマークのリスト
	byte2line()		指定のバイト位置の行番号を取得する
	line2byte()		指定の行のバイト位置を取得する
	diff_filler()		ある行より上の詰め行の数を取得する
	screenattr()		スクリーン列/行の属性を取得する
	screenchar()		スクリーン列/行の文字コードを取得する
	screenchars()		スクリーン列/行の文字コードのリストを取得する
	screenstring()		スクリーン列/行の文字列を取得する
	charcol()		カーソルもしくはマークにある文字の数値
	getcharpos()		カーソル、マーク、その他の位置の文字の取得
	setcharpos()		カーソル、マーク、その他の位置の文字の設定
	getcursorcharpos()	カーソル位置の文字の取得
	setcursorcharpos()	カーソル位置の文字の設定

カレントバッファで動作するもの:				*text-functions*
	getline()		バッファから行を得る
	getregion()		バッファからテキストの領域を得る
	getregionpos()		領域の位置のリストを得る
	setline()		バッファの行を置き換える
	append()		行または行のリストをバッファに追加する
	indent()		行のインデントを得る
	cindent()		C 言語におけるインデントを得る
	lispindent()		Lisp 言語におけるインデントを得る
	nextnonblank()		次の非空行を探す
	prevnonblank()		前の非空行を探す
	search()		パターンにマッチする場所を探す
	searchpos()		パターンにマッチする場所を探す
	searchcount()		カーソルの前後でマッチした数を得る
	searchpair()		start/skip/end の対を探す
	searchpairpos()		start/skip/end の対を探す
	searchdecl()		名前が宣言されている場所を探す
	getcharsearch()		文字検索情報を返す
	setcharsearch()		文字検索情報を設定する

他のバッファのテキストで動作するもの:
	getbufline()		指定したバッファから行のリストを得る
	getbufoneline()		指定したバッファから1行を得る
	setbufline()		指定したバッファ内の行を置き換える
	appendbufline()		指定したバッファに行のリストを追加する
	deletebufline()		指定したバッファから行を削除する

					*system-functions* *file-functions*
システム関数とファイル繰作:
	glob()			ワイルドカードを展開する
	globpath()		複数のディレクトリを対象にワイルドカードを展開
	glob2regpat()		glob パターンを正規表現に変換する
	findfile()		複数のディレクトリからファイルを探す
	finddir()		複数のディレクトリからディレクトリを探す
	resolve()		ショートカットのリンク先を得る
	fnamemodify()		ファイル名を修飾する
	pathshorten()		パス中のディレクトリ名を短くする
	simplify()		パスの意味を変えずに簡略化する
	executable()		実行形式ファイルかどうかをチェックする
	exepath()		実行可能ファイルのフルパスを得る
	filereadable()		ファイルが読み込み可能かどうかをチェックする
	filewritable()		ファイルが書き込み可能かどうかをチェックする
	getfperm()		ファイルのパーミッションを得る
	setfperm()		ファイルのパーミッションを設定する
	getftype()		ファイルの種類を得る
	isabsolutepath()	絶対パスであるかチェックする
	isdirectory()		ディレクトリの存在をチェックする
	getfsize()		ファイルのサイズを得る
	getcwd()		カレントディレクトリを得る
	haslocaldir()		カレントウィンドウが |:lcd| または |:tcd| を使
				用したかどうかをチェックする
	tempname()		一時ファイルの名前を得る
	mkdir()			ディレクトリを作成する
	chdir()			現在の作業ディレクトリを変更する
	delete()		ファイルを削除する
	rename()		ファイルの名前を変更する
	system()		シェルコマンドを実行し、その結果を文字列で得る
	systemlist()		シェルコマンドを実行し、その結果をリストで得る
	environ()		すべての環境変数を得る
	getenv()		環境変数を得る
	setenv()		環境変数を設定する
	hostname()		システムの名称を得る
	readfile()		ファイルを読み込み、行のリストを得る
	readblob()		ファイルを読み込み、Blobに格納する
	readdir()		ディレクトリ内のファイル名のリストを得る
	readdirex()		ディレクトリ内のファイル情報のリストを得る
	writefile()		行のリストまたは Blob をファイルに書き込む
	filecopy()		ファイル {from} を {to} へコピーする

日付と時刻:				*date-functions* *time-functions*
	getftime()		ファイルの最終更新日時を得る
	localtime()		現在時刻を秒単位で得る
	strftime()		時刻を文字列に変換する
	strptime()		日付/時刻の文字列を時刻に変換する
	reltime()		現在時刻または経過時間を正確に取得する
	reltimestr()		reltime()の結果を文字列に変換する
	reltimefloat()		reltime()の結果を浮動小数点に変換する

自動コマンド:					*autocmd-functions*
	autocmd_add()		自動コマンドとグループのリストを追加する
	autocmd_delete()	自動コマンドとグループのリストを削除する
	autocmd_get()		自動コマンドのリストを返す

			*buffer-functions* *window-functions* *arg-functions*
バッファ、ウィンドウ、引数リスト:
	argc()			引数リストの大きさ
	argidx()		引数リスト中の現在の位置
	arglistid()		引数リストのIDを得る
	argv()			引数リストの中身を得る
	bufadd()		バッファのリストにファイルを追加する
	bufexists()		バッファの存在をチェックする
	buflisted()		バッファが存在し、リストされているかどうか
	bufload()		バッファがロードされていることを保証する
	bufloaded()		バッファが存在し、ロードされているかどうか
	bufname()		バッファの名前を得る
	bufnr()			バッファの番号を得る
	tabpagebuflist()	タブページ中のバッファのリストを返す
	tabpagenr()		タブページの番号を取得する
	tabpagewinnr()		タブページを対象にwinnr()と同様
	winnr()			カレントウィンドウの番号を得る
	bufwinid()		バッファのウィンドウIDを得る
	bufwinnr()		バッファのウィンドウ番号を得る
	winbufnr()		ウィンドウのバッファ番号を得る
	listener_add()		変更を監視するためのコールバックを追加する
	listener_flush()	リスナーコールバックを呼び出す
	listener_remove()	リスナーコールバックを削除する
	win_findbuf()		バッファが含まれるウィンドウを探す
	win_getid()		ウィンドウのウィンドウIDを得る
	win_gettype()		ウィンドウの種別を得る
	win_gotoid()		IDで指定されたウィンドウへ移動する
	win_id2tabwin()		IDで指定されたタブとウィンドウの番号を得る
	win_id2win()		IDで指定されたウィンドウの番号を得る
	win_move_separator()	ウィンドウの垂直セパレータの移動
	win_move_statusline()	ウィンドウのステータス行の移動
	win_splitmove()		分割したもう片方へウィンドウを移動する
	getbufinfo()		バッファの情報一覧を得る
	gettabinfo()		タブページの情報一覧を得る
	getwininfo()		ウィンドウの情報一覧を得る
	getchangelist()		変更リストのエントリ一覧を得る
	getjumplist()		ジャンプリストのエントリ一覧を得る
	swapfilelist()		'directory' に存在するスワップファイルのリスト
	swapinfo()		スワップファイルの情報を得る
	swapname()		バッファのスワップファイルパスを得る

コマンドライン:					*command-line-functions*
	getcmdcomplpat()	現在のコマンドラインの補完パターンを取得
	getcmdcompltype()	現在のコマンドライン補完の種別を取得
	getcmdline()		現在のコマンドライン入力を取得
	getcmdprompt()		現在のコマンドラインプロンプトを取得
	getcmdpos()		コマンドラインにおけるカーソル位置を取得
	getcmdscreenpos()	コマンドラインでのカーソルの画面位置を取得
	setcmdline()		現在のコマンドラインを設定
	setcmdpos()		コマンドラインにおけるカーソル位置を設定
	getcmdtype()		現在のコマンドラインの種類を返す
	getcmdwintype()		現在のコマンドラインウィンドウの種類を返す
	getcompletion()		マッチするコマンド補完リストを返す
	fullcommand()		完全なコマンド名の取得
	cmdcomplete_info()	コマンドラインの補完情報を取得

Quickfixとlocationリスト:			*quickfix-functions*
	getqflist()		quickfixエラーのリスト
	setqflist()		quickfixを変更する
	getloclist()		locationリストの項目のリスト
	setloclist()		locationリストを変更する

挿入モード補完:					*completion-functions*
	complete()		補完候補を設定する
	complete_add()		補完候補を追加する
	complete_check()	補完処理を終えるべきかどうかをチェックする
	complete_info()		現在の補完情報を得る
	complete_match()	挿入モードの補完の開始マッチ桁とトリガーテキス
				トを取得する
	pumvisible()		ポップアップメニューが表示されているかチェック
	pum_getpos()		表示されているポップアップメニューの位置とサイ
				ズを得る

折り畳み:					*folding-functions*
	foldclosed()		行が折り畳まれているかどうかをチェックする
	foldclosedend()		foldclosed()と同様。折り畳み末尾の行番号を返す
	foldlevel()		行の折り畳みレベルを得る
	foldtext()		閉じた折り畳みを代替表示するテキストを生成
	foldtextresult()	閉じた折り畳みを代替表示するテキストを得る

シンタックスハイライト:		  *syntax-functions* *highlighting-functions*
	clearmatches()		|matchadd()|と|:match|コマンドで定義されたマッ
				チをクリアする
	getmatches()		|matchadd()|と|:match|コマンドで定義されたすべ
				てのマッチを得る
	hlexists()		ハイライトグループの存在をチェック
	hlget()			ハイライトグループの属性を取得する
	hlset()			ハイライトグループの属性を設定する
	hlID()			ハイライトグループのIDを得る
	synID()			指定位置のシンタックスIDを得る
	synIDattr()		シンタックスIDから指定の属性を得る
	synIDtrans()		変換したシンタックスIDを得る
	synstack()		指定位置のシンタックスIDのリストを得る
	synconcealed()		(構文の) conceal の情報を得る
	diff_hlID()		差分モードの指定位置のシンタックスIDを得る
	matchadd()		強調表示するパターンを定義する
	matchaddpos()		強調表示する位置のリストを定義する
	matcharg()		|:match|の引数の情報を得る
	matchdelete()		|matchadd()|と|:match|コマンドで定義されたマッ
				チを削除する
	setmatches()		|getmatches()|で得たマッチを使って復元する

スペリング:					*spell-functions*
	spellbadword()		カーソル位置以降のスペルミスを探す
	spellsuggest()		スペル訂正の候補を返す
	soundfold()		単語の同音等値(sound-a-like equivalent)を返す

履歴:						*history-functions*
	histadd()		履歴に項目を追加
	histdel()		履歴から項目を削除
	histget()		履歴の項目を得る
	histnr()		履歴リストの最大インデックスを得る

対話インターフェイス:				*interactive-functions*
	browse()		ファイル選択ダイアログを開く
	browsedir()		ディレクトリ選択ダイアログを開く
	confirm()		ユーザーに選択をさせる
	getchar()		ユーザーが入力した文字を得る
	getcharstr()		ユーザーが入力した文字を文字列として得る
	getcharmod()		最後に入力した文字の修飾子(modifier)を得る
	getmousepos()		最後に取得したマウスの位置を得る
	getmouseshape()		現在のマウスカーソル形状名を得る
	echoraw()		文字をそのまま出力する
	feedkeys()		先行入力キューに文字を入れる
	input()			ユーザーが入力した行を得る
	inputlist()		ユーザーにリストから項目を選択させる
	inputsecret()		ユーザーが入力した行を得る。ただし表示はしない
	inputdialog()		ダイアログを使ってユーザーが入力した行を得る
	inputsave()		先行入力キューを保存して空にする
	inputrestore()		inputsave()で保存した状態に戻す

GUI:						*gui-functions*
	getfontname()		現在使われているフォントの名前を取得
	getwinpos()		Vimウィンドウの座標
	getwinposx()		VimウィンドウのX座標
	getwinposy()		VimウィンドウのY座標
	balloon_show()		バルーンの内容を設定する
	balloon_split()		バルーン用にメッセージを分割する
	balloon_gettext()	バルーンのテキストを得る

Vimサーバー:					*server-functions*
	serverlist()		サーバー名のリストを返す
	remote_startserver()	サーバーをスタートする
	remote_send()		Vimサーバーにコマンド文字を送る
	remote_expr()		Vimサーバーで式を評価する
	server2client()		Vimサーバーのクライアントに応答を返す
	remote_peek()		Vimサーバーから返信があったかどうかをチェック
	remote_read()		Vimサーバーからの返信を読む
	foreground()		Vimのウィンドウを前面に持ってくる
	remote_foreground()	Vimサーバーのウィンドウを前面に持ってくる

ウィンドウサイズと位置:				*window-size-functions*
	winheight()		ウィンドウの高さを取得
	winwidth()		ウィンドウの幅を取得
	win_screenpos()		ウィンドウのスクリーン座標を取得
	winlayout()		タブページ内のウィンドウ配置を取得
	winrestcmd()		ウィンドウサイズを復元するコマンドを返す
	winsaveview()		カレントウィンドウのビューを取得
	winrestview()		カレントウィンドウのビューを復元

マッピングとメニュー:				*mapping-functions*
	digraph_get()		|digraph| の取得
	digraph_getlist()	全 |digraph| の取得
	digraph_set()		|digraph| の登録
	digraph_setlist()	複数 |digraph| の登録
	hasmapto()		マップの存在をチェック
	mapcheck()		マッチするマップの存在をチェック
	maparg()		マップのrhs(展開結果)を得る
	maplist()		全マップのリストを得る
	mapset()		マップを復元
	menu_info()		メニュー項目の情報を取得
	wildmenumode()		wildmodeが有効かどうかをチェック

テスト用:					*test-functions*
	assert_equal()		2つの式が等しい事をテストする
	assert_equalfile()	2つのファイルの内容が等しい事をテストする
	assert_notequal()	2つの式が等しくない事をテストする
	assert_inrange()	式が範囲内にある事をテストする
	assert_match()		値がパターンにマッチする事をテストする
	assert_notmatch()	値がパターンにマッチしない事をテストする
	assert_false()		式がfalseかどうかテストする
	assert_true()		式がtrueかどうかテストする
	assert_exception()	コマンドが例外を投げる事をテストする
	assert_beeps()		コマンドがビープ音を鳴らすことをテストする
	assert_nobeep()		コマンドがビープ音を鳴らさないことをテストする
	assert_fails()		コマンドが失敗する事をテストする
	assert_report()		テストの失敗をレポートする
	test_alloc_fail()	メモリの確保を失敗させる
	test_autochdir()	起動中に 'autochdir' を有効にする
	test_override()		Vimの内部処理を置き換えてテストする
	test_garbagecollect_now()   直ちにメモリを解放する
	test_garbagecollect_soon()  メモリを解放のフラグを設定する
	test_getvalue()		内部変数の値を取得する
	test_gui_event()	テスト用の GUI イベントを生成する
	test_ignore_error()	特定のエラーメッセージを無視する
	test_mswin_event()	MS-Windows のイベントを生成
	test_null_blob()	null の Blob を返す
	test_null_channel()	null のチャネルを返す
	test_null_dict()	null の辞書を返す
	test_null_function()	null の Funcref を返す
	test_null_job()		null の Job を返す
	test_null_list()	null のリストを返す
	test_null_partial()	null の部分適用を返す
	test_null_string()	null の文字列を返す
	test_null_tuple()	null の Tuple を返す
	test_settime()		Vimが内部的に用いる時間を設定する
	test_setmouse()		マウスの位置を設定する
	test_feedinput()	インプットバッファにキーシーケンスを追加する
	test_option_not_set()	オプションが設定されていることを示すフラグをリ
				セットする
	test_refcount()		式の参照カウントを返す
	test_srand_seed()	srand() のテスト用の種を設定する
	test_unknown()		unknown 型の値を返す
	test_void()		void 型の値を返す

プロセス間通信:					*channel-functions*
	ch_canread()		何か読むものがあるかチェックする
	ch_open()		チャネルを開く
	ch_close()		チャネルを閉じる
	ch_close_in()		チャネルの入力パートを閉じる
	ch_read()		チャネルからメッセージを読み取る
	ch_readblob()		チャネルから Blob を読み取る
	ch_readraw()		チャネルからrawメッセージを読み取る
	ch_sendexpr()		チャネルにJSONメッセージを送る
	ch_sendraw()		チャネルにrawメッセージを送る
	ch_evalexpr()		チャネル経由で式を評価する
	ch_evalraw()		チャネル経由で raw 文字列を評価する
	ch_status()		チャネルの状態を取得する
	ch_getbufnr()		チャネルのバッファ番号を取得する
	ch_getjob()		チャネルが割り当てられている Job を取得する
	ch_info()		チャネルの情報を取得する
	ch_log()		チャネルのログファイルにメッセージを出力する
	ch_logfile()		チャネルのログファイルを設定する
	ch_setoptions()		チャネルのオプションを設定する
	json_encode()		式をJSONの文字列にエンコードする
	json_decode()		JSONの文字列をVimの型にデコードする
	js_encode()		式をJSONの文字列にエンコードする
	js_decode()		JSONの文字列をVimの型にデコードする
	base64_encode()		blob を base64 文字列にエンコードする
	base64_decode()		base64 文字列を blob にデコードする
	err_teapot()		エラー 418 または 503 を与える

ジョブ:						*job-functions*
	job_start()		Job を開始する
	job_stop()		Job を停止する
	job_status()		Job のステータスを取得する
	job_getchannel()	Job が使用する channel を取得する
	job_info()		Job の情報を取得する
	job_setoptions()	Job のオプションを設定する

目印:						*sign-functions*
	sign_define()		目印を定義または更新する
	sign_getdefined()	定義されている目印のリストを取得する
	sign_getplaced()	設置されている目印のリストを取得する
	sign_jump()		目印へ移動する
	sign_place()		目印を設置する
	sign_placelist()	目印のリストを設置する
	sign_undefine()		定義された目印を削除する
	sign_unplace()		設置された目印を解除する
	sign_unplacelist()	設置された目印のリストを解除する

端末ウィンドウ:					*terminal-functions*
	term_start()		端末ウィンドウを開いてジョブを開始する
	term_list()		端末バッファのリストを取得する
	term_sendkeys()		端末にキーストロークを送る
	term_wait()		スクリーンがアップデートされるのを待つ
	term_getjob()		端末に関連するジョブを取得する
	term_scrape()		端末スクリーンの列を取得する
	term_getline()		端末からテキストの行を取得する
	term_getattr()		{what} の属性値を取得する
	term_getcursor()	端末のカーソル位置を取得する
	term_getscrolled()	端末のスクロール数を取得する
	term_getaltscreen()	代替のスクリーンフラグを取得する
	term_getsize()		端末のサイズを取得する
	term_getstatus()	端末のステータスを取得する
	term_gettitle()		端末のタイトルを取得する
	term_gettty()		端末の tty 名を取得する
	term_setansicolors()	GUI で使用される 16 色の ANSI カラーパレットを
				設定する
	term_getansicolors()	GUI で使用される 16 色の ANSI カラーパレットを
				取得する
	term_dumpdiff()		2つの画面ダンプ間の差分を表示する
	term_dumpload()		ウィンドウに端末スクリーンダンプを読み込む
	term_dumpwrite()	端末スクリーンの内容をファイルにダンプする
	term_setkill()		端末内のジョブを停止するシグナルを設定する
	term_setrestore()	端末を復元させるためのコマンドを設定する
	term_setsize()		端末のサイズを設定する
	term_setapi()		端末の JSON API 関数名のプリフィックスを設定す
				る

ポップアップウィンドウ:				*popup-window-functions*
	popup_create()		画面中央にポップアップを作成する
	popup_atcursor()	カーソル位置のすぐ上にポップアップを作成する、
				カーソルが離れると閉じる
	popup_beval()		v:beval_ 変数によって示される位置、
				マウスが離れると閉じる
	popup_notification()	3秒間通知を表示する
	popup_dialog()		パディングとボーダー付きで中央にポップアップを
				作成する
	popup_menu()		リストから項目を選択するためのプロンプト
	popup_hide()		ポップアップを一時的に隠す
	popup_show()		以前に隠されたポップアップを表示する
	popup_move()		ポップアップの位置とサイズを変更する
	popup_setoptions()	ポップアップのオプションを上書きする
	popup_settext()		ポップアップバッファの内容を置き換える
	popup_setbuf()		ポップアップバッファを設定する
	popup_close()		1つのポップアップを閉じる
	popup_clear()		全てのポップアップを閉じる
	popup_filter_menu()	リストの項目から選択する
	popup_filter_yesno()	'y' か 'n' が押されるまでブロックする
	popup_getoptions()	ポップアップの現在のオプションを取得する
	popup_getpos()		ポップアップの実際の位置とサイズを取得する
	popup_findecho()	`:echowindow` で使用しているポップアップのウィ
				ンドウIDを取得
	popup_findinfo()	ポップアップ情報ウィンドウのウィンドウIDを取得
				する
	popup_findpreview()	ポップアッププレビューウィンドウのウィンドウID
				を取得する
	popup_list()		全ポップアップのウィンドウIDのリストを取得する
	popup_locate()		スクリーン上の指定の位置にあるポップアップの
				ウィンドウIDを取得する

Registers:					*register-functions*
	getreg()		レジスタの値を得る
	getreginfo()		レジスタの情報を得る
	getregtype()		レジスタのタイプを得る
	setreg()		レジスタの値を設定する
	reg_executing()		実行中のレジスタ名を返す
	reg_recording()		記録中のレジスタ名を返す

タイマー:					*timer-functions*
	timer_start()		タイマーを作る
	timer_pause()		タイマーを一時停止もしくは再開する
	timer_stop()		タイマーを止める
	timer_stopall()		全てのタイマーを止める
	timer_info()		タイマーの情報を得る
タグ:						*tag-functions*
	taglist()		マッチするタグのリストを取得する
	tagfiles()		タグファイルのリストを取得する
	gettagstack()		ウィンドウのタグスタックを取得する
	settagstack()		ウィンドウのタグスタックを変更する

プロンプトバッファ:				*promptbuffer-functions*
	prompt_getprompt()	バッファで使われているプロンプトテキストを取得
				する
	prompt_setcallback()	バッファのプロンプトコールバックを設定する
	prompt_setinterrupt()	バッファの割り込みコールバックを設定する
	prompt_setprompt()	バッファのプロンプトテキストを設定する

テキストプロパティ:				*text-property-functions*
	prop_add()		指定位置にプロパティを付加する
	prop_add_list()		複数の指定位置にプロパティを付加する
	prop_clear()		指定行からプロパティをすべて削除する
	prop_find()		プロパティを検索する
	prop_list()		指定行のすべてのプロパティのリストを返す
	prop_remove()		指定行からプロパティを削除する
	prop_type_add()		プロパティタイプの追加/定義
	prop_type_change()	プロパティタイプの変更
	prop_type_delete()	テキストのプロパティタイプの削除
	prop_type_get()		プロパティタイプのプロパティを返す
	prop_type_list()	すべてのプロパティタイプをリストで返す

サウンド:					*sound-functions*
	sound_clear()		再生している全サウンドを停止する
	sound_playevent()	イベントサウンドを再生する
	sound_playfile()	サウンドファイルを再生する
	sound_stop()		サウンドの再生を停止する

その他:						*various-functions*
	mode()			現在の編集モードを得る
	state()			現在のビジー状態を得る
	visualmode()		最後に使われたビジュアルモードの種類
	exists()		変数、関数の存在をチェック
	exists_compiled()	exists() と同様だが、コンパイル時にチェック
	has()			機能がサポートされているかをチェック
	changenr()		最近の変更番号を返す
	cscope_connection()	cscope接続をチェック
	did_filetype()		FileType自動コマンドが使用されたかどうか
	diff()			2 つの文字列のリストの差分
	eventhandler()		イベントハンドラによって起動されたかどうか
	getcellpixels()		セルのピクセルサイズのリストを取得
	getpid()		Vim のプロセスIDを得る
	getscriptinfo()		読み込んだ Vim script のリストを取得
	getstacktrace()		Vim script の現在のスタックトレースを取得する
	getimstatus()		IME のステータスがアクティブかをチェック
	interrupt()		スクリプトの実行を中断する
	windowsversion()	MS-Windows バージョンの取得
	terminalprops()		端末の属性

	libcall()		外部ライブラリの関数を呼ぶ
	libcallnr()		同上、数値を返す

	undofile()		アンドゥファイルの名前を得る
	undotree()		バッファのアンドゥツリーの状態を返す

	shiftwidth()		'shiftwidth' の実際の値

	wordcount()		バッファ内のバイト数/単語数/文字数などを得る

	id()			キーとして使用するための項目の一意の文字列を得
				る

	luaeval()		|Lua|の式を評価する
	mzeval()		|MzScheme| の式を評価する
	perleval()		|Perl|の式を評価する (|+perl|)
	py3eval()		|Python|の式を評価する (|+python3|)
	pyeval()		|Python|の式を評価する (|+python|)
	pyxeval()		|python_x| の式を評価する
	rubyeval()		|Ruby| の式を評価する

	debugbreak()		デバッグ中のプログラムを中断する

==============================================================================
*41.7*	関数を定義する

自分で関数を定義することができます。基本的な関数定義は次のとおり: >

	def {name}({var1}, {var2}, ...): return-type
	  {body}
	enddef
<
	Note:
	関数名は大文字で開始する必要があります。

小さな関数を定義してみましょう。二つの数値のうち小さい方を返す関数を作ります。
関数は次のような行で始まります: >

	def Min(num1: number, num2: number): number

これは、関数が "Min" という名前で、数値である2つの引数: "num1" と "num2" を取
り、数値を返すことを Vim に伝えています。

最初にしなければならないのは、どちらの数値が小さいかをチェックすることです: >

	if num1 < num2

小さい方の値を変数 "smaller" に代入しましょう: >

	var smaller: number
	if num1 < num2
	  smaller = num1
	else
	  smaller = num2
	endif

変数 "smaller" はローカル変数です。これは Vim が何らかの間違いを警告できるよう
に、数値であると宣言されています。関数内で使用される変数は、"g:", "w:" または
"b:" のようなものが付いていない限りローカルです。

	Note:
	関数の内からグローバル変数にアクセスするには "g:" を付ける必要がありま
	す。つまり、関数内では "g:today" はグローバル変数 "today" を示し、
	"today" ならそれとは別の変数、すなわち関数もしくはスクリプトにローカル
	な変数になります。

`return` ステートメントを使って、小さい方の値を呼び出し元に返しましょう。そし
て、関数を閉じます: >

	  return smaller
	enddef

関数定義の全体は次のようになります: >

	def Min(num1: number, num2: number): number
	  var smaller: number
	  if num1 < num2
	    smaller = num1
	  else
	    smaller = num2
	  endif
	  return smaller
	enddef

この例は明かに冗長です。2つの return コマンドを使うことで短くできます: >

	def Min(num1: number, num2: number): number
	  if num1 < num2
	    return num1
	  endif
	  return num2
	enddef

そしてあなたが条件演算子を覚えているなら、必要なら1行にもできます: >

	def Min(num1: number, num2: number): number
	  return num1 < num2 ? num1 : num2
	enddef

ユーザー定義関数は組み込み関数とまったく同じ方法で呼び出すことができます。違う
のは名前だけです。Min 関数は次のように使用できます: >

	echo Min(5, 8)

関数が実行され、関数の中身が Vim によって解析されます。未定義の変数や関数を使
うなどの間違いがあったときは、エラーメッセージが表示されます。関数定義の時点で
はそれらのエラーは検出されません。より早くエラーを検知したい場合は、Vim にスク
リプト内のすべての関数をコンパイルするように指示できます: >

	defcompile

関数のコンパイルには少し時間がかかりますが、エラーは早期に報告されます。作業中
にスクリプトの最後で `:defcompile` を使用し、問題がなければコメントアウトしま
す。

何も返さない関数の場合は、単純に戻り値の型を省略します: >

	def SayIt(text: string)
	  echo text
	enddef

任意の型の値を返したいのであれば、"any" を戻り値の型に使えます: >
	def GetValue(): any
戻り値の型チェックが無効になるので、必要な時だけにしてください。

旧来の関数も `function` と `endfunction` で定義できます。これらには型がなくコ
ンパイルされません。そのため実行がより遅いです。


☆範囲指定を使う

関数呼び出しは行範囲付きで行えます。関数は範囲の各行ごとに1回呼び出され、カー
ソルはその行になります。例: >

	def Number()
	  echo "line " .. line(".") .. " contains: " .. getline(".")
	enddef

次のように実行すると: >

	:10,15Number()

関数は 6 回実行され、10行目から開始し終了は15行目です。


☆関数の一覧

`function` コマンドでユーザー定義関数の一覧を表示できます: >

	:function
<	def <SNR>86_Show(start: string, ...items: list<string>) ~
	function GetVimIndent() ~
	function SetSyn(name) ~

"<SNR>" プリフィックスは関数がスクリプトローカルであることを意味します。|Vim9|
の関数は "def" で始まり引数と戻り値の型を含みます。旧来の関数は "function" で
リストされます。

関数の中身を見たいときは `function` に関数名を指定してください: >

	:function SetSyn
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~

複数の "Show" 関数を異なるスクリプトで定義できるため、"Show" 関数を見るには、
スクリプトプリフィックスを含める必要があります。正確な名前を見つけるには
`function` が使用できますが、結果として非常に長いリストになる可能性があります。
パターンに一致する関数のみを取得するには、`filter` プリフィックスが使用できま
す: >
	:filter Show function
<	def <SNR>86_Show(start: string, ...items: list<string>) ~
>
	:function <SNR>86_Show
<	1    echohl Title ~
	2    echo "start is " .. start ~
	etc.


☆デバッグ

エラーメッセージが表示されたとき、あるいはデバッグ中に、行番号が表示されると便
利です。デバッグモードについては |debug-scripts| を参照してください。

'verbose' オプションに 12 以上の値を設定すると、すべての関数呼び出しが表示され
ます。15 以上にすると、実行されたすべての行が表示されます。


☆関数の削除

例えば SetSyn() 関数を削除するには次のようにします: >

	:delfunction SetSyn

削除はグローバル関数と旧来のスクリプトの関数に対してのみ機能し、|Vim9| script
内で定義した関数に対しては機能しません。

関数が存在しないか削除できない場合はエラーになります。


☆関数への参照

変数に関数を代入できると便利なことがあります。それには関数の参照の変数を使いま
す。よく "funcref" と略されます。例: >

	def Right(): string
	  return 'Right!'
	enddef
	def Wrong(): string
	  return 'Wrong!'
	enddef

	var Afunc = g:result == 1 ? Right : Wrong
	echo Afunc()
<	Wrong! ~

ここでは "g:result" が1ではないことを前提としています。詳細は |Funcref| を参照
してください。

Note 関数への参照を保持する変数の名前は大文字で始めなければなりません。そうで
ないと組み込み関数の名前と紛らわしくなります。

☆参考文献

可変長引数の使用については、|50.2| 章で紹介しています。

あなたが定義した関数についての情報は: |user-functions|。

==============================================================================
*41.8*	リストと辞書

ここまでは基本型(文字列と数値)を扱ってきました。Vim は 3 つの複合型、リスト、
Tuple と辞書もサポートしています。

リストとは、要素を順番に並べたものです。要素はどのような型でも構いません。数値
のリスト、リストのリスト、あるいは複数の型が混在したリストでも作れます。例え
ば、3 個の文字列からなるリストを作るには次のようにします: >

	var alist = ['aap', 'noot', 'mies']

リストの要素は角括弧で囲み、コンマで区切ります。空のリストを作るには次のように
します: >

	var alist = []

関数add()を使うとリストに要素を追加することができます: >

	var alist = []
	add(alist, 'foo')
	add(alist, 'bar')
	echo alist
<	['foo', 'bar'] ~

リストの連結には + を使います: >

	var alist = ['foo', 'bar']
	alist = alist + ['and', 'more']
	echo alist
<	['foo', 'bar', 'and', 'more'] ~

直接リストを関数で拡張するには次のように、`extend()` を使います: >

	var alist = ['one']
	extend(alist, ['two', 'three'])
	echo alist
<	['one', 'two', 'three'] ~

`add()` は `extend()` とは効果が異なることに注意してください: >

	var alist = ['one']
	add(alist, ['two', 'three'])
	echo alist
<	['one', ['two', 'three']] ~

add() の第2引数は1つの要素として追加され、この場合は入れ子になったリストになり
ます。


☆for ループ

リストを使ってできる素晴らしいことの1つが、リストに対する繰り返しです: >

	var alist = ['one', 'two', 'three']
	for n in alist
	  echo n
	endfor
<	one ~
	two ~
	three ~

上の例は、リスト "alist" の各要素に対して、その各値を変数 "n" に代入しながら
ループを行います。forループの書式は次の通りです: >

	for {varname} in {list-expression}
	  {commands}
	endfor

ある回数だけループするには、その長さのリストを使います。関数range()を使うと、
そのようなリストを作成できます: >

	for a in range(3)
	  echo a
	endfor
<	0 ~
	1 ~
	2 ~

range()が生成するリストの最初の要素は0であることに注意してください。そのため、
最後の要素はリストの長さより1小さい値になります。詳細: range() の内部では実際
にはリストは作られないため、巨大な範囲のループが効果的に動作します。それ以外の
時は、範囲は実際のリストになり、長いリストのためにより時間がかかります。

最大値、ステップ幅を指定することもでき、逆方向に進むこともできます: >

	for a in range(8, 4, -2)
	  echo a
	endfor
<	8 ~
	6 ~
	4 ~

より有用な例として、バッファ中のすべての行に対するループ: >

	for line in getline(1, 50)
	  if line =~ "Date: "
	    echo line
	  endif
	endfor

1行目から50行目(両端を含む)を調べ、そこに含まれる日付を全て表示しています。

さらなる情報については |Lists| を参照してください。

TUPLE

Tuple は、不変の順序付きの項目のシーケンスです。項目は任意の型にすることができ
ます。項目にはインデックス番号でアクセスできます。3 つの文字列を含む Tuple を
作成するには、次のようにします: >

	var atuple = ('one', 'two', 'three')

Tuple 項目は括弧で囲まれ、コンマで区切られます。空の Tuple を作成するには: >

	var atuple = ()

|:for| ループは、リストと同様に Tuple 内の項目を反復処理するために使用できま
す。

詳細については、|Tuples| を参照してください。

☆辞書

辞書はキーと値のペアを保持します。キーを指定することで高速に値を検索できます。
辞書は波括弧で作ります: >

	var uk2nl = {one: 'een', two: 'twee', three: 'drie'}

そして角括弧の中にキーを書くことで単語を検索します: >

	echo uk2nl['two']
<	twee ~

キーが特殊文字を含まない場合は、ドット記法が使えます: >

	echo uk2nl.two
<	twee ~

辞書の定義の書式は次の通りです: >

	{<key> : <value>, ...}

空の辞書とは、どんなキーも持たない辞書のことです: >

	{}

辞書にはいろいろな使い道があります。辞書を扱う関数もたくさんあります。例えば、
キーのリストを取得してそれに対してループするには次のようにします: >

	for key in keys(uk2nl)
	  echo key
	endfor
<	three ~
	one ~
	two ~

キーはソートされていません。特定の順序に並べるにはリストをソートします: >

	for key in sort(keys(uk2nl))
	  echo key
	endfor
<	one ~
	three ~
	two ~

要素が定義された順序を得ることはできません。そのような目的にはリストを使ってく
ださい。リストは順序を保って要素を保持します。

さらなる情報については |Dictionaries| を参照してください。

==============================================================================
*41.9*	空白

空の行はスクリプト内にあっても構いません。無視されます。

"trim" 無しで |:let-heredoc| を使用する場合以外、行頭の空白 (スペースとTAB) は
は無視されます。

末尾の空白は多くの場合無視されますが、常にではありません。`map` というコマンド
は末尾空白を含みます。それに気を付けなくてはいけませんが、分かりにくい間違いを
引き起す原因になります。一般的な解決策としては、本当に必要になるとき以外は末尾
空白を使わないことです。

オプション値に空白を含めるときは、バックスラッシュ ("\") でエスケープする必要
があります: >

	:set tags=my\ nice\ file

次のように書くと: >

	:set tags=my nice file

これはエラーになります。このコマンドは次のように解釈されてしまいます: >

	:set tags=my
	:set nice
	:set file

|Vim9| script は、空白に関しては非常にうるさいです。これは、確実にスクリプトを
読みやすくし、間違いが避けらるようにするために意図的に行われています。空白を合
理的に使えばちゃんと動作します。そうでないなら空白が不足しているか削除が必要な
その場所を示すエラーメッセージが表示されるでしょう。

==============================================================================
*41.10*	行継続

旧来の Vim のスクリプトで行継続をするには継続する行の先頭をバックスラッシュに
します: >
	let mylist = [
			\ 'one',
			\ 'two',
			\ ]

これには 'cpo' オプションに "C" フラグが含まれないことが必要になります。通常は
スクリプトの開始にてこの処理を置くことでそうします: >
	let s:save_cpo = &cpo
	set cpo&vim

そしてスクリプトの終了でオプションを戻します: >
	let &cpo = s:save_cpo
	unlet s:save_cpo

詳細についてはこちらを確認ください: |line-continuation|

|Vim9| script ではバックスラッシュをまだ使えますが、多くの箇所で不要となります
: >
	var mylist = [
			'one',
			'two',
			]

また、'cpo' オプションを変更することは必要なくなります。詳細は
|vim9-line-continuation| を参照してください。

==============================================================================
*41.11*	 コメント

|Vim9| script では、コメントは # 記号で開始します。行末までのすべての文字がコ
メントとして解釈され、無視されます。ただし、コメントを書くことができないコマン
ドもあります (以下に例を示します)。コメントは行のどこからでも開始できます、し
かしコマンドの一部の時はそうではありません、例、文字列の中。

旧来の script では、文字 " (二重引用符)でコメントを開始します。
これについて二重引用符の文字列をコメントとして認識されないようにするためにはい
くつか巧妙さが伴います(|Vim9| script を好む理由の1つです)。

コメントとして簡単な注釈を付けたとします。例: >

	abbrev dev development	# shorthand
	map <F3> o#include	# insert include
	execute cmd		# do it
	!ls *.c			# list C files

- 短縮形 'dev' は 'development  # shorthand' に展開されます。
- <F3> には 'o#....' から '# insert include' までの全部がマップされます。
- `execute` コマンドはエラーを起こします。
- `!` コマンドはすべての文字をシェルに渡すので、エラーを引き起すことがありま
  す。

`map`、`abbreviate`、`execute`、`!` などのコマンドはその後ろにコメントを書
くことができません (そのようなコマンドは他にもあります)。ただし、無理やりコメ
ントを書く方法もあります: >

	abbrev dev development|# shorthand
	map <F3> o#include|# insert include
	execute '!ls *.c'	|# do it

'|' 文字でコマンドを区切り、次のコマンドを書くことができます。そして次のコマン
ドはコメントのみになります。最後のコマンドは `execute` を使う汎用の解決策です、
これはすべてのコメントを受け付けないコマンドや '|' で次のコマンドを分けられな
いコマンドで動きます。

短縮入力やキーマップの場合は '|' の前に空白を置かないように注意してくださ
い。これらのコマンドは行末か '|' までのすべての文字を使います。そのため、意図
せずに末尾に空白を入れてしまうかもしれません: >

	map <F4> o#include  

ここでは意図してやっていますが、他の場合には偶発的である可能性があります。末尾
空白をハイライトすることで、この問題が発見しやすくなります: >
	match Search /\s\+$/

Unix では特別なコメント書式を使って Vim script を実行形式にすることができ、ま
た旧来のスクリプトでも動きます: >
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit

==============================================================================
*41.12*	ファイルフォーマット

行末の文字はシステムに依存します。Vim script では Unix のファイルフォーマット
が常に推奨されます。行は改行文字 (注:<NL>) で区切られます。これはまた他のシス
テムでも動作します。この方法でならあなたの Vim script を MS-Windows から Unix
にコピーしても動くようにすることができます。|:source_crnl| を参照。確実に正し
く設定されるには、ファイルを書き込む前に次のようにします: >

	:setlocal fileformat=unix

"dos" ファイルフォーマット使用時は、行は CR-NL の二文字で区切られます。CR 文字
はさまざまな問題の原因なので、これは回避するのが良いです。

==============================================================================

Vim script を書く事前情報は |usr_50.txt| にあります。

次章: |usr_42.txt|  新しいメニューを追加する

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
