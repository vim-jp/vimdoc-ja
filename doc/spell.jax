*spell.txt*	For Vim バージョン 8.1.  Last change: 2019 Jan 19


		  VIMリファレンスマニュアル	  by Bram Moolenaar


スペルチェック						*spell*

1. はじめに			|spell-quickstart|
2. スペルチェックの注意点	|spell-remarks|
3. スペルファイルの生成		|spell-mkspell|
4. スペルファイルの形式		|spell-file-format|

{Vi にはこれらのコマンドはない}

コンパイル時に |+syntax| 機能を無効にした場合にはスペルチェックは利用すること
ができない。

Note: 他にも vimspell プラグインがある。そのプラグインを入れていれば ":help
vimspell" を実行することでそれについて調べることができる。しかし、おそらくその
プラグインを削除し、代わりにオプション 'spell' を使いたいと思うだろう。そちら
のほうがうまくいく。

==============================================================================
1. はじめに					*spell-quickstart* *E756*

このコマンドで、スペルチェックがオンになる: >

	:setlocal spell spelllang=en_us

これはオプション 'spell' をオンにし、アメリカ英語のチェックを指定する。

認識されない単語は以下のようにハイライトされる:
	SpellBad	認識されない単語			|hl-SpellBad|
	SpellCap	頭文字が大文字になっていない単語	|hl-SpellCap|
	SpellRare	まれな単語				|hl-SpellRare|
	SpellLocal	選択された地域では間違った綴り		|hl-SpellLocal|

Vim は単語の綴りのみをチェックし、文法はチェックしない。

もし、'mousemodel' オプションが "popup" に設定されてカーソルが間違った単語の上
にあるか、"popup_setpos" に設定されてマウスポインタが間違った単語の上にあるな
ら、ポップアップメニューは間違った単語を置き換えるサブメニューが含まれるように
なる。Note: これはポップアップメニューの表示を遅くする。Note: GTKについてはメ
ニューが現れるまでマウスの右ボタンを離してはいけない。そうしなければ機能しない。

次の綴りの間違った単語を探すには:

							*]s*
]s			カーソルの後の、次の綴りの間違った単語に移動する。コマ
			ンドの前に count を指定することで、繰り返しができる。
			'wrapscan' が適用される。

							*[s*
[s			"]s" と同様だが後方検索を行い、カーソルより前の綴りの
			間違った単語を探す。2行に渡った単語は認識しないため、
			間違いとしてハイライトされていない単語で止まることがあ
			る。行頭が大文字になっていない単語では止まらない。

							*]S*
]S			"]s" と同様だが、間違った単語のみで止まり、まれな単語
			や他の地域の単語では止まらない。

							*[S*
[S			"]S" と同様だが、後方検索を行う。


単語をあなた自身の単語リストに追加するには:

							*zg*
zg			カーソルの下の単語を正しい (good) 単語として、
			'spellfile' の最初のファイルに追加する。
			コマンドの前に count を指定することで、'spellfile' 内
			の項目を指定することができる。count として 2 を指定す
			ると、2 番目の項目が使われる。

			ビジュアルモードで選択された文字は単語として追加される
			(スペースを含む!)。
			カーソルが間違った綴りとしてマークされた文章の上にある
			時、そのマークされた文章が使われる。
			そうでなければ、単語ではない文字で分けられたカーソルの
			下の単語が使われる。

			もしその単語が明示的に別のスペルファイルで間違った単語
			としてマークされているなら、その結果は予測できない。

							*zG*
zG			"zg" と同様であるが、その単語を内部単語リスト
			|internal-wordlist| に加える。

							*zw*
zw			"zg" と同様であるが、間違った (wrong) 単語としてマーク
			する。もしその単語がすでに 'spellfile' にある場合は、
			コメント行に変更される。それらを取り除くには
			|spellfile-cleanup| を参照する。

							*zW*
zW			"zw" と同様であるが、その単語を内部単語リスト
			|internal-wordlist| に加える。

zuw							*zug* *zuw*
zug			|zw| や |zg| をundoして、'spellfile' の項目からその単
			語を削除する。count は |zg| と同様に使われる。

zuW							*zuG* *zuW*
zuG			|zW| や |zG| をundoして、内部単語リストからその単語を
			削除する。count は |zg| と同様に使われる。

							*:spe* *:spellgood*
:[count]spe[llgood] {word}
			|zg| と同様に、{word} を正しい単語として 'spellfile' に
			加える。count が無いときは最初の名前が使われ、count に
			2 を指定したときは 2 番目の項目が使われる。以下同様。

:spe[llgood]! {word}	|zG| と同様に、{word} を正しい単語として内部単語リスト
			に加える。

							*:spellw* *:spellwrong*
:[count]spellw[rong] {word}
			|zw| と同様に、{word} を間違った (wrong) 単語として
			'spellfile' に加える。count が無いときは最初の名前が使
			われ、count に 2 を指定したときは 2 番目の項目が使われ
			る。以下同様。

:spellw[rong]! {word}	|zW| と同様に、{word} を間違った (wrong) 単語として内
			部単語リストに追加する。

:[count]spellu[ndo] {word}				*:spellu* *:spellundo*
			|zuw| と同様である。[count] は |:spellgood| と同様に使
			われる。

:spellu[ndo]! {word}	|zuW| と同様である。[count] は |:spellgood| と同様に使
			われる。


上記のコマンドで 'spellfile' に単語を追加した後、その関連付けられた ".spl" ファ
イルは自動的に更新され再読み込みされる。もし手動で 'spellfile' を変更するなら
|:mkspell| コマンドを用いる必要がある。このコマンドの順序でたいていうまくいく: >
	:edit <'spellfile' にあるファイル>
<	(スペルファイルに変更を加える) >
	:mkspell! %

'spellfile' の形式に関する詳細は下記の |spell-wordlist-format| を参照。

							*internal-wordlist*
内部単語リストは 'spell' が設定された全てのバッファで使われる。内部単語リスト
は蓄えられず、Vim が終了する時に失われる。また 'encoding' が設定された時にクリ
アされる。


間違った単語に対しての提案を調べるには:
							*z=*
z=			カーソルの下や後の単語に対して正しい綴りの単語を提案す
			る。これはまた間違った単語としてハイライトされていない
			単語に対しての代わりを調べることもできる。例えば、その
			後の単語が間違っている場合など。
			ビジュアルモードでハイライトされたテキストは置換される
			単語として見なされる。
			結果は、置換されようとしている単語との類似度でソートさ
			れる。
			これには長い時間が掛かることがある。うんざりした場合は
			CTRL-C を打つこと。

			count なしでこのコマンドを使う場合、選択肢がリストアッ
			プされ、選びたい選択肢の番号を入力することができる。置
			き換えたくない場合は <Enter> を押す。また、マウスを使っ
			て選択肢をクリックすることもできる (マウスがノーマルモー
			ドで使われ、行の折り返しがない時のみ働く)。キャンセル
			するには最初の行 (ヘッダー) をクリックする。

			リストアップされた提案はふつうハイライトされた間違った
			単語を置き換える。その提案は時々他のテキストを含むこと
			があるが、その場合は置き換えられるテキストが "<" の後
			にリストアップされる。

			count を用いた場合、プロンプトは出ずにその提案が使われ
			る。例えば、"1z=" は常に最初の提案を利用する。

			'verbose' が 0 以外の場合、間違った単語との類似度を示
			すスコアが提案と共に表示される。（高いスコアは、違いが
			大きいことを示す。）
			単語が置換された後は、リドゥコマンド "." はその単語の
			置換を繰り返す。これは、"ciw" の後に正しい単語を入力し
			<Esc> を入力したように動作する。これは、単語の間にス
			ペースを含まないタイ語やその他の言語に対しては動かな
			い。

					*:spellr* *:spellrepall* *E752* *E753*
:spellr[epall]		|z=| によって行われた置換を、現在のウィンドウの全ての
			マッチする単語に対して繰り返す。

挿入モードでは、カーソルが間違った綴りの単語の後にある場合、提案を見つけるため
に CTRL-X s を使うことができる。これは挿入モード補完のように動作する。次の提案
を使うには CTRL-N を、戻るには CTRL-P を使うこと。|i_CTRL-X_s|

オプション 'spellsuggest' は候補のリストがどのように生成、ソートされるかに影響
する。|'spellsuggest'| を参照せよ。

オプション 'spellcapcheck' は文の最初の単語が大文字で始まるかをチェックするの
に用いる。これはファイルの最初の単語には働かない。文の直後に改行があるとき、次
の行のハイライティングが後回しにされるかもしれない。必要であれば |CTRL-L| を使
用せよ。また、'spelllang' が設定される時にどのように自動で設定されるのかについ
ては |set-spc-auto| を参照せよ。

Vim は見つけた正しい単語の数を数える。これは提案候補をソートするのに使用される。
前に見つけた単語は小さな評価、よく見られる単語は大きな評価を得る。接辞ファイル
に共通する要素は共通の単語を定義するのに使用することができる。そのため、この機
構は新規もしくは小さいファイルでも機能する |spell-COMMON| 。

==============================================================================
2. スペルチェックの注意点				*spell-remarks*

性能

Vim はオンザフライのスペルチェックをする。スペルチェックを速くするために単語リ
ストはメモリにロードされる。だがこのために多くのメモリ (1 Mbyte以上) が使われ
る。さらに、単語リストがロードされている時に著しい遅延が生じるかもしれない。こ
れは'spell' が既に設定されていたのに、'spell' を設定する時や 'spelllang' を設
定する時に発生する。遅延を最小限にするには各単語リストが1回だけ読み込まれるよ
うにする。そうすれば、'spelllang' が空になる時か 'spell' がリセットされる時に
単語リストは削除されない。'encoding' を設定して全ての単語リストが再読み込みさ
れる時に、上のようにまた遅延に気づくかもしれない。


地域

単語はそれぞれの地域で綴りが異なるかもしれない。例えば、英語は少なくともこれ
らの差異がある。

	en		全ての地域
	en_au		オーストラリア
	en_ca		カナダ
	en_gb		イギリス
	en_nz		ニュージーランド
	en_us		アメリカ

ある地域では使われないが別の地域では使われる単語は SpellLocal |hl-SpellLocal|
でハイライトされる。

常に言語名や地域名には小文字を使う。

|zg| や他のコマンドで単語が追加された時、その単語は常に全ての地域に追加される。
これは 'spellfile' を手動で編集することで変更できる。|spell-wordlist-format|
を参照せよ。'spellfile' にあるファイル内で指定される地域は 'spelllang' にあるす
べてのエントリが同じ地域 (.spl の名前によって特定されるファイルは数えない) を指
定するときにのみ使用されることに注意すること。

							*spell-german*
特有の例外: ドイツ語ではこれらの特別な地域が使われる:
	de		全てのドイツ語単語を許容する
	de_de		新旧正書法
	de_19		旧正書法
	de_20		新正書法
	de_at		オーストリア
	de_ch		スイス

							*spell-russian*
特有の例外: ロシア語ではこれらの特別な地域が使われる:
	ru		全てのロシア語単語を許容する
	ru_ru		"IE" letter spelling
	ru_yo		"YO" letter spelling

							*spell-yiddish*
イディッシュ語は特有の文字を使用するため、"utf-8" エンコーディングを使用する必
要がある。もし latin1 を使っているのなら、Vim は代わりに字訳された (ローマ字化
された) イディッシュ語を使用するだろう。もしあなたが字訳されたイディッシュ語を
utf-8 で使用したいのなら、"yi-tr" を使用せよ。
一覧:
	'encoding'	'spelllang'
	utf-8		yi		イディッシュ語
	latin1		yi		ローマ字化されたイディッシュ語
	utf-8		yi-tr		ローマ字化されたイディッシュ語

							*spell-cjk*
中国語、日本語、あるいはその他の東アジアの文字に対するスペルチェックはサポート
されていないため、これらの文字は通常、エラーとしてマークされる。'spelllang' が
"cjk" を含んでいる場合、これらの文字はエラーとしてマークされなくなる。これは、
いくつかのアジアの単語が含まれるテキストを、スペルチェックを有効にして編集する
際に有用である。


スペルファイル						*spell-load*

Vim は 'runtimepath' のディレクトリの中の "spell" という名前のサブディレクトリ
にあるスペルファイルを探す。ファイル名は LL.EEE.spl のようになる:
	LL	言語名
	EEE	'encoding' の値

"LL" の値は 'spelllang' の値が使われるが、地域名は除外される。
例:
	'spelllang'	LL ~
	en_us		en
	en-rare		en-rare
	medical_ca	medical

'runtimepath' の中の最初のファイルだけがロードされる。これが成功した場合、
LL.EEE.add.spl という名前のファイルが追加でロードされる。追加ファイルは、見つ
かったものが全てロードされる。

スペルファイルが見つからなければ、自動コマンドイベント |SpellFileMissing| が発
生する。これによってスペルファイルをダウンロードする |spellfile.vim| プラグイ
ンを呼び出せる。

加えて、'spellfile' の名前に関連したファイルは読み込まれる。これらは |zg| や
|zw| で正しい単語や間違った単語を追加するファイルである。

例外:
- Vim は、'encoding' が "iso-8859-15" のとき "latin1" を使う。ユーロマークは
  スペルチェックに影響しない。
- 'encoding' 用のスペルファイルが見つからないときは "ascii" が試される。これは
  ほぼ全ての単語が ASCII である英語のような言語に対してのみうまく働く。
  'encoding' が iso-8859-2 のように "latin1" でないときに英文を編集しているとき
  に役に立つ。".add" ファイルについては、見つかったメインのスペルファイルとし
  て同じ名前のファイルが使用される。

例えば、以下の値が設定されている場合:
	'runtimepath' が "~/.vim,/usr/share/vim81,~/.vim/after"
	'encoding'    が "iso-8859-2"
	'spelllang'   が "pl"

Vim は以下を探す:
1. ~/.vim/spell/pl.iso-8859-2.spl
2. /usr/share/vim81/spell/pl.iso-8859-2.spl
3. ~/.vim/spell/pl.iso-8859-2.add.spl
4. /usr/share/vim81/spell/pl.iso-8859-2.add.spl
5. ~/.vim/after/spell/pl.iso-8859-2.add.spl

ここでは、1. が見つからず、2. が見つかったと仮定している。

もし 'encoding' が "latin1" ならば Vim は以下を探す:
1. ~/.vim/spell/pl.latin1.spl
2. /usr/share/vim81/spell/pl.latin1.spl
3. ~/.vim/after/spell/pl.latin1.spl
4. ~/.vim/spell/pl.ascii.spl
5. /usr/share/vim81/spell/pl.ascii.spl
6. ~/.vim/after/spell/pl.ascii.spl

これはこれらが見つからないことを想定する (ポーランド語は非 ASCII 文字を抜くと意
味をなさない)。

EBCDIC 向けのスペルチェックは現在サポートされていない。

現在の 'encoding' でスペルファイルが利用できないかもしれない。スペルファイルの
作成の仕方については |spell-mkspell| を参照せよ。"iconv" でスペルファイルを変
換するのは機能しないだろう!

Note: VMS ではファイル名によるトラブルを避けるため、".{enc}.spl" は
"_{enc}.spl" に変更されている。

						    *spell-sug-file* *E781*
もし ".spl" ファイルと全く同じだが最後が ".sug" で終わるファイルがあるのであれ
ば、このファイルはよりよい提案を与えるのに使われる。メモリの使用率を減らすため、
提案が作られる前には読み込まれない。

				    *E758* *E759* *E778* *E779* *E780* *E782*
スペルファイルを読み込む時、Vim はそれが正しくフォーマットされているかチェック
する。もしエラーが生じたなら、そのファイルが不完全であるか、変更されているか、
Vim の他のバージョン向けのものかもしれない。


スペルファイルのクリーンアップ				*spellfile-cleanup*

|zw| コマンドは 'spellfile' に存在するエントリをコメント行に変更する。これは毎
回新しいファイルに書き込まれることを避けるが、結果としてファイルは長くなるのみ
で短くなることはない。すべての ".add" スペルファイル内のコメント行をクリーンアッ
プするには次のようにする: >
	:runtime spell/cleanadd.vim

これは行頭が "##" で始まるものを除いて、すべてのコメント行を削除する。保持して
おきたいコメントには "##" を使う。

好きな頻度で、このスクリプトを呼び出すことができる。直近で変更されたファイルの
アップデートをスキップするための変数を提供している。そのファイルが最後に変更さ
れてからクリーンアップされるまでの秒数を設定する。例えば、この一時間で変更され
なかったファイルだけをクリーンアップするには次のようにする: >
      let g:spell_clean_limit = 60 * 60
デフォルトでは1秒。


単語

Vim は単語を認識するのに定型的な方法を使う。これは 'iskeyword' とは独立してい
るので、ヘルプファイル内や 'iskeyword' 内に '-' のような文字を含む言語に対して
も機能する。この単語の文字は 'encoding' に依存する。

単語の文字テーブルはメインの .spl ファイルに保存される。それゆえ .spl ファイル
を生成するときの現在のロケールがなんであるかが重要である! 一方 .add.spl ファイ
ルは単語テーブルを含まない。

数字で始まる単語に関しては、全体で単語であると認識するまで先頭の数字は無視され
る。したがって、もし "3D" が一つの単語で "D" が単語でないのなら、"3D" は単語と
して認識される。しかし、もし "3D" が単語で無ければ "D" は不正としてマークされ
る。0x12ab や 0X12AB のような16進数は認識される。


単語の組み合わせ

スペースを含む単語のスペルチェックが可能である。これは例えば、"et al." のよう
に個別に使用した場合に無効となる単語を認識するために使われる。これは更に
"the the" を評価してハイライトするためにも使われる。

スペースの個数は無関係だ。多くの場合、改行も現れるかもしれない。しかしながら、
これはスペルミスのチェックを開始する場所を見つけるのを困難にする。あなたが1行
の変更をし、その行だけが再描画されたのであれば、Vim は前の行を見ない。それゆえ、
前の行の最後が "et" であると "al." はエラーとみなされる。また、"the<CR>the" と
タイプしたときは初めの行が再描画されるまでハイライトされない。すぐに再描画を行
うには |CTRL-L| を使う。"[s" は改行を含む単語にも止まる。

改行があると、Vim は '*' や '>'、'"' のような単語をスキップするので、C、シェル、
Vim コードでのコメントをスペルチェックすることができる。


構文ハイライト						*spell-syntax*

構文ハイライトを使用するファイルでは、どこでスペルチェックを行うべきか指定する
ことができる:

1.  どこでも			   既定
2.  指定の要素			   "contains=@Spell" を使用する
3.  指定の要素以外どこでも	   "contains=@NoSpell" を使用する

@NoSpell クラスタを追加する2番目の方法はスペルチェックを再度無効にすることだろ
う。これが使われれば、例えば @Spell をプログラムのコメントに加えて、チェックす
るべきでないアイテムを @NoSell に追加できる。シンタックスアイテムにないテキス
トについては、|:syn-spell| を参照。


Vim script

スペルに関する Vim script を書きたいと思うと、これらの関数が役に立つことが分
かるだろう:

    spellbadword()	カーソル下の間違ったつづりの単語を見つける
    spellsuggest()	正しいつづりの候補を得る
    soundfold()		同音 (sound-a-like) の単語を得る


'spellcapcheck' の自動設定				*set-spc-auto*

'spelllang' オプションがうまく設定された後は、Vim は 'runtimepath' にある
"spell/LANG.vim" ファイルを読み込む。"LANG" は 'spelllang' の初めのコンマ、ドッ
ト、またはアンダースコアーまでの値である。これは言語のための特別なオプション、
とりわけ 'spellcapcheck' を設定するのに使われる。

ディストリビューションはこれらのファイルをいくつか含んでいる。これらが何をして
いるかを知るためには次のコマンドを使う >
	:next $VIMRUNTIME/spell/*.vim

Note: デフォルトのスクリプトは初期値が変更されているなら 'spellcapcheck' を設
定しない。これはユーザーが好む値を設定することを想定する。


二重スコア付け						*spell-double-scoring*

"double" 方式のスコア付けを選択するために 'spellsuggest' オプションを使用でき
る。この機構は、綴り間違いには2種類あるという原則に基づいている:

1. 単語の綴りは知っているが、何らかのミスタイプをする場合。これは小さな編集距
   離 (文字の入れ替わり/文字抜け/文字の混入) の結果であり、単語が完全に間違っ
   ているように聞こえるかもしれない。

2. 単語の綴りを知らず、単語が正しく聞こえるようにタイプする場合。
   編集距離は大きくなり得るが、sound-folding した後の単語は似ている。

これら2つの間違いのスコアは大きく異なるので、互いに1つのリストを使って、組み合
わせる。

sound-folding は遅く、言語を知っている人は2番目の種類の間違いはしないだろう。
それゆえ、'spellsuggest' に提案のスコアリングに用いる好きな方法を設定できる。

==============================================================================
3. スペルファイルの生成					*spell-mkspell*

Vim はつづりのためのバイナリフォーマットを使用する。このことにより単語リストの
読み込みを大幅に速くし、単語リストを小さく保つ。
						    *.aff* *.dic* *Myspell*
Myspell が使用する .aff と .dic ファイルから Vim が使用するスペルファイルを生
成することができる。Myspell は OpenOffice.org と Mozilla によって使用される。
OpenOffice の .oxt ファイルは .aff と .dic ファイルを含む zip ファイルである。
これらはここから探すことができる。
	http://extensions.services.openoffice.org/dictionary
これが機能しない場合、以前の OpenOffice 2 のファイルが使用されることがある。
	http://wiki.services.openoffice.org/wiki/Dictionaries
加えて、プレーンテキストの単語リストも使用できる。選択肢はあなたが見つけた単語
のリストによって決まり、結果は同じになる。

Aap (www.a-a-p.org) をインストールしたのなら、runtime/spell/??/ ディレクトリで
レシピを使用することができる。Aap はファイルをダウンロードし、Vim に必要なパッ
チを適用し .spl ファイルをビルドする。

現在のロケールが適切に設定されているか確認すること。適切に設定がなされていない
場合、Vim は大文字と小文字の区別ができない。もしロケールが利用できない場合 (例
えば Unix 上で MS-Windows コードページを使用している場合) は .aff ファイルにテー
ブルを追加すること |spell-affix-chars|。.aff ファイルがテーブルを定義していな
いなら、現在有効なスペリングのテーブルが使われる。スペリングが有効でないなら
Vim は推測しようとする。

							*:mksp* *:mkspell*
:mksp[ell][!] [-ascii] {outname} {inname} ...
			単語リストから Vim スペルファイルを生成する。例: >
		:mkspell /tmp/nl nl_NL.words
<								*E751*
			{outname} が ".spl" で終わっている場合、出力ファイル名
			として使われる。そうでなければ、地域名を除いた "en" の
			ような言語名が使われる。書き込まれたファイルは
			"{outname}.{encoding}.spl" となり、{encoding} には
			'encoding' オプションの値が入る。

			出力ファイルがすでに存在する場合は、上書きするために[!]
			を使用しなければならない。

			[-ascii] 引数が存在している場合は、非 ascii 文字で構
			成された単語がスキップされる。結果のファイルは
			"ascii.spl" で終わる。

			入力は Myspell 形式の {inname}.aff と {inname}.dic ファ
			イルが使用できる。もし {inname}.aff が存在していなけれ
			ば、{inname} はプレーン単語リストのファイル名として使
			われる。

			複数の {inname} 引数を使うと、1 つの Vim スペルファイル
			に複数の地域の組み合わせを与えることができる。例: >
		:mkspell ~/.vim/spell/en /tmp/en_US /tmp/en_CA /tmp/en_AU
<                        これは US, CA そして AU の英単語リストの組み合わせを
			1つの en.spl.file にする。
			8つの地域まで組み合わせることができる。*E754* *E755*
			上記のコマンドで出現する .aff ファイルの初めにある REP
			と SAL 項目が使われる。|spell-REP| |spell-SAL|
								*E845*
			このコマンドは多くのメモリを使用し、最適な単語ツリーを
			見つけることが求められる (ポーランド語、イタリア語、ハ
			ンガリー語は数百メガバイトのメモリを要求する)。最終的
			な結果は圧縮が使用されるので、非常に小さくなるだろう。
			メモリを使い果たさないようにするため、圧縮は適便行われ
			る。これは 'mkspellmem' オプションで調整できる。

			スペルファイルが書き込まれた後、バッファ内で使われ始め
			ると自動的に再読み込みされる。

:mksp[ell] [-ascii] {name}.{enc}.add
			上記の ":mkspell" と似ている。入力ファイルとして
			{name}.{enc}.add を使用すると、同じディレクトリに
			".spl" が付加された出力ファイルが生成される。

:mksp[ell] [-ascii] {name}
			上記の ":mkspell" と似ている。入力ファイルとして {name}
			を使用すると、同じディレクトリに ".{enc}.spl" が付加さ
			れた出力ファイルが生成される。

Vim は重複した単語の出現回数を報告する。これは単語リスト中の誤りであるかもしれ
ない。しかし、時には同じ基本単語に対して、結合しないようにするために異なる接頭
辞と接尾辞が使用される (例えば、チェコ語はこれを使う)。もしすべての重複する単
語を Vim に報告させたい場合は、'verbose' オプションを設定する。

Vim で使うために Myspell の単語リストを変更したいならば、次のような手順で行う
ことをお薦めする:

1. Myspell から xx_YY.aff と xx_YY.dic ファイルを入手する。
2. これらのファイルを xx_YY.orig.aff と xx_YY.orig.dic のようにコピーする。
3. 良くない単語を取り除くために xx_YY.aff とxx_YY.dic ファイルを変更し、足りな
   い単語を加え、FOL/LOW/UPP の単語の文字を定義したりする。配布されている
   "*.diff" ファイルを使用できる。
4. Vim を正しいロケールで起動し、Vim スペルファイルを生成するために |:mkspell|
   を使う。
5. 'runtimepath' 内のスペルファイルディレクトリに書き込んだなら、
   "set spelllang=xx" でスペルファイルを試してみる。その他のディレクトリに書き
   込んだ場合は、":set spelllang=xx.enc.spl" を試す。

Myspell ファイルが更新されたとき、差異をマージすることができる:
1. 新しい Myspell ファイルを xx_YY.new.aff と xx_UU.new.dic として取得する。
2. 変更箇所を確認するために Vimdiff を使う: >
	vimdiff xx_YY.orig.dic xx_YY.new.dic
3. 必要な変更点を xx_YY.dic に引き継ぐ。
   xx.YY.aff も変更する必要があるかもしれない。
4. xx_YY.new.dic を xx_YY.orig.dic へ、xx_YY.new.aff を xx_YY.orig.aff へリネー
   ムする


スペルファイルのバージョン				*E770* *E771* *E772*

スペルチェックは Vim の比較的新しい機能なので、.spl ファイル形式はより多くの言
語をサポートするために変更されるかもしれない。Vim はスペルファイルの有効性を確
認し、間違いがあれば報告する。

	E771: Old spell file, needs to be updated ~
スペルファイルが使用している Vim のバージョンよりも古いものなので、.spl ファイ
ルを更新する必要がある。

	E772: Spell file is for newer version of Vim ~
これはスペルファイルが使用している Vim よりも新しいバージョンに対応したものな
ので、Vim を更新する必要があることを意味する。

	E770: Unsupported section in spell file ~
これはスペルファイルが使用している Vim よりも新しいバージョンに対応したもの
で、スペルファイルを動作させるために必要なセクションを含むことを意味する。この
場合は、Vim を更新することが良いアイデアとなるだろう。


スペルファイルのダンプ

もし何らかの理由で、現在使っているスペルファイルでどんな単語がサポートされてい
るかをチェックしたい場合、以下のコマンドを使用できる:

							*:spelldump* *:spelld*
:spelld[ump]		新規ウィンドウを開き、すべての有効な単語で埋める。
			複合語は含まれない。
			Note: いくつかの言語では、結果が非常に大きくなり、Vim
			がメモリ不足を引き起こすかもしれない。

:spelld[ump]!		":spelldump" と同様に、単語数を含む。これは画面を更新
			している間に発見した単語の個数である。COMMON アイテム
			にある単語は10から数えられる。

単語リストの形式は |spell-wordlist-format| が使われる。全ての単語を含む1つの
.spl ファイルを生成するために、":mkspell" で読み込むことができるようにすべきだ。

すべての 'spelllang' に対するエントリが同じ地域を使用しているか、または全く地
域使用しない場合、地域情報がダンプワードに含まれる。そうでなければ、現在の地域
に関する単語のみが含まれ、"/regions" 行は生成されない。

.spl ファイルの名前を持つコメント行は、.spl ファイルから生成された単語の上記の
ヘッダーとして使われる。


スペルファイルがないとき	*spell-SpellFileMissing* *spellfile.vim*

使用している言語のスペルファイルが利用できないならば、エラーメッセージを受け取
るだろう。しかし、"spellfile.vim" プラグインがアクティブであるならば、スペルファ
イルをダウンロードするように薦められる。指示に従ったのならば、プラグインはダウ
ンロードしたスペルファイルを保存する場所を尋ねるだろう (このため、
'runtimepath' 内に書き込み可能なディレクトリがなければならない)。

プラグインは、Vim ftp サーバー上にスペルファイルを探すデフォルトの場所を持つ。
他の場所や他のプロトコルを使用したいならば、スペルファイルが存在するディレクト
リに対して、g:spellfile_URL を設定する。|netrw| プラグインはファイルを取得する
ために使われ、そこに URL の特定の構文があるかを調べる。例: >
	let g:spellfile_URL = 'http://ftp.vim.org/vim/runtime/spell'
特殊文字をエスケープする必要があるかもしれない。

このプラグインは一度、ある 1 つの言語をダウンロードすることについてのみ質問する
だろう。もし再度行おうとする場合は、Vim を再起動するか g:spellfile_URL を他の
値 (例えば、スペースを前置する) に設定する。

"spellfile.vim" プラグインの使用を避けるためには、vimrc ファイル内で次のように
する: >

	let loaded_spellfile_plugin = 1

プラグインを使用するかわりに 欠落したファイルを扱うために |SpellFileMissing|
自動コマンドを定義することができる。次のように使う: >

	:au SpellFileMissing * call Download_spell_file(expand('<amatch>'))

それゆえ <amatch> アイテムは言語の名前を含む。もう一つの重要な値はどのエンコー
ディングも自分自身のスペルファイルがあるので 'encoding' である。2つの例外: >
- ISO-8859-15 (latin9) の場合、"latin1" という名前が使用される (これらのエンコー
  ディングは、辞書の単語で使用されていない文字のみが異なる。)。
- "ascii" という名前は単語の多くで ASCII 文字のみを使用するいくつかの言語につ
  いて使われることがある。

デフォルトの "spellfile.vim" プラグインはこの自動コマンドを使う。もし後で自分
の自動コマンドを定義するなら、これを無効にするために ":au! SpellFileMissing"
を使いたいかもしれない。プラグインが読み込まれる前に自分の自動コマンドを定義す
る場合は、これを警告し、また何もしないだろう。
							*E797*
Note SpellFileMissing 自動コマンドはユーザーが編集しているバッファを変更や削除
してはいけない。

==============================================================================
4. スペルファイルの形式					*spell-file-format*

これは単語リストを作成、管理する人が使うファイルのフォーマットである。

Note ここでは辞書 ("dictionary") という単語の使用を避ける。スペルチェックの目
的は (本のような) 辞書を書くこととは違うからだ。スペリングのために、間違いのな
い単語のリストが必要となる。それゆえ、ハイライトされるべきではない。人と会社の
名前は辞書内に現れることはないが、単語リストには現れる。いくつかの古い単語はめっ
たに使われることはないが、よくあるミススペルである。これらは辞書には現れるが、
単語リストには現れない。

2つのフォーマットがある: 単語の率直なリストと接辞圧縮を使ったリストである。接
辞圧縮を使ったファイルは Myspell (Mozilla と OpenOffice.org) によって使われる。
これは2つのファイルを必要とし、1つは .aff、もう1つは .dic の拡張子をもつファイ
ルだ。


率直な単語リストのフォーマット				*spell-wordlist-format*

単語は1行に1つずつ現れなければならない。これが必要とされることのすべてだ。

加えて、次の項目が評価される:

- 何もない、もしくは空行は無視される。

	# comment ~
- # で始まる行は無視される (コメント行)。

	/encoding=utf-8 ~
- どんな単語よりも前にある "/encoding=" で始まる行はファイルのエンコーディング
  を指定する。'=' の後にはエンコーディング名がくる。これは Vim に指定されたエ
  ンコーディングから 'encoding' への変換のセットアップをするように伝える。それ
  ゆえ1つの単語リストを複数のエンコーディング向けに使うことができる。

	/regions=usca ~
- "/regions=" で始まる行はサポートする地域の名前を指定する。どの地域も2つの
  ASCII 文字でなければならない。その1めは地域 1。それゆえ "/regions=usca" は地
  域 1の "us" と地域 2の "ca" を持つ。加えて、単語リストの地域名は主となる単語
  リストと同じでなければならない!

- それ以外の '/' で始まる行は、今後使うために予約されている。評価されない行は
  無視される。警告のメッセージを受け取るので、動作しないのが何かを知ることがで
  きる。

- 単語の後には "/" と下記の項目を伴うことができる。
    =		大文字小文字は正確にマッチしなければならない。
    ?		珍しい単語
    !		悪い (誤った) 単語
    1 to 9	単語が有効である地域。地域が指定されていないならば、すべての地
		域で単語が有効である。

例:

	# 単語リストの例			コメント
	/encoding=latin1			ファイルのエンコーディング
	/regions=uscagb				地域 "us", "ca", "gb"
	example					全ての地域の単語
	blah/12					"us", "ca" 地域の単語
	vim/!					誤った単語
	Campbell/?3				地域 3 "gb" での珍しい単語
	's mornings/=				大文字小文字を保持した単語

Note "/=" が使われたとき、同じ単語で全てが大文字のものは受理されないことに注意。
これは大文字小文字が混ざった単語が自動的に大文字小文字が保たれるのとは異なる。
これらの単語は全ての文字が大文字であってもよい。


.AFF と .DIC ファイルのフォーマット			*aff-dic-format*

2つのファイルがある: 基本単語のリストと接辞ファイルだ。接辞ファイルは言語の
設定を指定し、接辞を含むことを可能にする。接辞は十分な単語リストを得るために、
基本単語を修正するのに使われる。このことは特にポーランド語のような言語において
著しく単語の数を減らす。これは接辞圧縮と呼ばれる。

基本単語リストと接辞ファイルは ":mkspell" コマンドで結び付けられ、その成果は
バイナリのスペルファイルになる。すべての前処理が完了すると、ファイルの読み込み
は高速になる。バイナリのスペルファイルのフォーマットはソースコード
(src/spell.c) に書き込まれている。しかし、このことについて知る必要があるのは開
発者だけだ。

前処理はまた 私達が Myspell 言語ファイルを取得し、Vim の単語リストが作られる前
に変更することを許す。これらのツールは "src/spell" ディレクトリで見つけること
ができる。

接辞と単語リストファイルのフォーマットは Myspell が使用しているもの (Mozillaと
OpenOffice.org のスペルチェッカー) に基づく。説明書は次の場所で見つけることが
できる。
	http://lingucomponent.openoffice.org/affix.readme ~
Note 接辞は大文字小文字を区別することに注意。これは説明書からははっきりとわか
らない。

Vim は多数の拡張をサポートしている。これらは以下の |spell-affix-vim| で説明さ
れている。他のスペルチェッカーと互換性を保つように作られているので、同じファイ
ルがしばしば使われる。Myspell を超えるもう一つのプロジェクトの1つに　Hunspell
( http://hunspell.sf.net ) がある。


単語リストのフォーマット			*spell-dic-format*

行番号をつけた簡潔な例:

	1	1234 ~
	2	aan ~
	3	Als ~
	4	Etten-Leur ~
	5	et al. ~
	6	's-Gravenhage ~
	7	's-Gravenhaags ~
	8	# 地域間で異なる単語 ~
	9	kado/1 ~
	10	cadeau/2 ~
	11	TCP,IP ~
	12	/ 接辞 S は 's' を加えるかもしれない ~
	13	bedel/S ~

最初の行は単語の数が含まれている。Vim はこれを無視するが、ここにこれがない場合
はエラーメッセージを受け取る。*E760*

これに続くのは、1行につき1つの単語。行末の空白は無視され、その他の空白は問題と
なる。エンコーディングは接辞ファイル内で指定される |spell-SET|。

コメント行は '#' か '/' で始まる。例の8行目と12行目を参照。Note 単語の後ろにコ
メントを書くことは許可されていないことに注意:

		someword   # comment that causes an error! ~

単語の後にはオプションのスラッシュとフラグがある。フラグのほとんどは、その単語
で使用できる接辞を示す文字である。.aff ファイルの SFX や PFX 行で指定されてい
る。|spell-SFX| と |spell-PFX| を参照。Vim では接辞ファイルの FLAG 項目で、ほか
の形式のフラグを使ってもよい |spell-FLAG|。

単語が小文字のみである場合、大文字で始まる単語にもマッチするだろう。

単語が大文字を含んでいる場合、その場所に大文字が必要とされていることを意味する。
その場所が小文字である同じ単語はマッチしないだろう。他の文字が大文字である場合
もマッチしない。

すべてが大文字の単語はいつも OK になるだろう。

	単語リスト	マッチする		マッチしない~
	als		als Als ALS		ALs AlS aLs aLS
	Als		Als  ALS		als ALs AlS aLs aLS
	ALS		ALS			als Als ALs AlS aLs aLS
	AlS		AlS ALS			als Als ALs aLs aLS

KEEPCASE の接辞 ID は、大文字小文字が同一の単語のみにマッチするために使うこと
ができる。下記の |spell-KEEPCASE| を参照。

Note: 5 から 7 行目は単語ではない文字が使われていることに注意。単語にはどのよ
うな文字でも含めることができる。テキストをチェックする際に、単語の前後に単語で
はない文字が現れたときにのみマッチする。Myspell は単語ではない文字で始まる単語
ではたぶん動作しないだろう。

12 行目に "TCP/IP" が定義されている。スラッシュには特別な意味があるので、代わ
りにコンマが使われる。これは接辞ファイルの SLASH 要素に定義されている。
|spell-SLASH| を参照。Note SLASH 要素なしでは、単語は "TCP,IP" となるだろう。


接辞ファイルフォーマット		*spell-aff-format* *spell-affix-vim*

							*spell-affix-comment*
.aff ファイルのコメント行は '#' で始まる:

	# comment line ~

引数の固定された要素はコメントによって続けることができる。しかし、引数がない場
合に限り空白を含むことができる。コメントは "#" 文字で始まらなければならない。
例:

	KEEPCASE =  # fix case for words with this flag ~


エンコーディング						*spell-SET*

接辞ファイルは "iconv" によってサポートされているエンコーディングであれば、ど
のようなものでもよい。しかしながら、いくつかの場合で現在のロケールはまた、
|:mkspell| が呼び出された時に正しく設定されるべきだ。FOL/LOW/UPP 行を追加する
ことはこの要求を取り除く |spell-FOL|。

エンコーディングに関するものの何よりも前にエンコーディングは指定されるべきだ。
エンコーディングは接辞ファイルと辞書ファイルの両方に適用される。これは SET 行
において行われる。

	SET utf-8 ~

エンコーディングは ":mkspell" が使われた時に 'encoding' オプションに設定された
値とは異なっていてもよい。Vim はすべてを 'encoding' に変換し、'encoding' に関
係するスペルファイルを生成するだろう。もしも 'encoding' に適合していない文字が
使われているなら、エラーメッセージを受け取るだろう。
							*spell-affix-mbyte*
マルチバイトのエンコーディングが使われている場合、より多くの異なった接辞フラグ
を使うことができる。しかし、Myspell はこれをサポートしない。それゆえ、いずれに
せよこれを使おうとは思わないかもしれない。互換性のためには 8-bit エンコーディン
グを使う。


情報

接辞ファイルのエントリは、スペルファイルに情報を追加するのに使うことができる。
フォーマットに制限はないが、正しいエンコーディングであるべきだ。

				*spell-NAME* *spell-VERSION* *spell-HOME*
				*spell-AUTHOR* *spell-EMAIL* *spell-COPYRIGHT*
	NAME		言語名
	VERSION		1.0.1  with fixes
	HOME		http://www.myhome.eu
	AUTHOR		John Doe
	EMAIL		john AT Doe DOT net
	COPYRIGHT	LGPL

これらのフィールドは .spl ファイルにそのままの状態で置かれる。|:spellinfo| コ
マンドは情報を閲覧するために使われる。

							*:spellinfo* *:spelli*
:spelli[nfo]		現在のバッファで使われているスペルファイルの情報を表示
			する。


文字テーブル
							*spell-affix-chars*
8-bit エンコーディングを使う場合、接辞ファイルは、単語の文字が何であるかを定義
するべきだ。これはどうしてかというと、":mkspell" が使われたシステムはこのエン
コーディングのロケールをサポートしていないかもしれないし、isalpha() が動作しな
いだろうからだ。例えば Unix 上で "cp1250" を使う場合である。
						*E761* *E762* *spell-FOL*
						*spell-LOW* *spell-UPP*
接辞ファイルの3行は必要だ。簡単な例:

	FOL  áëñ ~
	LOW  áëñ ~
	UPP  ÁËÑ ~

3 行すべては全く同じ文字数を持っていなければいけない。

"FOL" 行はケースフォールドされた文字を指定する。これらは大文字小文字を区別しな
い単語の比較に使われる。ほとんどのエンコーディングでは、小文字の行と同じである。

"LOW" 行は小文字を指定する。大部分は "FOL" 行に等しい。

"UPP" 行は大文字を指定する。これは "FOL" の同じ場所にある文字とは大文字である
点だけが異なる。

例外はドイツ語の ß に役立っている。大文字の形は "SS" だ。FOL/LOW/UPP 行の中に
含まれているべきであり、そのため、単語の文字として認識されるのだが、3 行すべて
で ß 文字を使う。

ASCII 文字は省略されるべきだ。Vim は常に同じ方法でこれらを扱う。エンコーディン
グが UTF-8 である場合、単語文字の指定は必要ない。

							*E763*
Vim は同じファイルでいくつかの言語のスペルチェックを使うことを許可する。
'spelllang' オプションでこれらを列記できる。結果として、同じエンコーディングに
対するすべてのスペルファイルは同じ単語文字を使用しなければならない。そうでなけ
れば、これらをエラーなしに結合できない。

もし単語テーブルが異なるという警告 E763 を受け取ったのなら、".spl" スペルファ
イルをアップデートする必要がある。ファイルをダウンロードした場合、使用している
すべてのスペルファイルの最新版を取得しよう。もしも1つの言語だけを使っているな
らば、例えばドイツ語、さらに最新の英語スペルファイルをダウンロードしよう。そう
でなければ、再度 |:mkspell| で .spl ファイルを生成しよう。もしエラーを受け取っ
たのであれば、使用している .aff ファイルの FOL と LOW、UPP 行を確認しよう。

"-ascii" 引数で生成される XX.ascii.spl スペルファイルは文字テーブルを含まない
だろう。そのため、どんなエンコーディングのスペルファイルとも結合することができ
る。加えて .add.spl ファイルはテーブルを含まない。


中間語の文字
							*spell-midword*
いくつかの文字は、2 つの普通の単語文字の間で使われているときのみ、単に単語文字
だとみなされる。一例はシングルクォートだ: テキストを引用するのにしばしば使われ
る。それゆえ、それは単語文字として認識されない。しかし、単語文字の間に現れた場
合、単語の一部にならなければならない。これは they'are のようなスペルミスを検出
するために必要だ。they're になるべきだが、"they" と "are" はそれ自身が単語であ
るので、気づかれなかったかもしれない。

これらの文字は .aff ファイルの MIDWORD で定義される。例:

	MIDWORD	'- ~


フラグタイプ						*spell-FLAG*

フラグは単語と共に使われる接辞や単語の他の特徴を指定するために使われる。通常は
シングルキャラクタのフラグが使われる。これは特に 8 ビットエンコーディングの場
合、使用可能なフラグの数を制限する。より多くの接辞が使われるのならば、フラグ項
目が使われることがある。取りうる値:

	FLAG long	2 文字フラグを使う
	FLAG num	1 から 65000 までの数値を使う
	FLAG caplong	A-Z を除く 1 文字フラグと A-Z で始まる 2 文字フラグを
			使う

接辞リストにおける "FLAG num" の値は、コンマで区切られている必要がある:
"234,2143,1435"。この方式は非効率的だが、ファイルをプログラムで生成する場合に
は便利である。

"caplong" を使う場合、2 文字フラグは "Aa", "B1", "BB" などのようにすべて大文字
で始まる。これは多くの共通項目に関する 1 文字フラグと 非共通項目に関する 2 文
字フラグを使うのに便利である。

Note: UTF-8 を使用している場合、65000 までの文字だけがフラグとして使われるだろ
う。

Note: "num" や "long" を使用している時でさえ、フラグの数値を混ぜることができ、
接頭辞は約 250 に制限される。


接辞
					    *spell-PFX* *spell-SFX*
PFX (接頭辞) と SFX (接尾辞) 行がサポートされている (Myspell のドキュメント、
もしくは Aspell のマニュアルを参照:
http://aspell.net/man-html/Affix-Compression.html).

概要:
	SFX L Y 2 ~
	SFX L 0 re [^x] ~
	SFX L 0 ro x ~

最初の行はヘッダーで 4 つのフィールドを持つ:
	SFX {flag} {combine} {count}

{flag}		接尾辞に使われる名前。たいていは 1 文字だが、他の文字も使うこ
		とができる。|spell-FLAG| を参照。

{combine}	'Y' か 'N' である。'Y' の場合、単語 + 接尾辞はさらに接頭辞を持
		つことができる。'N' の場合、接頭辞を持つことはできない。

{count}		次に続いている行数。これが間違っている場合、エラーメッセージを
		受け取るだろう。

PFX のためのフィールドは全く同じである。

次に続いている行の基本的なフォーマットは:
	SFX {flag} {strip} {add} {condition} {extra}

{flag}		最初の行で使われている {flag} と同じでなければならない。

{strip}		基本単語から削除された文字。文字が実際にあるなら、チェックせず、
		(バイトの) 長さだけが使われる。これは {condition} とマッチする
		のが良く、これ以外の方法ではおかしなことが起こる。{strip} の長
		さが基本単語と等しいかそれ以上なら、接尾辞は使われないだろう。
		{strip}が 0 (zero) の場合は何も取り除かない。

{add}		{strip} を取り除いた後の基本単語に加えられた文字。オプションと
		して、フラグが続く '/' がある。フラグは単語に接辞を付け加える。
		|spell-affix-flags| を参照。

{condition}	単純なパターン。これが基本語とマッチした場合のみ、その単語に対
		してのみ接尾辞が使われるだろう。通常、これは末尾が異なる単語に
		対して、{add} と {strip} フィールドが異なる 1 つの接尾辞を使う。
		{condition} が . (ドット) である場合は条件はない。
		パターンは次のものを含む:
		- リテラル文字。
		- [] 内の文字セット。[abc] は a, b, c にマッチする。[a-c] の範
		  囲のためにダッシュが使えるが、これは Vim に特有のものである。
		- ^ で始まる文字セットは特定の文字を補完することを意味する。
		  [^abc] は a, b, c を除いた全ての文字にマッチする。

{extra}		オプションの特別なテキスト
		    # comment		コメントは無視される
		    -			Hunspell はこれを使うが、無視される

PFX 向けにはフィールドは同じであるが、{strip}、{add}、{condition} は単語のはじ
めに適用する。

Note: Myspell は関連情報の後にある特別なテキストはどんなものでも無視する。Vim
は "#" で始まるこの行を必要とする。そのため、間違いは気づかれずには済まない。
例:

	SFX F 0 in   [^i]n      # Spion > Spionin  ~
	SFX F 0 nen  in		# Bauerin > Bauerinnen ~

しかしながら、Myspell のために書かれた接辞ファイルの多くのエラーを回避するため
に、IGNOREEXTRA フラグを加えることができる。

明らかに Myspell は一度ならず何度も接辞名が現れることを許す。これは間違いかも
しれないので、Vim は特別な "S" をチェックする。この機能を使う Myspell のための
接辞ファイルは、明らかにこのフラグを持つ。例:

	SFX a Y 1 S ~
	SFX a 0 an . ~

	SFX a Y 2 S ~
	SFX a 0 en . ~
	SFX a 0 on . ~


接辞フラグ						*spell-affix-flags*

これは Hunspell 由来の機能: 接辞はフラグを明記するかもしれない。基本単語を明示
するフラグと同じように動作する。フラグは基本単語 + 接辞 (制限付きの) に適用す
る。例:

	SFX S Y 1 ~
	SFX S 0 s . ~

	SFX A Y 1 ~
	SFX A 0 able/S . ~

辞書ファイルが "drink/AS" を含む場合、これらの単語が適合する。

	drink
	drinks		S suffix を使う
	drinkable	A suffix を使う
	drinkables	A suffix を使い、それから S suffix を使う

一般に、接尾辞フラグは基本単語フラグに付加され、どちらのフラグも単語に接尾辞を
加えるために使われる。しかし、基本単語フラグが接辞のために使われるのは次を除い
て 1 度だけである。その例外とは、双方が結合をサポートしている時に、双方の 1つ
の接頭辞と 1 つの接尾辞が使われる場合である。

特に、接辞フラグは次のために使うことができる:
- 上記の例と同じだが、接尾辞の接尾辞。これは一度だけ動作するので、1 つの単語は
  2 つの接尾辞を持つことができる (それと 1 つの接頭辞)。
- |spell-RARE| フラグを使って、珍しい接辞を持つ単語を作る。
- |spell-COMPOUNDFORBIDFLAG| フラグを使って、複合語から接辞を持つ単語を除外す
  る。
- 接辞を持つ単語が、|spell-COMPOUNDPERMITFLAG| を持つ接辞側の複合語の一部とな
  ることを許す。
- NEEDCOMPOUND フラグを使う: 接辞を加えた単語は複合語の一部としてのみ使われる。
  |spell-NEEDCOMPOUND|
- 複合語フラグ: 接辞を加えた単語は尾、中間、頭などで複合語の一部となることがで
  きる。フラグは基本単語のフラグと組み合わされる。|spell-compound|
- NEEDAFFIX: その他の接辞が妥当な単語を作るのに必要とされる。
- CIRCUMFIX は下記で説明される。


IGNOREEXTRA						*spell-IGNOREEXTRA*

通常、Vim は '#' で始まらない特別フィールドにエラーを与える。これはエラーが見
過ごされるのを防ぐ。しかしながら、いくつかの Myspell か Hunspell のために作ら
れるファイルは特別なフィールドを持つエントリを多く含んでいるかも知れない。多く
のエラーを回避するために IGNOREEXTRA フラグを使用する。


CIRCUMFIX						*spell-CIRCUMFIX*

CIRCUMFIX フラグは同時に付加されなければならない接頭辞と接尾辞を意味する。もし
も接頭辞が CIRCUMFIX フラグを持つのなら、CIRCUMFIX フラグを持つ接尾辞のみが追
加される。そして、その反対も。
代替としては接尾辞だけを指定し、その接尾辞に 2 つのフラグを与える。: それは必
要とされる接頭辞と NEEDAFFIX フラグである。|spell-NEEDAFFIX|


PFXPOSTPONE						*spell-PFXPOSTPONE*

接辞ファイルが多くの単語に適用可能なたくさんの接辞を含む場合、全ての単語リスト
をメモリ内でビルドすることはできない。これはヘブライ語 (全ての単語のリストはギ
ガバイトを超える) に適用する。この場合、適用されている接辞は後回しにされなけれ
ばならない。これはスペルチェックを遅くする。これは .aff ファイル内の次のキーワー
ドによって示される:

	PFXPOSTPONE ~

途切れた文字列やフラグなしの接頭辞だけ延期されることができる。途切れた文字列や
フラグのある接頭辞は単語リストに含まれたままだろう。もしも途切れた文字列が 1
文字で、加えられた文字列の最後の文字と等しいのならば、小文字を除いて例外である。
それゆえ、途切れた文字列は大文字で始まる単語を続けることは認められている。


スラッシュ付きの単語					*spell-SLASH*

スラッシュは .dic ファイルで基本単語を接辞文字や他のフラグと区別するために使わ
れる。不幸なことに、これは単語中でスラッシュを使えないことを意味している。それ
ゆえ、"TCP/IP" は単語ではなく、"IP" フラグをもつ "TCP" ということになる。単語
中にスラッシュを含むためには、その前にバックスラッシュを挿入する: "TCP\/IP"。
単語中にバックスラッシュを使いたいというような稀な場合があるならバックスラッシュ
を 2 つ続ける必要がある。それ以外のバックスラッシュの使用は将来の拡張のために予
約されている。


大文字小文字を保つ単語					*spell-KEEPCASE*

接辞ファイル内の KEEPCASE 行は大文字小文字を保つ単語のために使われる接辞ファイ
ルを定義するのに使われる。例:

	KEEPCASE = ~

このフラグは Myspell によってサポートされない。大文字小文字が重要であることを
意味する。もしも文章のはじめの単語が大文字で始まっていないのであれば、これを使
うことができる。例:

    単語リスト	    マッチする		    マッチしない ~
    's morgens/=    's morgens		    'S morgens 's Morgens 'S MORGENS
    's Morgens	    's Morgens 'S MORGENS   'S morgens 's morgens

フラグはまた、全てが大文字である場合に単語がマッチすることを回避するために使わ
れる。


稀な単語						*spell-RARE*

接辞ファイルで稀な単語のために使われる接辞名を定義するのに RARE 行は使われる。
例:

	RARE ? ~

稀な単語は誤りの単語とは異なるハイライトをされる。これはその言語向けの正しい単
語だがめったに使われず、入力ミスされやすい単語に使われる。同じ単語が正しい単語
として見つかると稀な単語としてハイライトされないだろう。

このフラグはさらに接辞に使われる。そのため、接辞付きの基本単語が稀な場合を除き、
基本単語は稀な単語ではない |spell-affix-flags|。しかしながら、もしも単語が他の
使い方 (例: 他の地域) で正しい単語として現れたのなら、稀な単語としてマークされ
ない。


誤った単語						*spell-BAD*

接辞ファイル内の BAD 行は、誤った単語のために使われる接辞名を定義するのに使わ
れる。例:

	BAD ! ~

これは他では正しいであろう単語を除外するのに使われる。例えば、.dic ファイル内
の "the the" である。

	the the/! ~

ひとたび誤った単語としてマークされると、同じ単語が正しいものであるとしてももと
に戻すことはできない。

フラグは接辞付きの単語にも適用する。それゆえ、関連する単語群全体を誤ったものと
してマークするのに使われる。

							*spell-FORBIDDENWORD*
FORBIDDENWORD は BAD とほとんど同じように使うことができる。Hunspell と互換。

							*spell-NEEDAFFIX*
NEEDAFFIX フラグは単語が接辞と共に使われることを要求するために使われる。単語そ
れ自身は正しい単語ではない (接辞が空でない限り)。例:

	NEEDAFFIX + ~


複合語							*spell-compound*

複合語は .dic ファイル内にある単語を連結することによって作られた長い単語である。
連結されているかもしれない単語を明示するために、文字が使われる。この文字は単語
の後の接辞リストに書かれる。この文字をここではフラグと呼ぼう。明らかに、これら
のフラグは接辞の ID で使われているどんなものとも異なっていなければならない。

							*spell-COMPOUNDFLAG*
Myspell 互換の方法は COMPOUNDFLAG で指定された 1 つのフラグを使う。このフラグ
を持つ単語は全て任意の順番に結合する。これはどの単語が最初にくるのかを制御しな
いことを意味する。例:
	COMPOUNDFLAG c ~

							*spell-COMPOUNDRULE*
複合語がどのように合成されるかを示すより進んだ方法は、複数のフラグを持った複数
の要素を使うことである。これは Myspell 3.0 と互換性を持たない。次の例から始めよ
う:
	COMPOUNDRULE c+ ~
	COMPOUNDRULE se ~

最初の行は "c" フラグを持つ単語が任意の順番で繋がれることを定義する。2 行目は
"s" フラグを持つ単語 1 つと "e" フラグを持つ単語 1 つからなる複合語を定義して
いる。次の内容の辞書からは:
	bork/c ~
	onion/s ~
	soup/e ~

これらの単語を作ることができる:
	bork
	borkbork
	borkborkbork
	(etc.)
	onion
	soup
	onionsoup

COMPOUNDRULE 要素は何度も目にするかもしれない。引数は 1 つもしくはそれ以上のグ
ループを作り上げる。それぞれのグループは次のようになる:
	one flag			e.g., c
	alternate flags inside []	e.g., [abc]
任意に次の記号を続けられる:
	*	ゼロもしくはそれ以上現れる。例: sm*e
	+	1 回もしくはそれ以上現れる。例: c+
	?	ゼロもしくは 1 回のみ現れる。例: x?

これは正規表現の文法に似ている (しかし、同じではない!)。いくつかの必要な単語フ
ラグの一連の例:
    COMPOUNDRULE x+	    x xx xxx etc.
    COMPOUNDRULE yz	    yz
    COMPOUNDRULE x+z	    xz xxz xxxz etc.
    COMPOUNDRULE yx+	    yx yxx yxxx etc.
    COMPOUNDRULE xy?z	    xz xyz

    COMPOUNDRULE [abc]z    az bz cz
    COMPOUNDRULE [abc]+z   az aaz abaz bz baz bcbz cz caz cbaz etc.
    COMPOUNDRULE a[xyz]+   ax axx axyz ay ayx ayzz az azy azxy etc.
    COMPOUNDRULE sm*e	    se sme smme smmme etc.
    COMPOUNDRULE s[xyz]*e  se sxe sxye sxyxe sye syze sze szye szyxe  etc.

特別な例: 2 つの単語とダッシュから作られる合成を許す:
	.aff ファイル内で:
	    COMPOUNDRULE sde ~
	    NEEDAFFIX x ~
	    COMPOUNDWORDMAX 3 ~
	    COMPOUNDMIN 1 ~
	.dic ファイル内で:
	    start/s ~
	    end/e ~
	    -/xd ~

これは単語 "start-end" を許すが、"startend" は許可しない。

さらなる暗黙のルールには次のようなものがある。これ以上のフラグなしで、接頭辞を
持つ単語は他の単語の後ろに結合されない。接尾辞を持つ単語は単語の前に結合されな
い。それゆえ、接辞は複合語の内側には現れない。これは
|spell-COMPOUNDPERMITFLAG| で変更することができる。

							*spell-NEEDCOMPOUND*
NEEDCOMPOUND フラグは単語が複合語の一部として使われることを要求するのに使われ
る。単語それ自身は正しい単語ではない。例:

	NEEDCOMPOUND & ~

							*spell-ONLYINCOMPOUND*
ONLYINCOMPOUND は NEEDCOMPOUND とまったく同じである。Hunspell との互換性のため
にサポートされている。

							*spell-COMPOUNDMIN*
合成するのに使われる単語の最小文字数は COMPOUNDMIN で指定される。例:
	COMPOUNDMIN 5 ~

省略された時は最小値はない。それよりも、明らかに短い単語からの合成フラグを省く
だけでよい。この機能は Myspell との互換性のためにある。

							*spell-COMPOUNDWORDMAX*
複合語の中に結合されうる単語の最大値は COMPOUNDWORDMAX で指定される。例:
	COMPOUNDWORDMAX 3 ~

省略されているときに最大値はない。すべての複合単語を適用する。

特定のフラグをもつ単語の制限を設定するために、COMPOUNDRULE 内の項目を確認する。
ここでは多すぎる単語を許可しないようだ。

							*spell-COMPOUNDSYLMAX*
複合語が含まれているかもしれない音節の最大値は COMPOUNDSYLMAX で指定される。
例:
	COMPOUNDSYLMAX 6 ~

SYLLABLE 項目がなければ効果はない。COMPOUNDSYLMAX がないと、音節の数に制限はな
い。

COMPOUNDWORDMAX と COMPOUNDSYLMAX の双方が定義されているなら、基準の 1 つに適
合している場合は複合語は認められる。それゆえ、COMPOUNDWORDMAX までの単語から作
成されるか、または COMPOUNDSYLMAX までの音節を含んでいるかのどちらかである。

						    *spell-COMPOUNDFORBIDFLAG*
COMPOUNDFORBIDFLAG は 1 つの接辞で使われるフラグを指定する。接辞を加える単語は
複合語の中で使うことができないことを意味する。例:
	接辞ファイル:
		COMPOUNDFLAG c ~
		COMPOUNDFORBIDFLAG x ~
		SFX a Y 2 ~
		SFX a 0 s   . ~
		SFX a 0 ize/x . ~
	辞書:
		word/c ~
		util/ac ~

これは "wordutil" と "wordutils" は認めるが、"wordutilize" は認めない。
Note: これは後回しにされた接頭辞にはまだ作用しない。

						    *spell-COMPOUNDPERMITFLAG*
COMPOUNDPERMITFLAG は接辞に使われるフラグを明示する。接辞を加える単語はまた、
接辞が単語の途中で終わるような複合語の中で使うことができることを意味する。この
フラグなしでは、認められない。
Note: これは後回しにされた接頭辞にはまだ作用しない。

						    *spell-COMPOUNDROOT*
COMPOUNDROOT フラグはすでに合成される辞書の単語のために使われる。これは結合の
ルールを確認したときに、2 つの単語を数えることを意味する。接辞を複合語として数
えるための接辞として使うこともできる。

						*spell-CHECKCOMPOUNDPATTERN*
CHECKCOMPOUNDPATTERN はパターンを定義するのに使われる。そのパターンというのは
2 つの単語がお互いに合成されている位置が一致しているときに結合を禁止するという
ものだ。例:
	CHECKCOMPOUNDPATTERN o e ~

これは、最初の単語が "o" で終わり、2 つ目の単語が "e" で始まる場合に結合を禁止
するというものだ。

引数がプレーンテキストでなければならず、項目名にもかかわらず、実際にサポートさ
れるパターンはない。大文字小文字は常に無視される。

3 つの引数とフラグを使用する Hunspell 機能はサポートされない。

							*spell-NOCOMPOUNDSUGS*
この項目は、提案するために合成を使うことは良いアイデアではないことを示す。合成
がとても短い、もしくは 1 文字の単語で使われる場合、これを使用する。例えば、桁
外の数字を作るときである。このフラグがないと、提案を作るために奇妙な複合語のす
べてを試す膨大な時間を費やすことになるだろう。

	NOCOMPOUNDSUGS ~

							*spell-SYLLABLE*
SYLLABLE 項目は、単語の音節の数字を数えるために使われる文字もしくは文字の並び
を定義する。例:
	SYLLABLE aáeéiíoóöõuúüûy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui ~

最初のスラッシュの前は 1 つの音節として数えられる文字セットで、繰り返しや混合
も含み、このセット内に無い次の文字までである。スラッシュの後には 1つの音節とし
て数えられる文字列が来る。これらは、セットから文字を使うよりも望ましい。例とし
て、"ideeen" は 3 つの音節を持っていて、"i" と "ee" そして、"e" のように数えら
れる。

ケースフォールドされた文字だけが含まれる必要がある。

合成を制限する他の方法は、上で述べられている: |spell-COMPOUNDFORBIDFLAG| フラ
グを接辞に加えることは、その接辞から作られるすべての単語が合成のために使われな
いことの原因となる。


制限の無い合成						*spell-NOBREAK*

タイ語のようないくつかの言語では、分かち書きをしない。これはすべての単語が結合
しているように見える。これを明示するために、接辞ファイルで NOBREAK 項目を引数
無しで使う:
	NOBREAK ~

Vim は単語の終わりと次の始まりがどこにあるかを見つけ出そうとする。スペルミスが
あった場合、この動作は完全には正しく行われないだろう。


							*spell-COMMON*
共通語は COMMON 項目で明示される。小さなファイルを編集している時ほど、より良い
提案をしてくれるだろう。例:

	COMMON  the of to and a in is it you that he was for on are ~

単語は 1 行につき 25 個までで、かつ空白で区切られていなければならない。
":mkspell" コマンドで複数の地域が指定されている場合、すべての地域の共通語は結
合され、すべての範囲で使われる。

							*spell-NOSPLITSUGS*
この項目は、提案を作るための単語の分割は良いアイデアでは無いことを示す。分割語
の提案は、似たような単語がほとんどない場合のみ出現するだろう。

	NOSPLITSUGS ~

							*spell-NOSUGGEST*
NOSUGGEST と共に使われるフラグは、提案されることがないであろう単語のために使わ
れる。汚らしい単語のために使うことができる。

	NOSUGGEST % ~


置換							*spell-REP*

接辞ファイルの REP 項目は共通の誤りを定義するのに使われる。これはスペルの提案
を生成するのに使われる。次の項目は "from" のテキストと "to" の置換を定義する。
例:

	REP 4 ~
	REP f ph ~
	REP ph f ~
	REP k ch ~
	REP ch k ~

最初の行は REP 行が続く数を明示する。Vim はこの数字を無視するが、この数字はそ
こになくてはならない (Myspell との互換性のため)。

簡易な 1 文字の置換や交換を含んではならない。Vim はこれらをどうにかして実行し
ようとする。もしそうしたいのであれば、すべての単語を含めることができるが、代わ
りに 'spellsuggest' の "file:" 項目を使いたいと思うかもしれない。

アンダースコアを使ってスペースを含めることができる。

	REP the_the the ~


類義文字						*spell-MAP* *E783*

接辞ファイルの MAP 項目は非常によく似た文字を定義するのに使うことができる。こ
れは異なったアクセントの文字のために使われることがほとんどである。これはむしろ
これらの文字を置換する提案に使われる。例:

	MAP 2 ~
	MAP eéëêè ~
	MAP uüùúû ~

最初の行は MAP 行が続く数を明示する。Vim はこの数字を無視するが、この数字はそ
こになくてはならない。

それぞれの文字は、MAP　項目中に 1 つのみでなければならない。最初の文字が ASCII
であるか少なくともアクセント文字でなければ、少しばかり効率が良い。


.SUG ファイル						*spell-NOSUGFILE*

soundfolding が接辞ファイルで明示されているとき、":mkspell" は通常、.spl ファ
イルの隣に .sug ファイルを生成する。このファイルは sound-a-like 形式によって、
すばやく提案を見つけるために使われる。多くのメモリを犠牲にする (総量は単語の数
に依存し、|:mkspell| は終了時に概算を表示するだろう)。

.sug ファイルを生成しないようにするには affix ファイル中に次の項目を使う。

	NOSUGFILE ~

使うことを望まないならば、ユーザーは .sug ファイルを簡単に取り除くことができる。


SOUND-A-LIKE						*spell-SAL*

接辞ファイルの SAL 項目は sounds-a-like の仕組みを定義するのに使われる。主な項
目は "from" テキストと "to" 置換を定義する。簡単な例:

	SAL CIA			 X ~
	SAL CH			 X ~
	SAL C			 K ~
	SAL K			 K ~

ここには少しのルールがあるが、非常に複雑になる。どのように動作するのかの説明は
Aspell のマニュアルで見つけることができる:
http://aspell.net/man-html/Phonetic-Code.html.

特別な項目がいくつかある:

	SAL followup		true ~
	SAL collapse_result	true ~
	SAL remove_accents	true ~

"1" は "true" と同じ意味である。他の値は "false" を意味する。


SIMPLE SOUNDFOLDING				*spell-SOFOFROM* *spell-SOFOTO*

SAL の仕組みは複雑で遅い。単純な仕組みはすべての文字を他の文字とマッピングし、
似たように聞こえる文字を同じ文字とマッピングする。同時に、ケースフォールディン
グをする。SAL 項目と単純な soundfolding の両方を持つことはできない。

要求される 2 つの項目がある: 1 つはマップされた文字を明示し、もう 1 つはそれら
がマップされている文字を明示するためのものだ。これらは厳密に同じ文字数でなけれ
ばならない。例:

    SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ~
    SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkes ~

例では、すべての母音は同じ文字 'e' にマップされている。もう 1 つのやり方ではす
べての母音を除去するものである。いくつかの同じように聞こえ、しばしば混合される
'm' や 'n' のような文字は、同じ文字にマップされている。やり過ぎないこと。すべ
ての単語は同じように見え始めるだろう。

SOFOFROM で現れない文字は、すべての空白が 1 つの空白に置き換えられることを除き、
除去されるだろう。SOFOFROM の同じ文字の連続は 1 つに置き換えられる。

結果を試すために |soundfold()| 関数を使うことができる。もしくは、|z=| コマンド
の出力するスコアを見るために、'verbose' オプションを設定することができる。


サポートされていない項目				*spell-affix-not-supported*

これらの項目は他のスペルチェッカーの接辞ファイルの中に現れる。Vim ではこれらは
無視され、サポートされていない、もしくは他の方法で定義される。

ACCENT		(Hunspell)				*spell-ACCENT*
		代わりに MAP を使う。|spell-MAP|

BREAK		(Hunspell)				*spell-BREAK*
		ブレークポイントを定義する。厳密にどのような動作をするのかははっ
		きりしない。サポートされていない。

CHECKCOMPOUNDCASE  (Hunspell)			*spell-CHECKCOMPOUNDCASE*
		複合語の境界の文字について大文字を許さない。サポートされていな
		い。

CHECKCOMPOUNDDUP  (Hunspell)			*spell-CHECKCOMPOUNDDUP*
		複合語中で同じ単語を 2 回使うことを許さない。サポートされてい
		ない。

CHECKCOMPOUNDREP  (Hunspell)			*spell-CHECKCOMPOUNDREP*
		REP 項目と複合語を使う何か。サポートされていない。

CHECKCOMPOUNDTRIPLE  (Hunspell)			*spell-CHECKCOMPOUNDTRIPLE*
		合成時に 3 つの同一の文字を禁止する。サポートされていない。

CHECKSHARPS  (Hunspell))			*spell-CHECKSHARPS*
		大文字の(ドイツ語)単語のSS文字のペアは大文字のシャープ s (ß)
		かもしれない。サポートされていない。

COMPLEXPREFIXES  (Hunspell)				*spell-COMPLEXPREFIXES*
		2 つの接頭辞の使用を可能にする。サポートされていない。

COMPOUND	(Hunspell)				*spell-COMPOUND*
		COMPOUND 項目の総数を持つ 1 行で、パターンを含む多くの
		COMPOUND 行が後ろに続く。
		総数を持つ最初の行は削除され、他の項目は COMPOUNDRULE にリネー
		ムされる。|spell-COMPOUNDRULE|

COMPOUNDFIRST	(Hunspell)				*spell-COMPOUNDFIRST*
		代わりに COMPOUNDRULE を使う。|spell-COMPOUNDRULE|

COMPOUNDBEGIN	(Hunspell)				*spell-COMPOUNDBEGIN*
		COMPOUNDBEGIN の印が付けられた単語は、複合語の最初の要素にな
		る。
		代わりに COMPOUNDRULE を使う。|spell-COMPOUNDRULE|

COMPOUNDLAST	(Hunspell)				*spell-COMPOUNDLAST*
		COMPOUNDLAST の印が付けられた単語は、複合語の最後の要素になる。
		代わりに COMPOUNDRULE を使う。|spell-COMPOUNDRULE|

COMPOUNDEND	(Hunspell)				*spell-COMPOUNDEND*
		おそらく COMPOUNDLAST と同じ

COMPOUNDMIDDLE	(Hunspell)				*spell-COMPOUNDMIDDLE*
		COMPOUNDMIDDLE の印が付けられた単語は、複合語の中間要素になる
		ことがある。
		代わりに COMPOUNDRULE を使う。|spell-COMPOUNDRULE|

COMPOUNDRULES	(Hunspell)				*spell-COMPOUNDRULES*
		COMPOUNDRULE 行の続く数。無視されるが、引数は 1 つの数値でなけ
		ればならない。

COMPOUNDSYLLABLE  (Hunspell)			*spell-COMPOUNDSYLLABLE*
		代わりに SYLLABLE と COMPOUNDSYLMAX を使う。|spell-SYLLABLE|
		|spell-COMPOUNDSYLMAX|

KEY		(Hunspell)				*spell-KEY*
		キーボード上で互いに近接する文字を定義する。よりよい提案を与え
		るのに使われる。サポートされていない。

LANG		(Hunspell)				*spell-LANG*
		language-specifies の挙動を明示する。これは実際に言語情報の一
		部をプログラム中に移動する。それゆえ、Vim はサポートしていない。
		それぞれの言語の特徴は個別に明示されていなければならない。

LEMMA_PRESENT	(Hunspell)				*spell-LEMMA_PRESENT*
		形態素解析のためだけに必要とされる。

MAXNGRAMSUGS	(Hunspell)				*spell-MAXNGRAMSUGS*
		n-gram 提案の数を設定する。サポートされていない。

PSEUDOROOT	(Hunspell)				*spell-PSEUDOROOT*
		代わりに NEEDAFFIX を使う。|spell-NEEDAFFIX|

SUGSWITHDOTS	(Hunspell)				*spell-SUGSWITHDOTS*
		提案にドットを加える。Vim はこれを必要としない。

SYLLABLENUM	(Hunspell)				*spell-SYLLABLENUM*
		サポートされていない。

TRY		(Myspell, Hunspell, others)		*spell-TRY*
		Vim は TRY 項目を使わず、無視する。提案を生成するために、実際
		の単語の文字が使われる。これは非常に効率がよい。

WORDCHARS	(Hunspell)				*spell-WORDCHARS*
		単語を評価するために使われる。Vim は必要としない。なぜなら、こ
		れらをチェックする前に単語を分ける必要がないからである (ハッシュ
		テーブルの代わりにトライを使っている)。

 vim:tw=78:sw=4:ts=8:noet:ft=help:norl:
