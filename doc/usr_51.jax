*usr_51.txt*	For Vim バージョン 9.0.  Last change: 2022 Jun 03

		     VIM USER MANUAL - by Bram Moolenaar

			      プラグインを作る


プラグインを使用することで、特定のファイルの種別の設定、構文ハイライトやその他
多くの設定を定義できます。
この章ではVimプラグインでのもっとも共通な部分の書き方について説明します。

|51.1|	一般的なプラグインを書く
|51.2|	ファイルタイププラグインを書く
|51.3|	コンパイラプラグインを書く
|51.4|	Vim script を配布する

次章: |usr_52.txt|  大きなプラグインを作る
前章: |usr_50.txt|  高度な Vim script の書き方
目次: |usr_toc.txt|

==============================================================================
*51.1*	一般的なプラグインを書く			*write-plugin*

Vim script を書いて、それを多くの人に使ってもらうことができます。そのようなス
クリプトはプラグインと呼ばれます。Vim ユーザーはあなたのスクリプトをプラグイン
ディレクトリにコピーするだけで、すぐにその機能を使うことができます。
|add-plugin| 参照。

プラグインには二種類あります:

      グローバルプラグイン : すべてのファイルで共通
  ファイルタイププラグイン : ファイルの種類別

この節ではグローバルプラグインについて説明します。ほとんどの説明はファイルタイ
ププラグインに対してもあてはまります。ファイルタイププラグイン特有の説明は次節
にあります |write-filetype-plugin|。

新しいプラグインを書くのに推奨される方法なので、ここでは |Vim9| の文法を使いま
す。ファイルが `vim9script` コマンドで始まることを確認してください。


☆名前

最初にプラグインの名前を決めなければなりません。プラグインが提供する機能が名前
から分かるようにしてください。また、他の人が作ったプラグインと名前がかぶらない
ようにしてください。

例えばタイプミス (type mistake) を修正 (correct) するためのスクリプトなら
"typecorrect.vim" という名前を付けたりします。ここではこれを例題として使いま
す。

プラグインが誰でも使えるようにするため、いくつかのガイドラインに従ってくださ
い。ガイドラインは段階的に説明していきます。例題プラグインの完全なソースは最後
に示します。


☆ボディ

まずはプラグインの本体部分を見てみましょう。行番号は実際の番号です: >

 12	iabbrev teh the
 13	iabbrev otehr other
 14	iabbrev wnat want
 15	iabbrev synchronisation
 16		\ synchronization

もちろん、実際のリストはもっと長いです。

行番号は説明のために追加したものです。プラグインを書くときは行番号を付けないで
ください。


☆最初の行
>
  1	vim9script noclear

`vimi9script` を一番最初のコマンドとして使用する必要があります。一番最初の行に
記述するのがベストです。

作成しているスクリプトは、2回目にロードされたときに終了するための `finish` コ
マンドがあります。スクリプトで定義された項目が失われるのを防ぐために、
"noclear" 引数を使用します。詳しくは |vim9-reload| をご覧ください。


☆ヘッダー

新しい単語を追加していくと、プラグインには複数のバージョンが存在することになり
ます。ファイルを配布したとき、それを使った人は、誰がこの素晴らしいプラグインを
書いたのかを知りたいと思うでしょうし、感想を伝えたいと思うかもしれません。
というわけで、次のようなヘッダーをプラグインに書いてください: >

  2	# Vim global plugin for correcting typing mistakes
  3	# Last Change:	2021 Dec 30
  4	# Maintainer:	Bram Moolenaar <Bram@vim.org>

著作権とライセンスについて: プラグインがとても便利で、そして再配布を制限するほ
どのものでない場合は、パブリックドメインか Vim ライセンス (|license|) の適用を
検討してみてください。次の短い宣言をプラグインの先頭付近に書いておくだけで十分
です: >

  5	# License:	This file is placed in the public domain.


ロードしない
------------

ユーザーが常にプラグインをロードしたいと思うとは限りません。また、システム管理
者がシステムのプラグインディレクトリにプラグインを入れたが、ユーザーは自分で入
れたプラグインを使いたいということもあります。したがって、指定したプラグインだ
けを無効にできる必要があります。次の行のようにします: >

  7	if exists("g:loaded_typecorrect")
  8	  finish
  9	endif
 10	g:loaded_typecorrect = 1

これはスクリプトの2重ロードで関数が無意味に再定義されることと自動コマンドが2重
に追加されるのを避ける効果もあります。

変数の名前は "g:loaded_" で始めてプラグインのファイル名をそのまま付けるように
してください。"g:" を付けることで変数をグローバルにし、他の箇所で機能があるか
チェックできるようにします。"g:" を付けないとスクリプトローカルになります。

`finish` を使ってファイルの残りの部分の読み込みを停止しています。Vimはコマンド
を解析して `endif` を見つける必要があるため、この方法はファイル全体を if-endif
で囲むよりもはるかに高速です。


☆マップ

さて、プラグインをもっと魅力あるものに仕上げましょう。マップを追加して、カーソ
ルの下の単語に対する修正を追加できるようにします。単純にキーを選んでマップを設
定することもできますが、そのキーは既にユーザーが使っているかもしれません。マッ
プに使用するキーをユーザーが選択できるようにするには、<Leader> を使います: >

 20	  map <unique> <Leader>a  <Plug>TypecorrAdd;

"<Plug>TypecorrAdd;" は目的の動作をします。詳しくは後で説明します。

使用したいキーを "g:mapleader" 変数に設定することで、プラグインのマップの最初
のキーを設定できます。例えば、次のように設定すると: >

	g:mapleader = "_"

マップは "_a" と定義されます。変数が設定されていない場合は初期設定 (バックス
ラッシュ) が使われます。つまり "\a" というマップが定義されます。

Note: 上記のコマンドでは <unique> が使われています。これは、同じマップが既に定
義されていた場合にエラーを表示します。|:map-<unique>|

マップするキーをユーザーが自分で定義できるようにするには、次のようにします: >

 19	if !hasmapto('<Plug>TypecorrAdd;')
 20	  map <unique> <Leader>a  <Plug>TypecorrAdd;
 21	endif

"<Plug>TypecorrAdd;" に対するマップが既にあるかどうかを調べ、無い場合のみ
"<Leader>a" にマップを定義します。ユーザーは自分の vimrc ファイルの中でマップ
を定義することができます: >

	map ,c  <Plug>TypecorrAdd;

すると、マップのキーとして ",c" が使われます。"_a" や "\a" は使われません。


☆ピース

スクリプトが大きくなると、それを部品ごとに分けたくなります。それには関数やマッ
プを使います。しかし、そうすると関数やマップが他のスクリプトのものと衝突する可
能性があります。例えば、Add() という関数を追加したとき、他のスクリプトでも同じ
名前の関数が定義されているかもしれません。そのような場合は、スクリプトの中だけ
で使える関数を定義します。
幸いにも、|Vim9| script では、これがデフォルトです。旧来のスクリプトでは、名前
の前に "s:" を付ける必要があります。

新しい修正を追加するための関数を定義します: >

 28	def Add(from: string, correct: bool)
 29	  var to = input($"type the correction for {from}: ")
 30	  exe $":iabbrev {from} {to}"
 ...
 34	enddef

Add() 関数は同じスクリプトの中から呼び出すことができます。他のスクリプトが
Add() を定義していた場合、それはそのスクリプトにローカルであり、スクリプトの中
からのみ呼び出すことができます。さらにグローバルの g:Add() 関数を定義すること
もでき、それはまた別の関数になります。

マップ定義では <SID> が使えます。これは、現在のスクリプトを識別するためのスク
リプト ID を生成します。私たちの入力修正プラグインでは <SID> を次のように使い
ます: >

 22	noremap <unique> <script> <Plug>TypecorrAdd;  <SID>Add
 ...
 26	noremap <SID>Add  :call <SID>Add(expand("<cword>"), true)<CR>

ユーザーが "\a" と入力すると、次の手順でキー入力が呼び出されます: >

	\a  ->  <Plug>TypecorrAdd;  ->  <SID>Add  ->  :call <SID>Add(...)

他のスクリプトで <SID>Add をマップすると、別のスクリプト ID が使われ、別のマッ
プが生成されます。

Note: Add() ではなく <SID>Add() と書いていることに注意してください。マップはス
クリプトコンテキストの外側でユーザーが入力するものだからです。<SID> はスクリプ
ト ID に変換され、どのスクリプトの Add() 関数を呼べばいいのかわかるようになっ
ています。

これは少し複雑ですが、複数のプラグインを同時に使用するためには必要なことです。
基本的なルールとしては、マップの中では <SID>Add() を使い、他の場所 (スクリプト
の中、自動コマンド、ユーザー定義コマンド) では Add() を使います。

マップと同じ方法で、メニューを追加することもできます: >

 24	noremenu <script> Plugin.Add\ Correction      <SID>Add

プラグインのメニューを追加する場合は "Plugin" メニューの下に登録することが推奨
されています。この例ではメニューが一つだけですが、複数のメニューを追加する場合
は、サブメニューの使用が推奨されています。例えば、"Plugin.CVS" 以下に
"Plugin.CVS.checkin" や "Plugin.CVS.checkout" などの CVS の操作を登録します。

Note: 28 行目では ":noremap" を使って、他のマップでトラブルが起きないようにし
ています。例えば、誰かが ":call" をマップしているかもしれないからです。24 行目
でも ":noremap" を使っていますが、ここでは "<SID>Add" を再マップして欲しいの
で、"<script>" を使っています。これを使うとスクリプトローカルなマップだけが再
マップされます |:map-<script>|。26 行目でも ":noremenu" で同様のことをしていま
す |:menu-<script>|。


<SID> と <Plug>						*using-<Plug>*
---------------

<SID> と <Plug> は、入力したキーに対するマップと、他のマップの中だけで使われる
マップが干渉しないようにするために使われます。<SID> と <Plug> の違いに注意して
ください:

<Plug>	これはスクリプトの外側からも見えます。ユーザーが自分でプラグインの機能
	をマップできるようにするような場合に使います。<Plug> は特殊なコード
	で、キーボードから入力されることはありません。
	キー列が他のプラグインとかぶらないように、<Plug> スクリプト名 マップ
	名、という形式で使ってください。
	セミコロンを終端として追加しています。我々の例では、スクリプト名が
	"Typecorr"、マップ名が "Add" なので、"<Plug>TypecorrAdd;" というキー列
	になります。スクリプト名とマップ名の最初の文字だけを大文字にして、どこ
	がマップ名なのかわかるようにします。

<SID>	これはスクリプト ID (スクリプト固有の識別子) です。
	Vim は内部で <SID> を "<SNR>123_" に変換します ("123" の部分はいろいろ
	な数字が入ります)。つまり、関数 "<SID>Add()" は、あるスクリプトでは
	"<SNR>11_Add()" という名前になり、別のスクリプトでは "<SNR>22_Add()"
	になります。これは ":function" コマンドで関数一覧を表示すると確認する
	ことができます。<SID> の変換はマップの中でも同様におこなわれるので、
	マップの中からスクリプトローカル関数を呼び出すことができます。


☆ユーザー定義コマンド

修正を追加するためのユーザー定義コマンドを追加します: >

 36	if !exists(":Correct")
 37	  command -nargs=1  Correct  :call Add(<q-args>, false)
 38	endif

ユーザー定義コマンドは、同じ名前のコマンドがまだない場合のみ定義できます。既に
定義されている場合はエラーになります。":command!" を使ってユーザー定義関数を上
書きするのは良いアイデアとは言えません。ユーザーは、自分が定義したコマンドがな
ぜ動かないのか不思議に思うでしょう。|:command|
だれの責任でそうなってしまったのか見付けるには: >

	verbose command Correct


☆スクリプト変数

先頭に "s:" が付いた変数はスクリプト変数です。これはスクリプトの中だけで使えま
す。スクリプトの外からは見えません。同じ名前の変数を複数のスクリプトで使ってし
まうようなトラブルを避けることができます。Vim が実行されている間、変数は保持さ
れます。そして、同じスクリプトが再読み込みされると、再び同じ変数が使われます。
|s:var|

スクリプト変数は、同じスクリプトの中で定義された関数、自動コマンド、ユーザー定
義コマンドでも使えます。我々の例に、修正の数を数えるための数行のコードを追加し
ます

|Vim9| script の良いところは、変数がデフォルトでスクリプトローカルであるという
ことです。必要に応じて "s:" を前に付けることができますが、そうする必要はありま
せん。また、スクリプト内の関数も、プリフィックスなしでスクリプト変数を使用する
ことができます(これが機能するには、関数の前に宣言する必要があります)。

スクリプトローカル変数は、スクリプト内で定義した関数、自動コマンド、ユーザーコ
マンド内でも使用できます。したがって、プラグイン内の部品間で情報を漏らさずに共
有するための最適な方法です。この例では、修正回数を数えるための行をいくつか追加
することができます: >

 17	var count = 4
 ...
 28	def Add(from: string, correct: bool)
 ...
 32	  count += 1
 33	  echo "you now have " .. count .. " corrections"
 34	enddef

"count" はスクリプト内の 4 で宣言と初期化がされます。その後、Add() 関数が呼び
出されると、"count" がインクリメントされます。関数がどこから呼ばれたかにかかわ
らず、関数が定義されたスクリプトのローカル変数を使用します。


☆まとめ

例題の完成形は以下のようになります: >

  1	vim9script noclear
  2	# Vim global plugin for correcting typing mistakes
  3	# Last Change:	2021 Dec 30
  4	# Maintainer:	Bram Moolenaar <Bram@vim.org>
  5	# License:	This file is placed in the public domain.
  6
  7	if exists("g:loaded_typecorrect")
  8	  finish
  9	endif
 10	g:loaded_typecorrect = 1
 11
 12	iabbrev teh the
 13	iabbrev otehr other
 14	iabbrev wnat want
 15	iabbrev synchronisation
 16		\ synchronization
 17	var count = 4
 18
 19	if !hasmapto('<Plug>TypecorrAdd;')
 20	  map <unique> <Leader>a  <Plug>TypecorrAdd;
 21	endif
 22	noremap <unique> <script> <Plug>TypecorrAdd;  <SID>Add
 23
 24	noremenu <script> Plugin.Add\ Correction      <SID>Add
 25
 26	noremap <SID>Add  :call <SID>Add(expand("<cword>"), true)<CR>
 27
 28	def Add(from: string, correct: bool)
 29	  var to = input("type the correction for " .. from .. ": ")
 30	  exe ":iabbrev " .. from .. " " .. to
 31	  if correct | exe "normal viws\<C-R>\" \b\e" | endif
 32	  count += 1
 33	  echo "you now have " .. count .. " corrections"
 34	enddef
 35
 36	if !exists(":Correct")
 37	  command -nargs=1  Correct  call Add(<q-args>, false)
 38	endif

31 行目は説明がまだでした。これは、新しい修正をカーソルの下の単語に適用しま
す。|:normal| コマンドを使って新しい略語を適用しています。Note: マップと略語は
その場で展開されます。":noremap" で定義されたマップから関数が呼び出されたとし
ても動作は同じです。


☆ドキュメント						*write-local-help*

プラグインのドキュメントを書くのは良いアイデアです。ユーザーが動作を変更できる
ような場合には特に重要です。|add-local-help| ではどのようにしてドキュメントが
インストールされるか説明されています。

プラグインヘルプファイルの例を示します ("typecorrect.txt"): >

  1	*typecorrect.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd;
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorrect-settings*
 17	This plugin doesn't have any settings.

書式に気をつけなければならないのは一行目だけです。一行目はコピーされ、help.txt
の "LOCAL ADDITIONS:" の項に埋め込まれます |local-additions|。最初の "*" は一
行目の一桁目に書いてください。ヘルプを追加したら ":help" を実行して項目が追加
されたことを確認してください。

ヘルプの中で ** で文字を囲むとタグを追加することができます。ただし、既存のヘル
プタグと同じものを使わないでください。"typecorrect-settings" のように、プラグ
インの名前を使ってタグを作るといいかもしれません。

ヘルプの他の部分を参照するときは || で囲みます。そうすれば、ユーザーは簡単にヘ
ルプの関連した部分を参照することができます。


☆要約							*plugin-special*

プラグインで使用する特有事項の要約を示します:

var name		スクリプトローカル変数。

<SID>			スクリプトID。マップや関数をスクリプトローカルにする
			のに使う。

hasmapto()		スクリプトが提供している機能に対して、ユーザーが既に
			マップを定義したかどうかをチェックする関数。

<Leader>		"mapleader" の値。ユーザーがその変数にキーを設定するこ
			とで、プラグインのマップの開始キーを指定できる。

map <unique>		マップが既に定義されているなら警告を発する。

noremap <script>	スクリプトローカルマップだけを使う。グローバルマップは
			使わない。

exists(":Cmd")		ユーザー定義コマンドが既にあるかどうかをチェックする。

==============================================================================
*51.2*	ファイルタイププラグインを書く	*write-filetype-plugin* *ftplugin*

ファイルタイププラグインはグローバルプラグインと似ていますが、カレントバッファ
のマップやオプションだけを設定します。ファイルタイププラグインの使用方法につい
ては |add-filetype-plugin| を参照してください。

先に |51.1| 節のグローバルプラグインの項を読んでください。そこで説明されている
ことはすべてファイルタイププラグインにもあてはまります。この節ではファイルタイ
ププラグイン特有の事項だけを説明します。ファイルタイププラグインはカレントバッ
ファに対してのみ機能するということが最も大切です。


☆無効化

ファイルタイププラグインを書いて多くの人に使ってもらおうとするなら、プラグイン
を無効化できるようにしておく必要があります。プラグインの先頭に次のような記述を
追加してください: >

	# このバッファに対してまだ実行されていない場合のみ処理を実行する
	if exists("b:did_ftplugin")
	  finish
	endif
	b:did_ftplugin = 1

これは同じプラグインが同じバッファで二重にロードされるのを防ぐためにも必要です
(":edit" コマンドを引数なしで実行したときに発生します)。

ユーザーは、次の行を書いたファイルタイププラグインを作成することで、標準プラグ
インのロードを無効化できます: >

	vim9script
	b:did_ftplugin = 1

ただし、そのファイルを保存したファイルタイププラグインディレクトリが、
'runtimepath' の中で $VIMRUNTIME よりも前にある必要があります。

標準プラグインを使いつつ、その設定を一つだけ変更したいという場合は、スクリプト
の中で設定を変更することができます: >

	setlocal textwidth=70

このファイルを "after" ディレクトリに保存すると、(例えば filetype=vim なら) 標
準配布の "vim.vim" が読み込まれた後に、保存したファイルが読み込まれるようにな
ります |after-directory|。Unix ならファイルのパスは
"~/.vim/after/ftplugin/vim.vim" です。Note: 標準プラグインは "b:did_ftplugin"
を設定しますが、しかしここではそれを無視しています。


☆オプション

ファイルタイププラグインでは、カレントバッファの設定だけを変更するため、次のコ
マンドを使ってオプションを設定してください: >

	setlocal

そして、バッファローカルなオプションだけを設定してください (どのオプションがそ
うなのかはヘルプで確認してください)。`:setlocal` コマンドでグローバルオプショ
ンやウィンドウローカルオプションを設定すると、たくさんのバッファの設定が変更さ
れます。ファイルタイププラグインはそのような動作をすべきではありません。

オプションの値がフラグや設定項目のリストなら、"+=" や "-=" を使うことで既存の
設定を維持することができます。ユーザーがそのオプションの設定を変更している可能
性もあるので注意してください。最初に初期設定に戻してから設定を変更するといいか
もしれません。例: >

	setlocal formatoptions& formatoptions+=ro


☆マッピング

カレントバッファの中だけで機能するマップを作るには次のコマンドを使います: >

	map <buffer>

上述したように、マップは二段階に分けて作る必要があります。ファイルタイププラグ
インで機能を定義する例を示します: >

	if !hasmapto('<Plug>JavaImport;')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport;
	endif
	noremap <buffer> <unique> <Plug>JavaImport; oimport ""<Left><Esc>

|hasmapto()| を使って、ユーザーが既に <Plug>JavaImport; に対してマップを定義し
ているかどうかを調べます。未定義ならファイルタイププラグインの標準のマップを定
義します。マップは <LocalLeader> で開始します。そうすることで、ファイルタイプ
プラグインのマップを開始するキーをユーザーが選択できます。初期設定はバックス
ラッシュです。
"<unique>" を使って、マップが既に存在したとき、あるいは既存のマップと重複した
ときにエラーメッセージが表示されるようにします。
|:noremap| を使って、ユーザーが定義した他のマップの影響を受けないようにしま
す。":noremap <script>" を使うと、スクリプトの中で定義した <SID> で始まるマッ
プだけが再マップされます。

ユーザーがファイルタイププラグインのマップを無効化できる仕組みを提供しなければ
なりません。例えば、"mail" ファイルタイプのプラグインなら次のようにします: >

	# マップを追加する。ユーザーが望まない場合は追加しない。
	if !exists("g:no_plugin_maps") && !exists("g:no_mail_maps")
	  # "> " を挿入して引用する
	  if !hasmapto('<Plug>MailQuote;')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote;
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote;
	  endif
	  vnoremap <buffer> <Plug>MailQuote; :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote; :.,$s/^/> /<CR>
	endif

ここでは二つのグローバル変数が使われています:
|g:no_plugin_maps|	すべてのファイルタイププラグインのマップを無効化
|g:no_mail_maps|	"mail" ファイルタイプのマップを無効化


☆ユーザー定義コマンド

ファイルタイプ用のユーザー定義コマンドを追加して、それを一つのバッファの中だけ
で使えるようにするには、|:command| の引数に "-buffer" を指定します。例: >

	command -buffer  Make  make %:r.s


☆変数

ファイルタイププラグインは対応するすべてのバッファに対して実行されます。スクリ
プトローカル変数はすべての実行で共有されます。バッファごとの変数を使いたい場合
はバッファローカル変数 |b:var| を使ってください。


☆関数

関数は一度だけ定義すれば十分です。しかし、ファイルタイププラグインは対応する
ファイルが開かれるたびに読み込まれます。次のようにすると関数が一度だけ定義され
るようになります: >

	if !exists("*Func")
	  def Func(arg)
	    ...
	  enddef
	endif
<
スクリプトが2回目に読み込まれた時に関数が削除されるのを防ぐため、`vim9script`
コマンドに "noclear" を使用することを忘れないでください。


☆アンドゥ					*undo_indent* *undo_ftplugin*

ユーザーが ":setfiletype xyz" としたとき、それ以前のファイルタイプの効果は無効
になるべきです。b:undo_ftplugin 変数にコマンドを設定し、ファイルタイププラグイ
ンの設定をアンドゥするようにしてください。例: >

	b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ .. "| unlet b:match_ignorecase b:match_words b:match_skip"

":setlocal" でオプション名の後に "<" を付けると、そのオプションをグローバルな
値でリセットします。オプションをリセットするにはこの方法が一番です。

インデントスクリプトの効果をアンドゥする為には、それに応じた b:undo_indent 変
数を設定すべきです。

これら両方の変数は旧来のスクリプトの文法で使われ、|Vim9| の文法では使いません。


☆ファイル名

ファイルタイププラグインのファイル名にはファイルタイプ名が含まれていなければな
りません |ftplugin-name|。次の三つのうちのどれかにしてください:

	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim

"stuff" はファイルタイプ名、"foo" と "bar" は任意の名前です。


☆ファイルタイプの認識					*plugin-filetype*

ファイルタイプが Vim によって認識されない場合は、別ファイルにファイルタイプを
認識するためにコードを作成する必要があります。通常は、自動コマンドを使って、
ファイル名がパターンにマッチしたときにファイルタイプを設定します。例: >

	au BufNewFile,BufRead *.foo		setlocal filetype=foofoo

この1行のファイルを  "ftdetect/foofoo.vim" として、'runtimepath' に表示される
最初のディレクトリに書き込みます。Unix の場合、"~/.vim/ftdetect/foofoo.vim" に
なります。規則では、スクリプト名にファイルタイプ名を使用します。

必要に応じて、ファイルの内容を調べて言語を認識するなど、より複雑なチェックを行
うことができます。|new-filetype| も参照。


☆要約							*ftplugin-special*

ファイルタイププラグインの特有事項を要約します:

<LocalLeader>		"maplocalleader" の値。ユーザーがその変数にキーを設定
			することで、ファイルタイププラグインのマップの開始キー
			を指定できる。

map <buffer>		バッファローカルなマップを定義する。

noremap <script>	同スクリプトで定義している <SID> で始まるマップだけを
			再マップする。

setlocal		カレントバッファのオプションのみ設定する。

command -buffer		バッファローカルなユーザー定義コマンドを定義する。

exists("*s:Func")	関数が定義済かどうかをチェックする。

プラグイン全般に関する事項は |plugin-special| を参照してください。

==============================================================================
*51.3*	コンパイラプラグインを書く		*write-compiler-plugin*

コンパイラプラグインは特定のコンパイラを使うためのオプションを設定します。ユー
ザーは |:compiler| コマンドでその設定を読み込むことができます。設定されるオプ
ションは主に 'errorformat' と 'makeprg' です。

百聞は一見に如かず。次のコマンドですべての標準コンパイラプラグインを開くことが
できます: >

	next $VIMRUNTIME/compiler/*.vim

`:next` と打って次のプラグインファイルに移動してください。

これらのファイルには二つの特有事項があります。一つは、標準ファイルに対して設定
を追加したり上書きしたりできる仕組みです。標準ファイルの先頭は次のようになって
います: >

 	vim9script
	if exists("g:current_compiler")
	  finish
	endif
	g:current_compiler = "mine"

コンパイラファイルを書いて、それを個人用のランタイムディレクトリ (例えば Unix
なら ~/.vim/compiler) に置いたとき、"current_compiler" 変数を設定することで標
準ファイルの設定をスキップすることができます。
							*:CompilerSet*
二つ目は、":compiler!" が使われたときは ":set" を使い、":compiler" が使われた
ときは ":setlocal" を使う仕組みです。Vim はそのために ":CompilerSet" という
ユーザーコマンドを定義します。古い Vim はそれを定義しないので、プラグインの中
で定義してください。例: >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the dfault 'errorformat'
  CompilerSet makeprg=nmake

コンパイラプラグインを書いて、それを Vim の配布物に含めたり、システムのランタ
イムディレクトリに入れたりする場合は、上記の方法を使ってください。
"current_compiler" がユーザープラグインで設定された場合は何も実行しないように
します。

コンパイラプラグインを書いて標準プラグインの設定を上書きする場合は
"current_compiler" をチェックしないようにします。そのプラグインは最後に読み込
まれないといけないので、'runtimepath' の最後にあるディレクトリに置きます。例え
ば、Unix なら ~/.vim/after/compiler などです。

==============================================================================
*51.4*	Vim script を配布する			*distribute-script*

Vim ユーザーは Vim のウェブサイト http://www.vim.org でスクリプトを探します。
便利なスクリプトを作ったら、ぜひ共有しましょう！

別の場所として github があります。しかし、そこが探される場所であるとあなたは知
る必要があります!。多くのプラグインマネージャーがプラグインを github から取得
するというアドバンテージがあります。あなたが使うであろうお気に入りのサーチエン
ジンが見付けるのもそこになります。

Vim script はどのシステムでも使えます。しかしながら tar や gzip コマンドは存在
しないことがあります。ファイルをまとめたり圧縮したりするには "zip" ユーティリ
ティが推奨されています。

可搬性を最大限に高めるには、Vim 自身を使ってスクリプトをパッケージ化します。そ
れには Vimball ユーティリティを使います。|vimball| を参照。

自動更新するための行を書いておくと便利です。|glvs-plugins| を参照。

==============================================================================

次章: |usr_52.txt|  大きなプラグインを作る

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
