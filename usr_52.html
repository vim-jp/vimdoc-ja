---
layout: vimdoc
helpname: 'usr_52'
---
<div id='vimCodeElement'>
<a class="Constant" href="usr_52.html" name="usr_52.txt">usr_52.txt</a>&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim バージョン 9.0.</span>&nbsp;&nbsp;Last change: 2022 May 21<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VIM USER MANUAL - by Bram Moolenaar<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim9 script でプラグインを作る<br>
<br>
<br>
Vim9 script 言語はプラグイン、とりわけ複数のファイルからなる大きなものを書くの<br>
に使えます。この章ではプラグインをモジュールとして分割し、アイテムをインポート<br>
やエクスポートして局所性を維持する方法を解説します。<br>
<br>
<a class="Identifier" href="usr_52.html#52.1">52.1</a>&nbsp;&nbsp;導入<br>
<a class="Identifier" href="usr_52.html#52.2">52.2</a>&nbsp;&nbsp;変数の宣言<br>
<a class="Identifier" href="usr_52.html#52.3">52.3</a>&nbsp;&nbsp;関数と型<br>
<a class="Identifier" href="usr_52.html#52.4">52.4</a>&nbsp;&nbsp;旧来のスクリプトから Vim9 script を使う<br>
<br>
次章:&nbsp;<a class="Identifier" href="usr_90.html">usr_90.txt</a>&nbsp;&nbsp;Vim のインストール<br>
前章:&nbsp;<a class="Identifier" href="usr_51.html">usr_51.txt</a>&nbsp;&nbsp;プラグインを作る<br>
目次:&nbsp;<a class="Identifier" href="usr_toc.html">usr_toc.txt</a><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.1" name="52.1">52.1</a>&nbsp;&nbsp;導入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_52.html#vim9-script-intro" name="vim9-script-intro">vim9-script-intro</a><br>
<br>
Vim9 script は大きな Vim script を容易に書けるようにデザインされています。他の<br>
スクリプト言語、特に TypeScript のようになっています。また、処理内の関数はコン<br>
パイルされ素早く実行できます。これにより Vim9 script はとても速く、最大100倍に<br>
なります。<br>
<br>
基本的な考え方はスクリプトファイルにあるアイテムをプライベートとし、そのスクリ<br>
プトファイル内からのみ利用し、そしてアイテムをエクスポートし、スクリプトファイ<br>
ルの外から使うというものです。エクスポートされたアイテムはインポートしたスクリ<br>
プトから使うことができます。これは定義された位置を非常に明確にできます。<br>
<br>
さあサンプルから始めてみましょう、このスクリプトが1つの関数をエクスポートし、<br>
もう1つのプライベートな関数があります:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script&nbsp;&nbsp;&quot; Vim9 script ファイルであることを示します。</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export def GetMessage(): string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let result = ''<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = GetPart(count)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def GetPart(nr: number): string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if nr == 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 'yes'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 'no'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
<a class="Comment" href="vim9.html#vim9script">vim9script</a>&nbsp;コマンドはファイルのごく最初のコマンドとして置かれなくてはいけま<br>
せん。これがないと Vim は旧来のスクリプトの文法であると見なします。<br>
<br>
<span class="Comment">export def GetMessage(): string</span>&nbsp;の行は&nbsp;<a class="Comment" href="vim9.html#:export">export</a>&nbsp;から始まっており、この関数は<br>
インポート可能で他のスクリプトから呼び出せることを意味します。<br>
<span class="Comment">def GetPart(...</span>&nbsp;の行は&nbsp;<a class="Comment" href="vim9.html#:export">export</a>&nbsp;から始まっておらず、これがスクリプトローカル<br>
の関数で、このスクリプトファイル内からしか使えません。<br>
<br>
<span class="Comment">export def GetMessage(): string</span>&nbsp;の行のコロンと戻り値の型に気付くでしょう。<br>
<a class="Comment" href="vim9.html#:def">def</a>&nbsp;で定義された Vim9 関数は引数および戻り値の型を指定する必要があります。こ<br>
れは Vim が効率的にコードをコンパイルできるようにするためです。GetPart 関数は<br>
引数 &quot;nr&quot; の型が &quot;number&quot; であると定義されています。<br>
<br>
注意すべきは&nbsp;<span class="Comment">result = GetPart(count)</span>&nbsp;の代入は&nbsp;<a class="Comment" href="eval.html#:let">let</a>&nbsp;コマンドを使っていないこ<br>
とです。これについては次の節で説明します。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.2" name="52.2">52.2</a>&nbsp;&nbsp;変数の宣言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_52.html#vim9-declarations" name="vim9-declarations">vim9-declarations</a><br>
<br>
Vim9 script の変数は一度だけ&nbsp;<a class="Comment" href="eval.html#:let">:let</a>&nbsp;もしくは&nbsp;<a class="Comment" href="eval.html#:const">:const</a>&nbsp;コマンドによって宣言され<br>
ます。値は&nbsp;<a class="Comment" href="eval.html#:let">:let</a>&nbsp;無しで代入され変数を&nbsp;<a class="Comment" href="eval.html#:unlet">:unlet</a>&nbsp;することはできません。<br>
<br>
よくあるケースとして、変数の宣言と初期化を同時にしたい時:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let myText = 'some text'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myText = 'other text'</div>
<br>
変数の型は式から推論されます。この場合は文字列となり、数値で初期化した場合は型<br>
は数値となります:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let myNumber = 1234<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myNumber = 0</div>
<br>
もし、この変数に文字列を代入したなら、エラーが検出されます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let myNumber = 'this fails!'</div>
<br>
稀なケースとして任意の型の値を取る変数が欲しい場合、&quot;any&quot; 型を指定しなければな<br>
りません:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let myVar: any = 1234<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myVar = 'text also works'</div>
<br>
値の代入なしで変数を宣言することもできます。このケースでは Vim は0もしくは空文<br>
字列として初期化します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let word: string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if condition<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word = 'yes'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word = 'no'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
とはいえ、これは短くできます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let word = condition ? 'yes' : 'no'</div>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.3" name="52.3">52.3</a>&nbsp;&nbsp;関数と型<br>
<br>
旧来の Vim script はコード実行時にのみ型のチェックがありました。そしてそれは寛<br>
容で、ときどきエラー報告ではなく処理によって不明な値となっていました。結果とし<br>
て関数が定義できかつ正常であると思えても、問題が通知されるのは常に関数の呼び出<br>
し後でした:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func Concatenate(base, add)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a:base + a:add<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc</div>
<br>
どの箇所に問題があると思いますか? 次を試してください:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo Concatenate('base', 'text')</div>
すると0が見えるでしょう。なぜか? それは旧来の Vim script は &quot;+&quot; が引数を数値<br>
に変換し、そして数値のない任意の文字列では結果が0となるのです! これはあなたが<br>
期待したものではありません。<br>
<br>
<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;だと型チェックが関数のコンパイル時に行われます。あなたは引数の型と戻り<br>
値の型の指定が必要になります。また引数の名前は &quot;a:&quot; のプリフィックス無しで使わ<br>
れることに注意してください:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def Concatenate(base: string, add: string): string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return base + add<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defcompile Concatenate</div>
<br>
ここでは直ちにコンパイルを実行するために&nbsp;<a class="Comment" href="vim9.html#:defcompile">:defcompile</a>&nbsp;を使っており、それがな<br>
いなら関数が最初に呼ばれるときにコンパイルされるでしょう。Vim はあなたが間違っ<br>
ていると警告します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E1051: Wrong argument type for +</div>
<br>
補足: ここでは旧来のスクリプトでの話です。Vim9 script を使う場合はスクリプトの<br>
最後に&nbsp;<a class="Comment" href="vim9.html#:defcompile">:defcompile</a>&nbsp;を置くことで、定義されるすべての関数の定義によるエラーが<br>
チェックされます。<br>
<br>
Vim9 script は厳密で、&quot;+&quot; 演算子は数値か浮動小数点数でしか使えません。文字の結<br>
合であれば &quot;..&quot; を使わなくてはなりません。これが間違いを防ぎ、上にあるような驚<br>
きの結果をもたらす自動型変換を回避します。そして関数の最初の行をこう変化させれ<br>
ば:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s:collected ..= add</div>
動くようになります。<br>
<br>
もし関数が何も返さないなら、戻り値の型は無くてよいです:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def ReportResult(result: string)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo 'The result is: ' .. result<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
これもまたチェックされ、もし値を返そうとすると、エラーとなるでしょう。<br>
<br>
あなたが型をケアしない場合や関数が多型で動くなら、&quot;any&quot; 型を使うことができます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def Store(key: string, value: any)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultDict[key] = value<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.4" name="52.4">52.4</a>&nbsp;&nbsp;旧来のスクリプトから Vim9 script を使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_52.html#source-vim9-script" name="source-vim9-script">source-vim9-script</a><br>
<br>
いくつかの場合として持っている旧来の Vim script にて Vim9 script のアイテムを<br>
使いたいことがあります。たとえばあなたの .vimrc がプラグインの初期化をする場合<br>
などです。最良の方法は&nbsp;<a class="Comment" href="vim9.html#:import">:import</a>&nbsp;を使うことです。例:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import Init as NiceInit from 'myNicePlugin.vim'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call NiceInit('today')</div>
<br>
これは Vim9 script からエクスポートされた &quot;Init&quot; 関数を見付けそれをスクリプト<br>
ローカルなアイテム &quot;NiceInit&quot; として利用可能にします。&quot;s:&quot; を指定しなくても<br>
<a class="Comment" href="vim9.html#:import">:import</a>&nbsp;は常にスクリプトの名前空間を使います。もし &quot;myNicePlugin.vim&quot; がすで<br>
に読み込み済みであれば再度読み込まれることはありません。<br>
<br>
その上アイテムがグローバルの名前空間に置かれるのを防ぎ (名前の衝突が不測の問題<br>
になり得ます)、そしてたとえ何度もアイテムをインポートしても、スクリプトの読み<br>
込みがただ一度であることを意味します。<br>
<br>
いくつかの場合、例えばテストなどで、ただ Vim9 script を読み込みたいだけのこと<br>
があります。大丈夫ですが、グローバルのアイテムだけが利用可能となります。Vim9<br>
script ではこうしたグローバルのアイテムで確実にユニークな名前を使うようにしな<br>
くてはなりません。 例:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source ~/.vim/extra/myNicePlugin.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call g:NicePluginTest()</div>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
次章:&nbsp;<a class="Identifier" href="usr_90.html">usr_90.txt</a>&nbsp;&nbsp;Vim のインストール<br>
<br>
Copyright: see&nbsp;<a class="Identifier" href="usr_01.html#manual-copyright">manual-copyright</a>&nbsp;&nbsp;vim:tw=78:ts=8:noet:ft=help:norl:<br>
</div>
