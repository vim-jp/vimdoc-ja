COMMENT: コマンド拡張(マッピング、コマンド定義、自動実行)
STATUS: finished 6.3.054
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>

*usr_40.txt*	For Vim version 6.3.  Last change: 2004 Feb 13

		     VIM USER MANUAL - by Bram Moolenaar

			     新しいコマンドを作る


vimは拡張可能なエディタです。頻繁に使うコマンドシーケンスを新しいコマンド
に置きかえることができます。また既存のコマンドを再定義することもできます。
自動コマンドを使えば自動的にコマンドを実行させることができます。

|40.1|	キーマッピング
|40.2|	コマンドラインのコマンドを定義する。
|40.3|	自動コマンド

     Next chapter: |usr_41.txt|  Write a Vim script
 Previous chapter: |usr_31.txt|  Exploiting the GUI
Table of contents: |usr_toc.txt|

==============================================================================
*40.1*	Key mapping

単純なマッピングについては|05.3|で説明しました。原則として一連のキー入力を
違った一連のキー入力に変換するものです。単純ですが、パワフルな仕組です。
一番単純なのは１つのキーに一連のキーを割り当てる方法です。<F1>以外のファン
クションキーはvimでは何も定義していませんので、自由に割り当てができます。
例えば >

	:map <F2> GoDate: <Esc>:read !date<CR>kJ

ここでは３つのモードをどのように使うかを示しています。最後の行まで"G"で
ジャンプして、oコマンドで新しい行を追加して挿入モードを開始します。そこで
"Date: "という文字列を挿入し、<Esc>で挿入モードから抜けます。
  <>で囲まれた特殊キーの使い方に注意してください。これを角カッコ表記と呼び
ます。これを使うとマッピングが読みやすいですし、コピー＆ペーストしても変な
問題が起こりません。
  ":"文字はvimをコマンドラインにします。":read !date"コマンドは"date"コマン
ドの出力を読み込んでそれを現在行の下に追加します。<CR>は":read" を実行する
のに必要です。
   この時点までを実行すると次のようになります。

	Date:  ~
	Fri Jun 15 12:54:34 CEST 2001 ~

さらに、"kJ"でカーソルを上に上げて２つの行を１行に繋ぎます。
割り当てに使えるキーを決めるには、|map-which-keys|を見て下さい。


MAPPING AND MODES

":map"コマンドは通常モードのキーの再割り当てを行います。他のモードの割り当て
を定義することもできます。例えば、":imap"は挿入モード用ですので、現在のカー
ソル位置に日付を挿入するのに使えます。 >
 
	:imap <F2> <CR>Date: <Esc>:read !date<CR>kJ

これは通常モードでの<F2>の割り当てとほとんどいっしょです。違うのは最初だけ
です。通常モードでの<F2>割り当ても生きています。このように各モード用に同じ
キーで違う働きをするように定義できます。
気をつけていただきたいのは、挿入モードでこのコマンドを実行すると終わった時
には通常モードになっている点です。もし挿入モードのままにしておきたければ、
マッピングの最後に"a"を追加しておきましょう。

どのmapコマンドがどのモードで動くかは次の通りです。

	:map		通常モード、ビジュアルモード、 オペレータ保留モード
	:vmap		ビジュアルモード
	:nmap		通常モード
	:omap		オペレータ保留モード
	:map!		挿入モード、コマンドライン
	:imap		挿入モード
	:cmap		コマンドライン

オペレータ保留モードというのは、"d"とか"y"といったオペレータ文字を入力した後
で、モーションコマンドやテキストオブジェクトを入力しようとしている時のモード
です。例えば、"dw"と入力する時に"w"を押す時がオペレータ依存モードです。

例えば、あなたが"d<F7>"とすると、Ｃのプログラムブロック（中カッコ{}で囲まれ
たテキスト）を削除できるように<F7>を定義したいとしましょう。y<F7>とすると
同じようにプログラムブロックを名前なしレジスタにコピーできます。この場合、
やらなければならないのは、<F7>で現在のプログラムブロックを選択するように
定義することです。次のコマンドでできます。 >

	:omap <F7> a{

これはブロック選択の"a{"をオペレータ保留モードで実行するように<F7>を定義し
ます。このマッピングは"{"がちょっと入力しづらいようなキーボードでは便利で
すね。


マッピング定義を見る

現在のマッピング定義を見るには引数なしで":map"を実行します。もしくは、特定の
モード用のコマンド（例えば":vmap"）を使います。結果は次のようになります。

	   _g		 :call MyGrep(1)<CR> ~
	v  <F2>		 :s/^/> /<CR>:noh<CR>`` ~
	n  <F2>		 :.,$s/^/> /<CR>:noh<CR>`` ~
	   <xHome>	 <Home>
	   <xEnd>	 <End>


最初の桁にはそのマッピングがどのモードで有効かを示します。"n"は通常モード、
"i"は挿入モード、などです。ここが空白の場合は":map"で定義されたことを示し
、通常モードでもビジュアルモードでも有効です。
マッピングのリストを見れば、特殊キーが<>の書式で書けるかどうかがわかります。
（ただしカラーをサポートしている場合に限ります）例えば、<Esc>がカラーで表示
されていれば、エスケープ文字であることがわかります。他のテキストと同じ色の
場合は、"<Esc>"という５文字の文字列です。


リマッピング

マッピングには他のマッピングを含むことができます。例えば、
<F2>のマッピングは次のように短くすることができます。 >

	:map <F2> G<F3>
	:imap <F2> <Esc><F3>
	:map <F3>  oDate: <Esc>:read !date<CR>kJ

通常モード用の<F2>は最後の行に移動してその後で<F3>が押されたかのように動き
ます。挿入モード用の<F2>は<Esc>で挿入モードを終わらせてから、同じように<F3>
を使います。そして、<F3>には実際にやりたいことを定義しておきます。

あなたがずっとExモードをヘビーに使っていて、"Q"をテキストの整形に使いたい
（vimの古いバージョンではそうでした）のなら、以下でそのようになります。 >

	:map Q gq

でも時には、Exモードを使いたくない時もあるでしょう。"gQ"を"Q"に割り当てましょ
う。そうすればExモードに移行する手段を残せます。 >

	:map gQ Q

今やったのは、"gQ"を入力した時にそれを"Q"にマップすることです。これはいいで
しょう。しかし"Q"が"gq"に割り当てられていますから、gQと入力すると結局、"gq"と
なります。これだとExモードにすることができません。
再帰的なマップを避けるには":noremap"コマンドを使います。 >

	:noremap gQ Q

これで、Vimは"Q"がそれ以降のマッピングの検査を必要としないことを知ります。同じ
ようなコマンドが各モード用に用意されています。

	:noremap	通常モード、ビジュアルモード、 オペレータ保留モード
	:vnoremap	ビジュアルモード
	:nnoremap	通常モード
	:onoremap	オペレータ保留モード
	:noremap!	挿入モード、コマンドライン
	:inoremap	挿入モード
	:cnoremap	コマンドライン


再帰的マッピング

マッピングが自分自身を呼び出すと永遠に動きつづけます。これは同じ動きを無限
回数繰り返すために使われます。
例えば、ファイルの先頭行にバージョン番号があるようなファイルのリストを持って
いるとします。これを"vim *.txt"で編集できます。さて最初のファイルを編集しま
しょう。次のマッピングを定義します。 >

	:map ,, :s/5.1/5.2/<CR>:wnext<CR>,,

さらに",,"を入力します。これで上記のマッピングが動き始めます。まず最初の行の
"5.1"を"5.2"に変更します。そして":wnext"で上書きして次のファイルを編集しま
す。マッピングの最後は",,"です。これは同じマッピングをもう一度呼び出します。
そこで置き換えを行います。以下同文。
これはエラーが発生するまで続きます。この場合なら、置き換え時に"5.1"が見つ
からないファイルがあるかもしれません。"5.1"をファイルに加える変更をして、
",,"をもう一度入力して続けられます。もしくは最後のファイルに達したため、
":wnext"がエラーになるかもしれません。
マッピングの動作途中でエラーが起こると、マッピングの残りを無視します。
マッピング動作中に割り込むにはCTRL-C（WindowsではCTRL-Break)を押します。


マッピングの解除

マッピングを解除するには":unmap"コマンドを使います。繰り返しですが、マッピ
ングを解除するモードは使ったコマンドによります。

	:unmap		通常モード、ビジュアルモード、 オペレータ保留モード
	:vunmap		ビジュアルモード
	:nunmap		通常モード
	:ounmap		オペレータ保留モード
	:unmap!		挿入モード、コマンドライン
	:iunmap		挿入モード
	:cunmap		コマンドライン

ビジュアルモードを除き通常モードとオペレータ保留モードでマッピングを定義するに
はちょっとしたトリックがあります。最初に３つの全モードで定義し、ビジュアルモー
ドのみ解除します。 >

	:map <C-A> /---><CR>
	:vunmap <C-A>

注意：<C-A>という５文字はCTRL-Aのことです。

全マッピングを解除するには|:mapclea|コマンドを使います。今現在とは違った
モードのバリエーションにも適用されます。このコマンドはundoできませんので、
気を付けて下さい。


特殊なキャラクタ

":map"コマンドに他のコマンドを続けることができます。'|'文字で２つのコマ
ンドを区切ります。逆に言うと'|'文字はmapコマンドの中では使えないという
ことです。これを含ませたい場合には、<Bar>を使います。例を示します。 >
>
	:map <F8> :write <Bar> !checkin %<CR>

同じ問題は":unmap"コマンドにも言えます。こちらは末尾の空白に注目して追加し
なければなりません。以下の２つのコマンドは違うものです。 >
>
	:unmap a | unmap b
	:unmap a| unmap b

最初のコマンドは末尾に空白の付いた"a "を解除しようとします。

なお、マッピングの中に空白を使いたい場合には、<Space>を使います。 >

	:map <Space> W

これはスペースバーを押した時に空白類で区切られた次の単語までカーソルを移
動します。

マッピング行の末尾にはコメントは付けられません。これは（コメントに使う）
" 文字がマッピングの一部として処理されるためです。代わりに |" を使うこと
ができます。これはマッピングの後にさらに何もしないコマンドを指定して、そ
の後にコメントを書きます。例をあげましょう。

	:map <Space> W|     " 次の単語に移動するのにスペースバーを使う

マッピングと省略(ABBREVIATIONS)

省略は挿入モードのマッピングと非常に似ています。引数は同じ方法で処理されま
す。大きな違いはその起動のし方です。省略は単語の後に空白類を入力すると起動
されますが、マッピングは最後の文字を入力した時に起動します。
その他にも、省略では入力した文字はテキスト上に表示される点が違います。省略
を起動すると、入力した文字列は削除され、省略処理が生成したものに置き替え
られます。マッピングでは最後の文字を入力し、コマンドを実行させるまで何も
表示されません。'showcmd'オプションを設定してれば、マッピングで入力した
文字がVimウィンドウの最下行に表示されます。
ただし、マッピングがあいまいな場合は例外です。例えば、次の２つのマッピング
があるとします。 >

	:imap aa foo
	:imap aaa bar

さて、"aa"と入力した時、vimは１つ目か２つ目のどちらを使うべきか決められま
せん。そこで次にタイプされる文字を待ちます。それが"a"であれば、２つ目の
マッピングを使い、"bar"という結果を返します。そうでなく、例えば空白だった
場合は、１つ目のマッピングを使って"foo"という結果を返し、さらに空白文字を
表示します。


さらに....

<script>を使うと、マッピングをスクリプト内のローカルにできます。
|:map-<script>|を見てください。

<buffer>を使うと、マッピングを特定のバッファ内のローカルにできます。
|:map-<buffer>|を見てください。

<unique>を使うと、新しいマッピングを定義する時に既に存在していれば、登録
できなくなります。そうでなければ、新しいマッピングは単純に以前のを上書き
します。|:map-<unique>|を見てください。

何もしないキーを定義するには、<Nop>を割り当てます。以下の例は<F7>キーを押
しても何もしないようにします。 >

	:map <F7> <Nop>| map! <F7> <Nop>

上の定義で、<Nop>の後には空白があってはいけません。

==============================================================================
*40.2*	Defining command-line commands

vimでは独自のコマンドを定義できます。定義したコマンドはコマンドラインモード
の他のコマンドと同じ様に使えます。
コマンドの定義には":command"コマンドを次のように使います。 >

	:command DeleteFirst 1delete

これで、":DeleteFirst"コマンドを実行すると、vimは":1delete"、つまり最初の
行を削除します。

	Note:
	ユーザ定義コマンドは必ず大文字で始まらなければなりません。ただし、
	":X", ":Next" and ":Print"は使えませんし、アンダースコア("_")も使
	えません。数字は使えますが、推奨されません。

ユーザ定義コマンドの一覧を見るには、次のコマンドを実行します。 >

	:command

組み込みコマンドと同じ様にユーザ定義コマンドも省略入力できます。他のコマンド
との区別に必要な文字を入力してください。コマンドライン補完で完全なコマンド名
を得ることができます。


引数の数
--------

ユーザ定義コマンドでは引数を指定できます。引数の数は -nargs オプションで指定
しなければなりません。例えば、上で例示した:DeleteFirstコマンドには引数は
ありません。つまり次のように指定できるわけです。 >

	:command -nargs=0 DeleteFirst 1delete

もっとも、引数０はデフォルトですので、実際には"-nargs=0"を追加しなくても
かまいません。-naargsには次のような値を与えます。

	-nargs=0	引数なし
	-nargs=1	引数１つ
	-nargs=*	いくつでも
	-nargs=?	引数なし、もしくは１つ
	-nargs=+	引数１つ以上(いくつでも)


引数の使い方
------------

コマンド内では、引数を<args>キーワードで示します。例えば、 >

	:command -nargs=+ Say :echo "<args>"

のように使います。ここで、以下を入力すると、 >

	:Say Hello World

vimは "Hello World" と表示します。 ただし、引用符(")を使うと、
うまく動きません。 >

	:Say he said "hello"

特殊文字(訳注:"など)を文字列として得るには、スクリプトの式で使えるように適切に
エスケープするため、"<q-args>"を使います。 >

	:command -nargs=+ Say :echo <q-args>

こうすれば、上で示した":Say"コマンドは次のような結果となります。 >

	:echo "he said \"hello\""

キーワード<f-args>は関数呼び出しとして使うのに適切な形式に整形する点を除けば
<args>と同じです。例を示しましょう。 >

	:command -nargs=* DoIt :call AFunction(<f-args>)
	:DoIt a b c

上記は以下のコマンドを実行します。 >

	:call AFunction("a", "b", "c")


行範囲
------

一部のコマンドは引数として範囲を受け取ります。そのようなコマンドを定義する
には、-range オプションを使わなければなりません。このオプションの値は以下
の通りです。

	-range		範囲指定を許可。デフォルトは現在行
	-range=%	範囲指定を許可。デフォルトは現在のファイル全体
	-range={count}	範囲指定を許可。the last number in it is used as a
			single number whose default is {count}.

範囲を指定する場合、キーワード<line1>や<line2>は範囲の最初と最後の行を示し
ます。例えば、以下のコマンド定義では SaveIt というコマンドを定義します。
これは、指定した範囲を"save_file"というファイルに書き出します。 >

	:command -range=% SaveIt :<line1>,<line2>write! save_file


他のオプション
--------------

その他のオプションやキーワードは次の通りです。

	-count={number}		コマンドが回数指定できるようにします。デフォ
				ルト値は{number}です。指定の回数はキーワード
				<count>で得られます。
	-bang			!指定ができるようにします。指定の有無は<bang>
				キーワードで得られます。
	-register		指用するレジスタを指定できます。デフォルト
				は名前なしレジスタです。
				指定されたレジスタは<reg>(もしくは<register>)
				で得られます。
	-complete={type}	コマンド行補完のタイプを指定します。タイプに
				指定できる値は、|:command-completion|を参照
				してください。
	-bar			コマンドの後に | と別コマンドを続けることを
				許します。また、" とコメントも許します。
	-buffer			このコマンドは現バッファに対してのみ有効で
				あることを示します。

最後に、キーワード<lt>があります。これは文字"<"を示します。これは、<>アイテム
の特殊な意味を回避し、単なる文字として使いたい時に使います。


再定義と削除
------------

同じコマンドを再定義するには ! を使用します。 >

	:command -nargs=+ Say :echo "<args>"
	:command! -nargs=+ Say :echo <q-args>

ユーザ定義コマンドを削除するには":delcommand"を使います。このコマンドに削除
したいコマンド名を１つだけ指定します。 >

	:delcommand SaveIt

全部のユーザ定義コマンドを削除するには以下のようにします。 >

	:comclear

このコマンドはアンドゥできませんから、気をつけて！

ここで述べた内容の詳細については、リファレンスマニュアル |user-commands|
を参照してください。

==============================================================================
*40.3*	自動コマンド

自動コマンド(Autocommand)はファイルの読み込み、書き出し、バッファの変更、と
いった何らかのイベントに対して、自動的に実行されるコマンドのことです。
自動コマンドを使うと、例えば、圧縮されたファイルを編集できるようにvimを強化
できるのです。これには |gzip| プラグインを使います。
自動コマンドは非常に強力です。慎重に使えば、多くのコマンドを入力する手間を
省いてくれます。逆に言えば、不用意に使うととんでもないトラブルの原因となり
ます。

例えば、ファイルを書き込む時には必ずファイル末尾にある日付を置き換えるよう
にしたいというケースを考えてみましょう。
まず、次のような関数を定義します。 >

	:function DateInsert()
	:  $delete
	:  read !date
	:endfunction

この関数を毎回、ファイルを書き出す直前に呼び出したいわけです。
これには次のように指定します。 >

	:autocmd FileWritePre *  call DateInsert()

"FileWritePre" というのが自動コマンドのトリガとなるイベントです。このイベン
トは「まさしくファイルを書き出す直前」を示します。"*" はファイル名に合致す
るパターンです。ここでは全ファイルを対象にしています。
このコマンドを有効にして、":write"を実行すると、vimは FileWritePre に合致
する自動コマンドを探して、それを実行します。その後で":write"を実行します。
一般的な :autocmd の指定形式は次の通りです。 >

	:autocmd [group] {events} {file_pattern} [nested] {command}

上の [group] は無指定でも構いません。これはコマンド呼び出しを管理したい時に
使います。（詳しくは後述します） {events} パラメタにはコマンドをキックする
イベントを（","区切りで複数可）指定します。
 {file_pattern} はファイル名です。通常はワイルドカードとなります。例えば、
"*.txt" を指定すれば、ファイル名の末尾が ".txt" となっている全ファイルに
対して自動コマンドが使われます。 [nested] フラグは自動コマンドの多重呼び
出し（下記参照）の可否を指定します。最後の {command} は実行させたいコマンド
です。


イベント
--------

BufReadPostは最も強力な部類のイベントです。新規ファイルを編集した後でキック
されます。これはオプション値の定義によく使います。例えば、"*.gsm"はGNUの
アセンブリ言語のファイルです。シンタックスファイルを正しく読み込むために、
次の自動コマンドを定義しておきます。 >

	:autocmd BufReadPost *.gsm  set filetype=asm

vimがファイルのタイプを検出できた時に、'filetype' オプションを"asm"に定義
します。
vimがファイルのタイプを検出できた時に、'filetype' オプションを"asm"に定義
します。この定義はFiletypeイベントをキックします。特定の種類のファイルを編
集する時に使います。例えば、テキストファイル用の省略定義ファイルを読み込む
には次のように定義します。 >

	:autocmd Filetype text  source ~/.vim/abbrevs.vim

新規ファイルの編集を始める時に、スケルトンを用意させることもできます。 >

	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c

イベントの全リストについては|autocmd-events|を参照してください。


パターン
--------

引数 {file_pattern} はファイル名のパターンを","区切りで羅列したものです。
例えば、"*.c,*.h" という指定は、末尾が".c" と ".h" のファイルに合致します。
一般的なファイルのワイルドカードが使えます。以下によく使うものを掲げておき
ます。

	*		任意の文字の任意長の文字列
	?		任意の１文字
	[abc]		a か b か c
	.		"."文字自身
	a{b,c}		ab もしくは ac

パターンにスラッシュ(/)を含んでいる場合は、vimはディレクトリ名と比較します。
スラッシュがない場合は、パス名の最後とだけ比較します。例えば、"*.txt"は、
"/home/biep/readme.txt" と合致します。 "/home/biep/*" も同じように合致し
ます。でも、"home/foo/*.txt"では合致しません。
スラシュを含んでいる場合は、vimはファイルの絶対パス("/home/biep/readme.txt")
と、相対パス（例えば"biep/readme.txt") の双方とパターン照合をします。

	Note:
	MS-Windowsのようなディレクトリのセパレータとしてバックスラッシュを使
	うシステム上であっても、自動コマンドではスラッシュを使います。こうす
	ることで、バックスラッシュに特別な意味があってもパターンの指定が簡単
	になります。自動コマンドの汎用性も増します。


削除
----

自動コマンドの削除は定義した時と同ジコマンドを使います。ただし、{command} 指
定は取り去った上で、! を使います。次のようになります。 >

	:autocmd! FileWritePre *

これは、"FileWritePre"イベントで、"*"パターンを使っている自動コマンドを全部
削除します。


一覧
----

現在定義されている自動コマンドの一覧を見るには次のようにします。 >

	:autocmd

この一覧は filetype 検出を使っていると、とても長くなる場合があります。一部の
コマンドだけを見るには、グループやイベントやパターンを（組み合せて）指定し
ます。例えば、"BufNewFile" の自動コマンドの一覧を見るには以下のようにします。
>
	:autocmd BufNewFile

パターン"*.c"に対する自動コマンドの一覧なら次のようになります。 >

	:autocmd * *.c

イベントとして"*"を指定すると、全イベントが対象となります。cprogramsグループ
に関する自動コマンドの一覧は、次のように指定します。 >

	:autocmd cprograms


グループ
--------

{group} は自動コマンドの定義で使います。これは自動コマンドを関連したグループ
にまとめます。例えば、特定のグループの自動コマンドをまとめて削除することも出
来ます。
あるグループ用に自動コマンドを定義するには、":augroup"コマンドを使います。
例えば、cprogramsグループに属する自動コマンドを定義してみましょう。 >

	:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END

次のようにしても同じです。 >

	:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3

"cprograms"グループの自動コマンドを全部削除するには、次のようにします。 >

	:autocmd! cprograms


ネスト
------

通常はイベントによって起動されるコマンドからは新たなイベントをキックしま
せん。例えば、FileChangeShellイベントからキックされた処理でファイルを読み
込んでも、シンタックスを設定するための自動コマンドはキックされないのです。
こういった場合でもイベントを発生させるには、"nested"指定を行います。 >

	:autocmd FileChangedShell * nested  edit


自動コマンドの起動
------------------

イベントが発生したかのように自動コマンドを起動させることもできます。自動コ
マンドから他の自動コマンドをキックする時に使われます。例を示します。 >

	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("<afile>:r")

上は新規ファイルを編集し始めた時にキックされる自動コマンドを定義します。ファ
イル名の末尾は".new"でなければなりません。":execute"コマンドは式の評価を行い
新たなコマンドを生成し、それを実行します。例えばファイル"tryout.c.new"を編集
しようとした時に実行されるコマンドは次のようになります。 >

	:doautocmd BufReadPost tryout.c

expand()関数は"<afile>"引数を取ります。これは自動コマンドが起動された時の
ファイル名を示します。さらに":r"指定で、ファイル名のルート部分（訳注:最後の
.newを除いた部分？）を得ます。

":doautocmd" は現在のバッファに対して起動されます。":doautoall"コマンドは
似ていますが、全バッファに対して起動される点が異なります。


通常モードのコマンドの利用
--------------------------

自動コマンドで起動されるコマンドはコマンドラインモードのコマンドです。もし
通常モードのコマンドが使いたければ、":normal"コマンドが使えます。例を示し
ます。 >

	:autocmd BufReadPost *.log normal G

上は"*.log"というファイルを編集しようとした時にカーソルをファイルの末尾に
移動させる自動コマンド定義です。
":normal"コマンドの使い方はちょっと難しいです。まず、引数にはそのコマンドの
引数も含めた完全なコマンド形式で指定します。例えば、挿入モードに遷移するため
に"i"を使うのであれば、そのモードから抜けるための<Esc>も必要となります。
同様に検索を始めるのに"/"を使うのであれば、<CR>で実行するようにしなければ
なりません。
":normal"コマンドの後ろに書いてある全内容を使用します。つまり | を使って他
のコマンドを記述したりはできないということです。それをやりたければ、":normal"
コマンドを":execute"コマンドの中に置きます。この方法は、非表示文字を簡単
に受け渡す方法でもあります。例を示します。 >

	:autocmd BufReadPost *.chg execute "normal ONew entry:\<Esc>" |
		\ 1read !date

上の例では、長いコマンドを複数行に分けるのに逆スラッシュ("\")を使っていま
す。この方法はvimスクリプトで使用できます。（コマンドラインモードでは使えま
せん）

ファイルをあちこちとジャンプするといった複雑なことをする自動コマンドで、
元の場所（訳注：カーソル位置？）に戻りたい場合には、ファイルのビューを復元
すればいいかも知れません。その例は、|restore-position| を参照してください。



イベントの無効化
----------------

時によって、自動コマンドをキックしたくない場合もあるでしょう。'eventignore'
オプションには、完全に無効にしたいイベントのリストを格納できます。例えば、
以下ではウィンドウへの出入りについてのイベントは無視されます。 >

	:set eventignore=WinEnter,WinLeave

全イベントを無視するには次のようにします。 >

	:set eventignore=all

元に戻すには'eventignore'の内容を空にします。

	:set eventignore=

==============================================================================

Next chapter: |usr_41.txt|  vimスクリプトの書き方

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
