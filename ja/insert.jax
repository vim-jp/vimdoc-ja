COMMENT: 挿入・置換モード
STATUS: finished 6.3.054
TRANSLATOR: 村岡太郎 <koron@tka.att.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>

*insert.txt*    For Vim バージョン 6.3.  Last change: 2004 Apr 09


		VIMリファレンスマニュアル    by Bram Moolenaar


						*Insert* *Insert-mode*
テキストの挿入と置換					*mode-ins-repl*

よく使われるコマンドの概要がユーザーマニュアルの24章|usr_24.txt|にあります。

このファイルの大部分は挿入と置換モードについて記述してある。終わりのほうにテキ
ストを挿入する別の方法を記述している。

1. 特別なキー						|ins-special-keys|
2. もっと特別なキー					|ins-special-special|
3. 'textwidth'と'wrapmargin'オプション			|ins-textwidth|
4. 'expandtab'、'smarttab'それと'softtabstop'オプション	|ins-expandtab|
5. 置換モード						|Replace-mode|
6. 仮想置換モード					|Virtual-Replace-mode|
7. 挿入モードの補完					|ins-completion|
8. 挿入モードのコマンド					|inserting|
9. Exの挿入コマンド					|inserting-ex|
10. ファイルを挿入する					|inserting-file|

文字のない場所にカーソルと移動するためには'virtualedit'も参照してください。表
を編集するときに便利です。

==============================================================================
1. 特別なキー						*ins-special-keys*

挿入と置換モードでは、次の文字には特別な意味がある:その他の文字はそのまま入力
される。それらの特別な文字をバッファに入力するには、CTRL-Vに続けて入力する。
<Nul>文字を入力するには"CTRL-V CTRL-@"か"CTRL-V 000"を使用する。あるシステムで
は、CTRL-Cを入力するのに"CTRL-V 003"を使わなければならない。Note: CTRL-Vに他の
動作がマップされているときは、多くの場合、代わりにCTRL-Qを使います|i_CTRL-Q|。

テキストを入力中に特別な言語のモードを使用している場合には、いつもこのモードが
ON/OFFと切り替えられてしまうのをどう避けるかを示す、'langmap'オプション
|'langmap'|を参照する。

'insertmode'を設定した場合には、<Esc>と他の幾つかのキーに別の意味が与えられ
る。|'insertmode'|を参照。

文字		アクション	~
-----------------------------------------------------------------------
						*i_CTRL-[* *i_<Esc>*
<Esc> or CTRL-[	挿入/置換モードを終了し、ノーマルモードに戻る。短縮入力を終了
		する。
		Note: キーボードによっては<Esc>が押し難いかもしれないが、その
		時にはCTRL-[を使うようにする。
						*i_CTRL-C*
CTRL-C		挿入モードを終了し、ノーマルモードに戻る。短縮入力はチェック
		しない。

						*i_CTRL-@*
CTRL-@		直前に挿入されたテキストをもう一度挿入し、挿入を終了する。{Vi:
		最初に入力された時だけ、かつ最大128文字まで}
						*i_CTRL-A*
CTRL-A		直前に挿入されたテキストをもう一度挿入する。 {Vi にはない}

						*i_CTRL-H* *i_<BS>* *i_BS*
<BS> or CTRL-H	カーソルの前の文字を削除する(行同士の連結については
		|i_backspacing|参照)。
		<BS>キーが想定するように働かない場合には|:fixdel|を参照。
		{Vi: 自動字下げは消すことができない}
						*i_<Del>* *i_DEL*
<Del>		カーソルの下の文字を削除する。カーソルが行末にあり、
		'backspace'オプションに"eol"が含まれている場合には、<EOL>が削
		除される; 現在の行の後ろに次の行が接続される。
		<Del>キーが想定するように働かない場合には|:fixdel|を参照。
		{Vi にはない}
						*i_CTRL-W*
CTRL-W		カーソルの前にある単語を削除する(行同士の連結については
		|i_backspacing|参照)。単語の定義については"word motions"の節
		|word-motions|を参照。
						*i_CTRL-U*
CTRL-U		現在の行の入力済み文字全部を削除する(行同士の連結については
		|i_backspacing|参照)。

						*i_CTRL-I* *i_<Tab>* *i_Tab*
<Tab> or CTRL-I タブを挿入する。'expandtab'オプションが設定されていれば、同じ
		数の空白文字が挿入される(展開を避けるためにはCTRL-V <Tab>を使
		う。CTRL-Vに他の動作がマップされているときはCTRL-Q <Tab>を使
		う|i_CTRL-Q|)。'smarttab'オプションと|ins-expandtab|も参照。
						*i_CTRL-J* *i_<NL>*
<NL> or CTRL-J	新しい行を始める。
						*i_CTRL-M* *i_<CR>*
<CR> or CTRL-M	新しい行を始める。
						*i_CTRL-K*
CTRL-K {char1} [char2]
		合字(|digraphs|参照)を入力する。{char1}が特別なキーだった場
		合、そのキーのコードが<>の形で挿入される。例えば、
		<C-K><S-Space>(キー2つ)と入力することで、文字列"<S-Space>"が入
		力される。マッピングも考慮されない。 {Vi にはない}

CTRL-N		次のキーワードを探す(|i_CTRL-N|を参照)。 {Vi にはない}
CTRL-P		前のキーワードを探す(|i_CTRL-P|を参照)。 {Vi にはない}

CTRL-R {0-9a-z"%#*+:.-=}					*i_CTRL-R*
		レジスタの内容を挿入する。CTRL-Rをタイプしてから2つ目の文字を
		タイプするまで、レジスタの名前の入力が期待されていることを示す
		ため、'"'が表示される。
		テキストはタイプしたかのように挿入されるが、マッピングや短縮入
		力の展開はされない。'textwidth'や'formatoptions'や'autoindent'
		のようなオプションが設定されている場合には、入力されたテキスト
		に対して効力を持つ。これは"p"コマンドやマウスによる貼り付けと
		は、違う動作になる。
		特別なレジスタ:
			'"'	最後に削除されたりヤンクされたテキストの入って
				いる、名前なしレジスタ
			'%'	現在のファイル名
			'#'	裏バッファのファイル名
			'*'	クリップボードの内容 (X11: プライマリセレクシ
			        ョン)
			'+'	クリップボードの内容
			'/'	最後に検索を行ったパターン
			':'	最後に実行したコマンドライン
			'.'	最後に挿入したテキスト
			'-'	最後に削除した小さい(行単位以下の)領域
			'='	式評価レジスタ: 式評価の入力を求められる
				(|expression|参照)。
		レジスタについては|registers|を参照。 {Vi にはない}

CTRL-R CTRL-R {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-R*
		レジスタの内容を挿入する。CTRL-Rが一つの時と同様に働くが、タイ
		プされたようにではなく、テキストは文字通りに挿入される。これは
		レジスタに<BS>のような文字が含まれていた場合に違いを生じる。例
		えば"ab^Hc"という内容のレジスタaがあった場合: >
	CTRL-R a		結果は"ac".
	CTRL-R CTRL-R a		結果は"ab^Hc".
<		オプション'textwidth'、'formatoptions'その他はまだ適用される。
		これらも避けたいのならば下記の"<C-R><C-O>r"を使用する。'.'レジ
		スタ(最後に挿入されたテキスト)は、まだタイプされたように扱われ
		る。{Vi にはない}

CTRL-R CTRL-O {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-O*
		レジスタの内容が文字通り挿入され、自動字下げも行われない。マウ
		スによる貼り付け|<MiddleMouse>|と同様である。
		キャラクタは置き換えられない!
		'.'レジスタ(最後に挿入されたテキスト)は、まだタイプされたよう
		に扱われる。

CTRL-R CTRL-P {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-P*
		レジスタの内容が文字通りに挿入され、インデントが
		|[<MiddleMouse>|同様に修正される。
		キャラクタは置き換えられない!
		'.'レジスタ(最後に挿入されたテキスト)は、まだタイプされたよう
		に扱われる。

						*i_CTRL-T*
CTRL-T		現在の行の先頭にshiftwidth一単位分の字下げを挿入する。字下げ幅
		は'shiftwidth'に丸められる(これはviと同じ)。{Vi: 字下げされて
		いる時だけ}
						*i_CTRL-D*
CTRL-D		現在の行の先頭の字下げを、shiftwidth一単位分削除する。字下げ幅
		は'shiftwidth'に丸められる(これはviと同じ)。{Vi: CTRL-Dは自動
		字下げの適用後にしか使えない}
						*i_0_CTRL-D*
0 CTRL-D	現在行の字下げを完全に削除する。{Vi: CTRL-Dは自動字下げの適用
		後にしか使えない}
						*i_^_CTRL-D*
^ CTRL-D	現在行の字下げを完全に削除する。次の行では字下げは元に戻され
		る。これはラベルを入力する際に役に立つ。{Vi: CTRL-Dは自動字下
		げの適用後にしか使えない}

						*i_CTRL-V*
CTRL-V		続く非数字文字を文字通りに挿入する。特別なキーはターミナルコー
		ドが挿入される。10進数、8進数、16進数、の数字で文字コードを直
		接指定することもできる|i_CTRL-V_digit|。CTRL-Vの後の入力にはマ
		ップは適用されない。{Vi: 数字文字をバイトに変換できない}
		Note: CTRL-Vに他の動作がマップされているとき(例えばテキストを
		ペーストするなど)、その場合には代わりにCTRL-Qを使用する
		|i_CTRL-Q|。

						*i_CTRL-Q*
CTRL-Q		CTRL-Vと同じ。
		Note: ある種のターミナルではCTRL-Qを使用できない。GUIでは使え
		る。

CTRL-X		CTRL-Xモードに入る。これは単語の補完やウィンドウスクロールのコ
		マンドを入力する、サブモードである。|i_CTRL-X|と
		|ins-completion|を参照。{Vi にはない}

						*i_CTRL-E*
CTRL-E		カーソルの下の行の同じ位置の文字を挿入。{Vi にはない}
						*i_CTRL-Y*
CTRL-Y		カーソルの上の行の同じ位置の文字を挿入。{Vi にはない}
		'textwidth'はCTRL-EとCTRL-Yには、長い行から文字をコピーするこ
		とを可能にするために、効力を発揮しないことに注意。

						*i_CTRL-_*
CTRL-_		次に示すように言語を切り替える:
		-  右→左ウィンドウでは、revinsとnohkmapに切り替えられ、この場
		   合英語を挿入できるようになる。
		-  右→左ウィンドウ以外ではrevinsとhkmapに切り替えられ、この場
		   合ヘブライ語を挿入できるようになる。

		CTRL-_はカーソルをタイプ済みテキストの末尾に移動させる。

		このコマンドは'allowrevins'オプションが設定されている時のみ有
		効。
		右→左モードについての詳しい情報は|rileft.txt|を参照。
		{Vi にはない}
		|+rightleft|機能を有効(デフォルトで有効)にしてコンパイルした時
		にだけ使用可能。
						*i_CTRL-^*
CTRL-^		入力言語を切替える。
		言語マッピング|:lmap|が定義されているとき:
		  'iminsert'が1(言語マッピングが使われている)なら0(言語マッ
		  ピングを使わない)になる。
		  'iminsert'が他の値なら1になる。したがって言語マッピングが
		  有効になる。
		言語マッピングが定義されていないとき:
		  'iminsert'が2(インプットメソッドが使われている)なら0(イン
		  プットメソッドを使わない)になる。
		  'iminsert'がその他の値なら2になる。したがってインプットメ
		  ソッドが有効になる。
		'iminsert'を1にすると"b:keymap_name"の値、または'keymap'オプ
		ションか"<lang>"がステータスラインに表示される。
		言語マッピングは通常はキーボードにない文字を打つのに使われる。
		これらの値を設定するために'keymap'オプションを使える。
		{Vi にはない}

						*i_CTRL-]*
CTRL-]		文字を入れることなく、短縮入力をトリガーする。{Vi にはない}

						*i_<Insert>*
<Insert>	挿入と置換モードを交互に切り替える。{Vi にはない}
-----------------------------------------------------------------------

						*i_backspacing*
<BS>、CTRL-WそしてCTRL-Uの効果は'backspace'オプションに依存している('revins'が
設定されていなければ)。これは下記の項目をカンマで区切ったリストになっている:

項目	    アクション ~
indent	    字下げをバックスペースで消去可能
eol	    行末をバックスペースで消去可能(行を連結)
start	    挿入の開始点を超えてバックスペースで消去可能; CTRL-WとCTRL-Uは一度
	    スタート地点で停止する。

'backspace'が空の時、Vi互換のバックスペースが使用される。自動字下げや、第1カラ
ムの前、そして挿入の開始点を超えてのバックスペースはできない。

下位互換性のために、値として"0"、"1"そして"2"を使用することもできる。
|'backspace'|参照。

'backspace'オプションが"eol"を含まれている時に、カーソルが第1カラムにあり、3つ
のキーのうちどれかが押されると、現在の行が1行前の行に連結される。これはカーソ
ルの前にある<EOL>を事実上消している。
{Vi: 行をまたいだり、挿入の開始点を超えての削除はできない}

						*i_CTRL-V_digit*
CTRL-Vに続けて、10進数、8進数、16進数のどれかで文字コードを直接入力することが
できます。この方法で改行(<NL>, 数値 10)以外のどんな文字でも入力することができ
ます。文字コードを入力するには5つの方法があります。

最初の文字	モード		最大文字数	最大値 ~
(なし)		10進数		    3		 255
o か O		8進数		    3		 255
x か X		16進数		    2		 ff	  (255)
u		16進数		    4		 ffff	  (65535)
U		16進数		    8		 7fffffff (2147483647)

入力できる文字数の最大まで入力すると、例えば<C-V>032と入力した場合にはスペー
ス(値32)が入る。一番上の桁のゼロは省略することができる。その場合には数値を入
力した後に入力する文字は数字以外でなければならない。これは他のモードでも同じ
である。モード中で無効な文字を入力した場合には、それ以前に入力されたものが使
われ無効な文字は通常の入力として扱われる。

値10を入力すると、それは0になってしまう。数値10は<NL>であり、内部で<Nul>文字
を表すのに使われている。バッファをファイルに書き出すときに<NL>は<Nul>に変換
される。<NL>は各行末に出力されるので、<NL>をファイルに書きたければ改行するこ
と。

						*i_CTRL-X* *insert_expand*
CTRL-Xを押すと、幾つかのコマンドを使用することが出来る、サブモードに入る。これ
らのコマンドの多くはキーワードの補完である; |ins-completion|参照。Vimのコンパ
イル時に|+insert_expand|機能を無効にした場合には、この機能は使用できない。

次の2つのコマンドは、挿入モードを抜けることなくウィンドウを上下にスクロールさ
せることができる:

						*i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		ウィンドウを一行上にスクロール。

						*i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		ウィンドウを一行下にスクロール。

CTRL-Xを押した後にCTRL-E(もしくはCTRL-Y)を押すと、現在のファイル内でカーソルを
現在の位置から動かすことなく、ウィンドウが一行上(下)にスクロールする。関係ない
キーが押されると、すぐにCTRL-Xモードは終了し、そのキーが挿入モードで押されたも
のとして解釈される。


==============================================================================
2. もっと特別なキー				*ins-special-special*

下のキーは特別である。これらは現在の挿入を中断し、何かを行い、そして挿入を再開
する。これは挿入モード出ることなく、何かをすることができることを意味している。
これはモードが分かれていない普通のエディタのように、常に挿入モードを使用するの
が好みの場合には、とても便利である。これには'backspace'オプションに
"indent,eol,start"を設定し、'insertmode'オプションを設定すると良いだろう。コマ
ンドにファンクションキーをマップしたいならば、CTRL-Oを使うことができる。

これらのキーを使用する前後の変更(文字の挿入や削除)は、別々に取り消すことができ
る。最後の変更だけがやり直すことができ、常に"i"コマンドのように振舞う。

char		action	~
-----------------------------------------------------------------------
<Up>		カーソルを1行上へ移動する		     *i_<Up>*
<Down>		カーソルを1行下へ移動する		     *i_<Down>*
CTRL-G <Up>	1行上の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_<Up>*
CTRL-G k	1行上の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_k*
CTRL-G CTRL-K	1行上の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_CTRL-K*
CTRL-G <Down>	1行下の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_<Down>*
CTRL-G j	1行下の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_j*
CTRL-G CTRL-J	1行下の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_CTRL-J*
<Left>		カーソルを1文字左へ移動する		     *i_<Left>*
<Right>		カーソルを1文字右へ移動する		     *i_<Right>*
<S-Left>	カーソルを1単語前へ("b"コマンドのように)     *i_<S-Left>*
<C-Left>	カーソルを1単語前へ("b"コマンドのように)     *i_<C-Left>*
<S-Right>	カーソルを1単語後へ("w"コマンドのように)     *i_<S-Right>*
<C-Right>	カーソルを1単語後へ("w"コマンドのように)     *i_<C-Right>*
<Home>		カーソルを行の最初の文字へ		     *i_<Home>*
<End>		カーソルを行の最後の文字の後へ		     *i_<End>*
<C-Home>	カーソルをファイルの最初の文字へ	     *i_<C-Home>*
<C-End>		カーソルをファイルの最後の文字の後へ	     *i_<C-End>*
<LeftMouse>	カーソルをマウスでクリックした位置へ	     *i_<LeftMouse>*
<S-Up>		1ページ上へ				     *i_<S-Up>*
<PageUp>	1ページ上へ				     *i_<PageUp>*
<S-Down>	1ページ下へ				     *i_<S-Down>*
<PageDown>	1ページ下へ				     *i_<PageDown>*
<MouseDown>	3行下へスクロール			     *i_<MouseDown>*
<S-MouseDown>	1ページ下へスクロール			     *i_<S-MouseDown>*
<MouseUp>	3行上へスクロール			     *i_<MouseUp>*
<S-MouseUp>	1ページ上へスクロール			     *i_<S-MouseUp>*
CTRL-O		1つコマンドを実行して、挿入モードに戻る      *i_CTRL-O*
CTRL-G u	アンドゥで元に戻す地点を新たに設定	     *i_CTRL-G_u*
-----------------------------------------------------------------------

Note: カーソルキーを押した時に挿入モードから抜けてしまったら、'noesckeys'オプ
ションをチェックする。

CTRL-Oコマンドは時々副作用を生じる: カーソルが行末を越えている場合に、最後の文
字をその行に表示してしまうかもしれない。マッピングでは<Esc>を使うのが無難です
訳注: 「カーソルが行末を越えている場合に、行の最後の文字の上へ移動してしまうか
訳注: もしれない」では？
(まず"x"を入力し、<Esc>を押すとカーソルは常にその文字の上に置かれます)。

Shiftキーを押しながらのカーソルキー操作は、全ての端末で可能なわけではない。

更に副作用として、"i"や"a"コマンドでの回数指定は無視される。そうしないと
CTRL-Oでのコマンドの繰り返しが複雑になってしまう。

CTRL-G u を使う例: >

	:inoremap <C-H> <C-G>u<C-H>

これはアンドゥできるバックスペースキーを再定義している。これで以前の入力を変
更することなく CTRL-O u を使ってバックスペースの結果を元に戻せる。

'whichwrap'オプションが適切に設定されているならば、行の先頭/末尾での<Left>と
<Right>キーは、カーソルを上の行や下の行へ移動させる。

CTRL-G j と CTRL-G k コマンドはカラムの前にテキストを挿入するのに使える。
例: >
   int i;
   int j;
カーソルが最初の"int"にあるとき、"istatic <C-G>j       "と入力するとこうなる: >
   static int i;
	  int j;
全ての行のカラムに同じテキストを挿入するにはブロック選択コマンド "I"|v_b_I|
を使う。

==============================================================================
3. 'textwidth'と'wrapmargin'オプション			*ins-textwidth*

'textwidth'オプションは入力中の行が長くなりすぎる前に、自動的に改行を行うため
に使うことができる。'textwidth'オプションには望む最大行長を設定する。それを超
えて文字(空白とタブを除く)を入力すると最後の単語が(それがその行の唯一の単語で
無いならば)次の行に置かれる。'textwidth'に0を設定すれば、この機能を無効にする
ことができる。

'wrapmargin'オプションはこれと殆ど同じことをする。違いは'textwidth'は固定幅な
のに対して、'wrapmargin'はスクリーンの幅に依存する。'wrapmargin'を使用すること
は、'textwidth'に(スクリーンのカラム数 - 'wrapmargin'に与えた値)を設定すること
に等しい。

'textwidth'と'wrapmargin'が両方とも設定されていた場合には、'textwidth'が使用さ
れる。

もしも本当には改行をしたくないけれども、見かけ上は具合の良い場所で折り返されて
ほしい場合には、'linebreak'オプションを参照。

自動的に改行されるのは、挿入モードを使用している時か、行に追加している時だけで
ある。置換モードで行の長さが代わらない時には、改行は行われない。

長い行は、マージンを超えて非空白文字を入力すると、改行される。この改行がなされ
る位置は、'formatoptions'オプションに与える文字で制御することが可能である:
"l"  挿入を始めた時に'textwidth'よりも既に長くない時にだけ、改行を行う。
"v"  現在の挿入コマンドの間に挿入された空白文字の位置でのみ、改行を行う。これ
     はほぼVi互換。
"lv" 挿入を始めた時に'textwidth'よりも長くない行にだけ、かつその挿入コマンドの
     間に挿入された空白文字の位置でのみ、改行を行う。'textwidth'の境界を越えて
     非空白文字を入力した時に、"l"と違う。

テキストのブロックを整形(format)したいならば、"gq"オペレータを使うことができ
る。"gq"に続けて、ブロックの末尾までカーソルを動かす移動コマンドをタイプする。
多くの場合、コマンド"gq}"が、望むこと(段落の最後までを整形)をしてくるだろう。
代わりに、現在カーソルがどこにあるかに関わらず、パラグラフ全体をフォーマットし
てくれるコマンド、"gqap"を使うこともできる。またはビジュアル選択モードを使うこ
ともできる: "v"を押し、ブロックの最後まで移動し、"gq"とタイプする。|gq|も参
照。

==============================================================================
4. 'expandtab'、'smarttab'それと'softtabstop'オプション	*ins-expandtab*

'expandtab'オプションがオンになっていると、タブ文字は空白文字(スペース)に展開
され、その空白文字が挿入される。もし本当の<Tab>文字を挿入したいのならば、
CTRL-Vを押してから入力する(CTRL-Vに他の動作がマップされているときはCTRL-Qを使
う|i_CTRL-Q|)。
'expandtab'は初期状態でオフになっている。置換モードでは、1文字が複数のスペース
で置換されることに注意。この結果、行の中の文字数は増える。バックスペースをする
と、1度に1つの空白が削除される。元々そこにあった文字は、1つのスペース(最後の1
つ)を削除しただけで元に戻される。{Vi には'expandtabオプションは存在しない}

							*ins-smarttab*
'smarttab'オプションがオンの時には、1度の<Tab>で、行の先頭で<Tab>を1度押すと
'shiftwidth'の位置まで、その他の場所では'tabstop'の位置まで空白が挿入される。
これは<Tab>文字の代わりに、度々スペースが挿入されることを意味している。
'smarttab'がオフの時には、<Tab>では常に'tabstop'の位置まで空白が挿入され、
'shiftwidth'は">>"などの時にだけ使用される。{Vi には無い機能}

							*ins-softtabstop*
'softtabstop'オプションが零ではない時、<Tab>は'softtabstop'で指定されるタブ位
置まで空白を挿入し、<BS>は'softtabstop'で指定されるタブ位置までの空白を削除す
る。これは'softtabstop'に指定した値を'tabstop'に設定したのと同様に働くが、しか
し本当の<Tab>文字は依然'tabstop'の幅に展開されるので、他のアプリケーションでそ
のファイルを使う時にも正しく表示されるだろう。

もしも'softtabstop'がゼロでないならば、直前に挿入された文字が1つの空白文字(ス
ペース)で、そのカーソルの直前の(空白)文字だけを削除する時を除き、<BS>は空白文
字を一つ前の'softtabstop'の位置まで削除しようと試みる。そうでないとカーソルの
直前の単一の文字を消すということができなくなってしまう。まず'softtabstop'の
キャラクタを消してから、それから望む場所にカーソルを持っていくために、余分な空
白文字を置く必要がある。

==============================================================================
5. 置換モード			*Replace* *Replace-mode* *mode-replace*

ノーマルモードで"R"コマンドを使うと置換モードに入る。

置換モードでは、タイプされた全て文字のために行の文字が削除される。消す文字が無
い場合(行末)、タイプされた文字は(挿入モードのように)追加される。このように行末
に至るまで、行内のまとまった数の文字が同じままとどまる。<NL>がタイプされると、
文字は消されずに改行が挿入される。

<Tab>文字には注意。<Tab>のある場所に通常の印刷可能文字をタイプすると、文字数は
同じだけど、見た目上のカラム数はより短くなってしまう。

置換モードで文字を消す(<BS>、CTRL-WもしくはCTRL-U)場合、変更を取り消すことにな
る。置き換えられてしまった文字が復帰する。存在していたテキストよりも多くタイプ
していた場合には、その追加した分は削除される。これは効果的に1度に1文字ずつの
UNDOになる。

'expandtab'オプションがオンの場合、<Tab>は幾つかのスペースで置き換えられる。結
果として行中の文字数は増えることになる。バックスペースは一度に1つの文字を消
す。もともとの文字は1つのスペース(最後の1つ)をバックスペースするだけで戻され
る。{Vi には'expandtab'オプションはない}

==============================================================================
6. 仮想置換モード		*vreplace-mode* *Virtual-Replace-mode*

ノーマルモードで"gR"コマンドを使うと仮想置換モードに入る。
{+vreplace機能を付けずにコンパイルした場合は利用できない}
{Vi には仮想置換モードはない}

仮想置換モードは置換モードに良く似ているが、ファイルの実際の文字ごとにではな
く、スクリーン上の文字幅単位で置換することができ、そのためファイル内の他の文字
の見た目の位置が移動することはない。

<Tab>をタイプすると通常のキャラクタを幾つか置換し、<Tab>の先頭で文字をタイプし
たならば、<Tab>は以前と同じ場所に存在することになるから、なにも置換されないこ
とになる。

<NL>をタイプしても、ファイル内の後の文字がその(見かけ上の)位置を変えることはな
い。現在行の残りの部分は<NL>によって置き換えられ(それはつまり、消されるという
こと)、次の行で置換が続行される。ファイルの終端に達するまで、新しい行は挿入さ
れない。

CTRL-TとCTRL-Dを使用したときには面白い効果がある。カーソルの前のキャラクタは普
通に横にシフトされるが、しかしカーソルの後のキャラクタはそのままそこに残ろうと
する。CTRL-Tはシフトされた文字の下にある古い行を隠していくが、CTRL-Dはそれらを
再び表示してくれる。

置換モード同様に、<BS>他を使用すると置換されてしまった文字を戻すことができる。
この機能は'smartindent', CTRL-TそれにCTRL-D, 'expandtab', 'smarttab',
'softtabstop', その他などが考慮される。

'list'モードで'cpoptions'に"L"が含まれない時には、仮想置換モードはまるで'list'
モードでないかのように振舞う。

TRANS_TODO
Note that the only times characters beyond the cursor should appear to move
are in 'list' mode, and occasionally when 'wrap' is set (and the line changes
length to become shorter or wider than the width of the screen), or
momentarily when typing over a CTRL character.
(訳注:ここ、どうしてもうまく訳せません…m(_ _)m)
コントロール文字は1文字でスクリーン文字を2文字占有する。それを通常の文字2文字
で置換すると、最初の1文字目は挿入され2文字目がコントロール文字を置換する。

このモードは<Tab>でカラムが区切られた表へ、新しいデータをカラムを揃えて入力す
るような編集作業に便利である。

==============================================================================
7. 挿入モードの補完					*ins-completion*

挿入・置換モードでは、既にタイプしたキーワードや行の一部を補完するコマンドを使
用できる。これは複雑なキーワード(例えば大文字やアンダースコアを含む関数名など)
を使用しているときに便利である。

この機能はコンパイル時に|+insert_expand|機能を有効にしておかないと使用できな
い。

補完には次のような種類がある:

1. 行全体						|i_CTRL-X_CTRL-L|
2. 現在のファイルのキーワード				|i_CTRL-X_CTRL-N|
3. 'dictionary'のキーワード				|i_CTRL-X_CTRL-K|
4. 'thesaurus'のキーワード, thesaurus-style		|i_CTRL-X_CTRL-T|
5. 編集中と外部参照しているファイルのキーワード		|i_CTRL-X_CTRL-I|
6. タグ							|i_CTRL-X_CTRL-]|
7. ファイル名						|i_CTRL-X_CTRL-F|
8. 定義もしくはマクロ					|i_CTRL-X_CTRL-D|
9. Vimのコマンドライン					|i_CTRL-X_CTRL-V|
10. 'complete'のキーワード				|i_CTRL-N|

これら総て(2の「現在の..」を除く)はCTRL-Xモードで動作する。CTRL-Xモードとは挿
入・置換モードのサブモードである。CTRL-XとCTRL-Xコマンドのどれか1つをタイプす
ることでCTRL-Xモードに移行する。CTRL-Xモードから抜けるにはコマンドとして有効で
はないキーをタイプする。有効なキーとはCTRL-Xコマンドそれ自身、CTRL-N(次の候
補)、そしてCTRL-P(前の候補)である。

マッチの大文字/小文字を調節したいのならばオプション'infercase'を参照。

Note: CTRL-Xモードでの有効なキーはマップされない。これは":map ^F ^X^F"な指定を
可能にする(^Fと^XはそれぞれCTRL-FとCTRL-Xの意味)。これに対して、CTRL-Xモードを
終了させるキー(つまりCTRL-Xモードのコマンドとして有効ではないキー)はマップされ
る。'complete'を使って補完をするとき、マップは通常通りに適用される。

次のマッピングは補完コマンドのタイピングをちょっとだけ楽にしようと提案された
(これらは他のコマンドを覆い隠してしまうけれど): >
    :inoremap ^] ^X^]
    :inoremap ^F ^X^F
    :inoremap ^D ^X^D
    :inoremap ^L ^X^L

例外として、レジスタの値を挿入するCTRL-RはCTRL-Xモードを終了しない。これは主
に'='レジスタを使って関数などを呼び次の操作を決定することを可能にする。レジ
スタの内容(や'='レジスタの評価結果)がCTRL-Xモードで無効なキーだった場合、そ
れが入力されたものとしてCTRL-Xモードは終了する。

以下のものは現在の行がスペースだけなら<Tab>を入力し、違うならCTRL-Nの補間をす
る<Tab>をマッピングする例である: >

	function! CleverTab()
	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
	      return "\<Tab>"
	   else
	      return "\<C-N>"
	endfunction
	inoremap <Tab> <C-R>=CleverTab()<CR>


行全体を補完する					*compl-whole-line*

							*i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		現在行のカーソルの前にあるのと同じ文字で始まる行を、後
			方(上方向)に探す。インデントは無視される。見つかった行
			がカーソルの前に挿入される。
			'complete'オプションがどのバッファから探すのかを決める
			のに使われます。しかし、読み込まれたバッファだけが使わ
			れます。
	CTRL-L	or
	CTRL-P		後方に、次にマッチする行を探す。これによりみつかった行
			で、以前のマッチした行を置き換える。

	CTRL-N		前方に、次のマッチする行を探す。これによりみつかった行
			で以前のマッチした行を置き換える。

	CTRL-X CTRL-L	行を展開した後で再びCTRL-X CTRL-Lをタイプすれば、それ
			に続けて付加的に行を取得でき、CTRL-Xを2回押すことで終
			了する。
			
現在のファイルのキーワードで補完する			*compl-current*

							*i_CTRL-X_CTRL-P*
							*i_CTRL-X_CTRL-N*
CTRL-X CTRL-N		カーソルの前にあるキーワードで始まる単語を、前方に検索
			する。みつかったキーワードはカーソルの前に挿入される。

CTRL-X CTRL-P		カーソルの前にあるキーワードで始まる単語を、後方に検索
			する。みつかったキーワードはカーソルの前に挿入される。

	CTRL-N		次にマッチするキーワードを前方に検索する。このキーワー
			ドは前回マッチしたキーワードを置き換える。

	CTRL-P		次にマッチするキーワードを後方に検索する。このキーワー
			ドは前回マッチしたキーワードを置き換える。

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	続けてCTRL-X CTRL-NやCTRL-X CTRL-Pを使用することで、
			最後の展開に続けて違うコンテキストで単語を補完すること
			ができる。これはCTRL-Xを2度押すことで終了できる。

カーソルの直前にあるキーワード(アルファベットと'iskeyword'の文字で構成される名
前)が、直前に"\<"(単語の開始の意味)が補われて検索パターンとして使用される。
キーワードがない場合には"\<\k\k"(少なくとも2文字以上のキーワードの開始位置)が
検索パターンに用いられる。

置換モードでは、置換される文字数はマッチした文字列の長さに依存する。これはマッ
チした文字列を置換モードでタイピングしたのと同じように振舞う。

カーソルの直前に有効なキーワードの文字がなかった場合、少なくとも2文字以上のあ
らゆるキーワードがマッチする。
	例えば、次の結果を得るには:
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	このようにタイプする:
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);

同じ補完結果が繰り返される場合にはそれがスキップされる; そのためCTRL-NやCTRL-P
を押すたびに違うマッチ文字列が挿入されることになる(1つしかマッチするキーワード
がない場合は除く)。

マッチ結果が1文字のとなる補完候補文字列は、通常の使用で実際に補完して欲しいで
はないことがほとんどなので、補完候補に含まない。
	例えば、次の結果を得るには:
		printf("name = %s\n", name);
	このようにタイプする:
		printf("name = %s\n", n^P);
	こうでも良い:
		printf("name = %s\n", ^P);
'\n'の中の文字'n'はスキップされる。

単語補完を開始した後で、補完済み単語に続く単語を検索するのに、CTRL-X CTRL-Pも
しくはCTRL-X CTRL-Nを使うことができる。これらのシーケンスはテキストから探さ
れ、単語を拡張補完し、さらに拡張補完していくことができる。これは複雑な単語の
シーケンスを繰り返す必要があるときに役に立つ。CTRL-PとCTRL-Nは少なくとも2文字
以上の文字列を探すけれども、CTRL-X CTRL-PとCTRL-X CTRL-Nは1文字の文字列も探し
出す。
	例えば、次の結果を得るには:
		M&eacute;xico
	このようにタイプする:
		M^N^P^X^P^X^P
CTRL-Nは補完を開始し、CTRL-Pで最初の1文字"M"に戻し、次の2つのCTRL-X CTRL-Pが
"&eacute"と";xico"を得る。

直前の補完が'textwidth'よりも長いために分裂している場合、現在の行のテキストだ
けが使用される。

マッチ文字列が行末で見つかった場合には、次の行の最初の単語が挿入され"word from
next line"というメッセージが表示される。さらに続けてCTRL-X CTRL-Pもしくは
CTRL-X CTRL-Nで検索を行なうと、その単語のある行で続く文字が検索される。


'dictionary'のキーワードで補完する			*compl-dictionary*

							*i_CTRL-X_CTRL-K*
CTRL-X CTRL-K		カーソルの直前のキーワードで始まる単語をオプション
			'dictionary'で与えられたファイルから検索する。これは
			CTRL-Nに似ているが、現在のファイル内は検索せずに辞書
			ファイル内だけを検索する。見つけたキーワードはカーソル
			の直前に挿入される。最初のマッチが使用される前に総ての
			マッチが検索されるので、かなり遅くなる可能性がある。オ
			プション'dictionary'の初期値は空である。
			どこから単語リストを見つけ出すかについては、オプション
			'dictionary'を参照。

	CTRL-K	or
	CTRL-N		マッチするキーワードの前方検索。直前にマッチしたキー
			ワードは新しいもので置き換えられる。

	CTRL-P		マッチするキーワードの後方検索。直前にマッチしたキー
			ワードは新しいもので置き換えられる。

							*i_CTRL-X_CTRL-T*
CTRL-X CTRL-T		CTRL-X CTRL-Kと同じだが、'dictionary'ではなく
			'thesaurus'オプションを使う。たとえ単語が完全でなくて
			も、類語ファイルの中に単語が見つかると、その行の他の単
			語も一致とみなされる。したがって単語は完全に置き換えら
			れる。

			例えば、'thesaurus'ファイルにこのような行があるし
			て: >
				angry furious mad enraged
<			カーソルが"ang"の後にあり、CTRL-X CTRL-Tを押すと
			"angry"が補間される。続けて補間すると
			"furious"、"mad"、...、と置き換えられる。
			他にも二つの言語間の単語の置き換えや、API関数をキー
			ワードによってグループ分けするのに使える。

	CTRL-T	or
	CTRL-N		次のキーワードを前方に探す。見つかったキーワードはそ
			の前のキーワードを置き換える。

	CTRL-P		次のキーワードを後方に探す。見つかったキーワードはそ
			の前のキーワードを置き換える。


編集中と外部参照しているファイルのキーワードで補完する	*compl-keyword*

'include'オプションは外部参照(インクルード)ファイルを含む行を指定するのに使
う。'path'オプションはインクルードファイルを探す場所を指定するのに使う。

							*i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		カーソルの直前と同じ文字で始まる最初のキーワードを、現
			在のファイルとインクルードファイルから探し出す。マッチ
			したキーワードはカーソルの直前に挿入される。

	CTRL-N		次にマッチするキーワードを前方検索する。直前にマッチし
			たキーワードは新しいもので置き換えられる。
			Note: CTRL-Iは補完が成功した時に入力する<Tab>と同じで
			ある。従ってCTRL-Iを次のマッチを探すために使用すること
			はできない。

	CTRL-P		次にマッチするキーワードを後方検索する。直前にマッチし
			たキーワードは新しいもので置き換えられる。

	CTRL-X CTRL-I	直前の補完の文脈で続けてCTRL-X CTRL-Iによる単語補完を
			行なう。2連CTRL-Xが使用されるまで続く。


タグで補完する						*compl-tag*
							*i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		カーソルの直前と同じ文字で始まる最初のタグを探し出す。
			マッチしたタグはカーソルの直前に挿入される。アルファ
			ベットと'iskeyword'で指定される文字が、タグ名にどの文
			字が含まれるかを決定する(これはキーワードと同じルー
			ル)。|CTRL-]|も参照。'showfulltag'オプションはタグ定義
			の周辺からコンテキストに含めるために使用される。
	CTRL-]	or
	CTRL-N		次にマッチするタグを前方検索する。直前にマッチしたタグ
			は新しいもので置き換えられる。

	CTRL-P		次にマッチするタグを後方検索する。直前にマッチしたタグ
			は新しいもので置き換えられる。


ファイル名で補完する					*compl-filename*
							*i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		カーソルの直前と同じ文字で始まる最初のファイル名を探し
			出す。マッチしたファイル名はカーソルの直前に挿入され
			る。アルファベットと'isfname'で指定される文字が、ファ
			イル名にどの文字が名前に含まれるかを決定する。Note: こ
			の段階では(まだ)'path'オプションは使用されない。
	CTRL-F	or
	CTRL-N		次にマッチするファイル名を前方検索する。直前にマッチし
			たファイル名は新しいもので置き換えられる。


	CTRL-P		次にマッチするファイル名を後方検索する。直前にマッチし
			たファイル名は新しいもので置き換えられる。


定義もしくはマクロで補完する				*compl-define*

定義を含んだ行を特定するのに'define'オプションが使用される。インクルードファイ
ルを含んだ行を特定するのに'include'オプションが使用される。インクルードファイ
ルを探すのに'path'オプションが使用される。

							*i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		カーソルの直前と同じ文字で始まる最初の定義(もしくはマ
			クロ)名を、現在のファイルとインクルードファイルから探
			し出す。マッチした定義名はカーソルの直前に挿入される。
	CTRL-D	or
	CTRL-N		次にマッチするマクロ名を前方検索する。直前にマッチした
			マクロ名は新しいもので置き換えられる。

	CTRL-P		次にマッチするマクロ名を後方検索する。直前にマッチした
			マクロ名は新しいもので置き換えられる。

	CTRL-X CTRL-D	直前の補完の文脈で続けてCTRL-X CTRL-Dによる単語補完を
			行なう。2連CTRL-Xが使用されるまで続く。

Vimコマンドの補間					*compl-vim*

補間は文脈に左右される。コマンドラインでの入力時のように機能する。Exコマンドと
その引数も補間する。


							*i_CTRL-X_CTRL-V*
CTRL-X CTRL-V		カーソルの前に何があるかを推測し、最初に一致するもの
			を探す。
			Note: CTRL-Vがマッピングに使われていれば、たいていは
			CTRL-Qが変わりに使える|i_CTRL-Q|。
	CTRL-V or
	CTRL-N		次の一致を前方に探す。そしてその前のものを置き換え
			る。

	CTRL-P		次の一致を後方に探す。そしてその前のものを置き換え
			る。

	CTRL-X CTRL-V	加えて言うと CTRL-X CTRL-V は CTRL-V と同じように働
			く。これはVimコマンドの補間をマッピングをするのに使
			える。例えば: >
				:imap <Tab> <C-X><C-V>


キーワードを別のソースから補完する。			*compl-generic*

							*i_CTRL-N*
CTRL-N			カーソルの直前と同じ文字で始まる単語を、'complete'オプ
			ションで指定された場所から後方検索する。マッチしたキー
			ワードはカーソルの直前に挿入される。

							*i_CTRL-P*
CTRL-P			カーソルの直前と同じ文字で始まる単語を、'complete'オプ
			ションで指定された場所から前方検索する。マッチしたキー
			ワードはカーソルの直前に挿入される。

	CTRL-N		次にマッチするキーワードを前方検索する。直前にマッチし
			たキーワードは新しいもので置き換えられる。

	CTRL-P		次にマッチするキーワードを後方検索する。直前にマッチし
			たキーワードは新しいもので置き換えられる。

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	直前の補完の文脈で続けてCTRL-X CTRL-NもしくはCTRL-X
			CTRL-Pによる単語補完を行なう。2連CTRL-Xが使用されるま
			で続く。

==============================================================================
8. 挿入モードのコマンド					*inserting*

下のコマンドはバッファに新しいテキストを挿入するのに使うことができる。それらは
全て取り消すことができるし、"."コマンドで繰り返すことができる。

							*a*
a			カーソルの後ろにテキストを[count]回追加する。
			'virtualedit'がセットされていないなら、カーソルが空行
			の最初のカラムにあるときはそこに挿入する。

							*A*
A			行末にテキストを[count]回追加する。

<insert>	or				*i* *insert* *<Insert>*
i			カーソルの前にテキストを[count]回挿入する。
			挿入モード中のCTRL-O|i_CTRL-O|で使うときはカウントはサ
			ポートされていない。

							*I*
I			行の先頭の非空白文字の前にテキストを[count]回挿入す
			る。

							*gI*
gI			カラム1からテキストを[count]回挿入する。{Vi にはない}

							*gi*
gi			カレントバッファの最後に入力がされた場所にテキストを
			入力する。
			これは|'^|マークを使う。マークが行末を越えているとき
			に"'^i"と動作が異なる。
			行が挿入、削除されていると入力位置は調整されるが、文
			字単位の変更は考慮されない。
			|:keepjumps|コマンドが使われると|'^|マークは変更され
			る。
			{Vi にはない}

							*o*
o			カーソルのある行の下に新しい行を作り、そこにテキストを
			[count]回繰り返し挿入する。{Vi:空行を[count]行挿入す
			る}

							*O*
O			カーソルのある行の上に新しい行を作り、そこにテキストを
			[count]回繰り返し挿入する。{Vi:空行を[count]行挿入す
			る}

これらのコマンドはテキストの挿入を開始するのに使われる。挿入モードは<Esc>で止
めることができる。挿入モードでのその他の特殊な文字は|mode-ins-repl|を参照。
[count]の効果は挿入モードから抜けた時に現れる。

'autoindent'が設定されている時には、新しい行のインデントに、前の行と同じものが
使用される。'smartindent'か'cindent'が設定されている時には、行のインデントはC
プログラム(ソースコード)のスタイルに、自動的に調整される。

'textwidth'は、行の最大幅(文字数)を設定することができる。文字を追加している時
に行が長くなりすぎると、自動的に改行が挿入される。


==============================================================================
9. Exの挿入コマンド					*inserting-ex*

							*:a* *:append*
:{range}a[ppend]	指定された行の下に何行分かのテキストを挿入する。
			{range}が省略された場合、テキストは現在行の後から挿入
			される。

							*:i* *:in* *:insert*
:{range}i[nsert]	指定された行の上に何行分かのテキストを挿入する。
			{range}が省略された場合、テキストは現在行の前から挿入
			される。

これら2つのコマンドは、"."だけを含んだ行を入力するまで、挿入すべきテキストを待
ちつづける。バックスラッシュで始まる行には警戒すべし。|line-continuation|参照。
NOTE: ":append"と":insert"は":if"と":endif"の間では機能しません。

							*:start* *:startinsert*
:star[tinsert][!]	このコマンドの実行直後に挿入モードを開始する。ノーマル
			モードで"i"をタイプしたように働く。!が含まれていた時に
			は、行に追加する"A"のように働く。そうでなければ現在の
			位置から挿入が始まる。関数やスクリプトの中でこのコマン
			ドを使用したときには、関数やスクリプトが終了してから挿
			入が始まることに注意。
			{Vi にはない}
			{+ex_extra機能を無効にしてコンパイルした場合は利用でき
			ない}

							*:stopi* *:stopinsert*
:stopi[nsert]		できるだけ早く挿入モードを中止します。挿入モードで
			<Esc>を押したように機能します。
			オートコマンドで使うことができます。例: >
				:au BufEnter scratch stopinsert

==============================================================================
10. ファイルを挿入する					*inserting-file*

							*:r* *:re* *:read*
:r[ead] [name]		カーソルの後ろに、ファイル[name] (省略した場合:現在の
			ファイル)を挿入する。

:{range}r[ead] [name]	指定したラインの下に、ファイル[name](省略した場合:現在
			のファイル)を挿入。

							*:r!* *:read!*
:r[ead] !{cmd}		カーソルの後ろに、{cmd}を実行したその標準出力の内容を
			挿入。コマンドの出力を蓄え、バッファに読み込むために、
			テンポラリファイルが使用される。コマンドの出力を保存す
			るために'shellredir'が使用されるので、標準エラー出力も
			含めるか含めないか指定することができる。{cmd}は
			":!{cmd}と同じように実行されるので、'!'だけを指定した
			場合には、以前に実行された|:!|コマンドに置き換えられ
			る。

これらのコマンドは、ファイルの内容、もしくはコマンドの出力をバッファへ挿入す
る。これらは取り消す(UNDO)ことができる。これらは"."コマンドで繰り返すことはで
きない。これらは行単位で行われる操作で、挿入はカーソルの直後のラインからか、指
定したラインの直後から行われる。一番最初のラインより上(ファイルの先頭)に挿入す
るには":0r {name}"というコマンドを使う。

":read"コマンドの後には、新しいラインの左で、最初の空白でない文字にカーソルが
移動する。もしExモードでなければ、カーソルは新しい行の最後の左側に移動する(残
念だがViとの互換性のため)。

":r"にファイル名が与えられた場合、それを裏バッファのファイルになる。これは例え
ば代わりにそのファイルを編集したい時に使うことができる: "e! #"。'cpoptions'オ
プションから'a'フラグを削除することで、オフに切り替えることができる。

							*file-read*
'fileformat'オプションがファイルの<EOL>の流儀を決定する:
'fileformat'    文字		   名前				~
  "dos"		<CR><NL> or <NL>   DOS format
  "unix"	<NL>		   Unix format
  "mac"		<CR>		   Mac format
以前には'textmode'が使用された。それは現在では廃れている。

'fileformat'が"dos"の時には、<NL>の前の<CR>は無視され、ファイルの終端にある
CTRL-Zもまた無視される。

'fileformat'が"mac"の時には、ファイル内の<NL>は内部的に<CR>によって表現され
る。これは<NL>を表現するために使用される<NUL>との混同を避けるためである。
|CR-used-for-NL|参照。

'fileformats'オプションが空でなかったら、Vimは<EOL>のタイプを識別しようと試み
る(|file-formats|参照)。しかしながら、'fileformat'オプションは変更されない。検
出されたフォーマットはファイルの読み込みの際にだけ使用される。
'fileencodings'についても同様。

MS-DOS、Win32そしてOS/2以外のシステムでは、DOSフォーマットのファイルを読み込ん
だときにはそれを知らせるために、"[dos format]"というメッセージが表示される。
マッキントッシュ、MS-DOS、Win32そしてOS/2においては、ファイルがUnixフォーマッ
トであった場合に、"[unix format]"というメッセージが表示される。
マッキントッシュ以外のシステムでは、ファイルがマックフォーマットであった場合
に、"[Mac format]"というメッセージが表示される。

":r ！”をどう使うかの例: >
	:r !uuencode binfile binfile
このコマンドは"binfile"を読み込みuuencode化して、それを現在のバッファに読み込
む。e-mailを編集していて、バイナリファイルを含めたい時に便利である。

							*read-messages*
ファイルを読み込むときVimはその情報を表示する。いくつかのものについての説明
をあげる。他のものは見ればわかる。ロングとショートのどちらを使うかは
'shortmess'オプションに依存する。

	ロング		ショート	意味 ~
	[readonly]	{RO}		ファイルは書き込み制限されている
	[fifo/socket]			ストリームを使っている
	[fifo]				FIFOストリームを使っている
	[socket]			ソケットストリームを使っている
	[CR missing]			"dos"ファイルフォーマットで読み込ん
					でいてCRのないNLを見つけた
	[NL found]			"mac"ファイルフォーマットで読み込ん
					でいてNLを見つけた(unixフォーマット
					なのだろう)
	[long lines split]		少なくとも一つの行が二つに分割された
	[NOT converted]			'fileencoding'から'encoding'の変換が
					失敗した
	[converted]			'fileencoding'から'encoding'への変換
					を実施した。
	[crypted]			暗号が解除された
	[READ ERRORS]			ファイルを全て読み込めなかった

(訳注)以下日本語メッセージの場合
	ロング		ショート	意味 ~
	[読込専用]	[読専]		ファイルは書き込み制限されている
	[FIFO/ソケット]			ストリームを使っている
	[FIFO]				FIFOストリームを使っている
	[ソケット]			ソケットストリームを使っている
	[CR無]				"dos"ファイルフォーマットで読み込ん
					でいてCRのないNLを見つけた
	[NL有]				"mac"ファイルフォーマットで読み込ん
					でいてNLを見つけた(unixフォーマット
					なのだろう)
	[長行分割]			少なくとも一つの行が二つに分割された
	[未変換]			'fileencoding'から'encoding'の変換が
					失敗した
	[変換済]			'fileencoding'から'encoding'の変換
					を実施した。
	[暗号化]			暗号が解除された
	[読込エラー]			ファイルを全ては読み込めなかった


 vim:tw=78:ts=8:ft=help:norl:
