---
layout: vimdoc
helpname: 'channel'
---
<div id='vimCodeElement'>
<a class="Constant" href="channel.html" name="channel.txt">channel.txt</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim バージョン 8.1.</span>&nbsp;&nbsp;Last change: 2019 Mar 21<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Identifier">VIMリファレンスマニュアル&nbsp;&nbsp;&nbsp;&nbsp;by Bram Moolenaar</span><br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;プロセス間通信&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel" name="channel">channel</a><br>
<br>
Vim は別のプロセスと通信するのにチャネルを用います。<br>
チャネルはソケットまたはパイプを用います。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#socket-interface" name="socket-interface">socket-interface</a><br>
ジョブはプロセスを開始し、プロセスと通信するために使用できます。<br>
Netbeans インターフェイスもチャネルを使っています。<a class="Identifier" href="netbeans.html#netbeans">netbeans</a><br>
<br>
1. 概要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#job-channel-overview">job-channel-overview</a><br>
2. チャネルデモ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#channel-demo">channel-demo</a><br>
3. チャネルを開く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#channel-open">channel-open</a><br>
4. JSON、JS チャネルを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#channel-use">channel-use</a><br>
5. チャネルコマンド&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#channel-commands">channel-commands</a><br>
6. RAW、NL チャネルを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#channel-raw">channel-raw</a><br>
7. その他のチャネル機能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#channel-more">channel-more</a><br>
8. チャネルでジョブを開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#job-start">job-start</a><br>
9. チャネルなしでジョブを開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#job-start-nochannel">job-start-nochannel</a><br>
10. ジョブオプション&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#job-options">job-options</a><br>
11. ジョブを制御する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#job-control">job-control</a><br>
12. プロンプトバッファを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#prompt-buffer">prompt-buffer</a><br>
<br>
<span class="Special">{Vi にはこれらの機能はありません}</span><br>
<span class="Special">{Vim が&nbsp;</span><a class="Identifier" href="various.html#+channel">+channel</a><span class="Special">&nbsp;機能付きでコンパイルされたときのみ有効}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Comment">has('channel')</span>&nbsp;でこれを確認できる<br>
<span class="Special">{Vim が&nbsp;</span><a class="Identifier" href="various.html#+job">+job</a><span class="Special">&nbsp;機能付きでコンパイルされたときのみ有効}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Comment">has('job')</span>&nbsp;でこれを確認できる<br>
<br>
<span class="PreProc">==============================================================================</span><br>
1. 概要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-channel-overview" name="job-channel-overview">job-channel-overview</a><br>
<br>
主に 4 種類のジョブがあります:<br>
1. いくつかの Vim インスタンスを扱うデーモン。Vim はソケットで接続します。<br>
2. 1 つの Vim インスタンスを 1 つのジョブが非同期に処理する。ソケットまたはパ<br>
&nbsp;&nbsp; イプを使用します。<br>
3. 短時間、非同期で仕事をするジョブ。ソケットまたはパイプを使用します。<br>
4. フィルタを同期して実行する。パイプを使用します。<br>
<br>
ソケットを使用する場合&nbsp;<a class="Identifier" href="channel.html#job-start">job-start</a>、<a class="Identifier" href="channel.html#job-start-nochannel">job-start-nochannel</a>、および<br>
<a class="Identifier" href="channel.html#channel-open">channel-open</a>&nbsp;参照。2 と 3 の場合は、パイプを使用する 1 つ以上のジョブです<br>
(<a class="Identifier" href="channel.html#job-start">job-start</a>&nbsp;参照)。<br>
4 の場合、&quot;:<span class="Special">{range}</span>!cmd&quot; コマンドを使用します (<a class="Identifier" href="change.html#filter">filter</a>&nbsp;参照)。<br>
<br>
ソケットとパイプ上でこれらのプロトコルを利用できます:<br>
RAW&nbsp;&nbsp;&nbsp;&nbsp; 何も知られていない、Vim はメッセージの終わりを知らせない。<br>
NL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;すべてのメッセージは NL (改行) 文字で終わります。<br>
JSON&nbsp;&nbsp;&nbsp;&nbsp;JSON エンコーディング&nbsp;<a class="Identifier" href="eval.html#json_encode()">json_encode()</a><br>
JS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript スタイルの JSON 風のエンコーディング&nbsp;<a class="Identifier" href="eval.html#js_encode()">js_encode()</a><br>
<br>
共通の組み合わせ:<br>
- NL モードでパイプを介して接続されたジョブを使用します。例えば、スタイルチェッ<br>
&nbsp;&nbsp;カーを実行し、エラーと警告を受け取ります。<br>
- デーモンを使用して、JSON モードでソケットに接続します。例えば、データベース<br>
&nbsp;&nbsp;内の相互参照を参照します。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
2. チャネルデモ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-demo" name="channel-demo">channel-demo</a>&nbsp;<a class="Constant" href="channel.html#demoserver.py" name="demoserver.py">demoserver.py</a><br>
<br>
デモには Python が必要です。デモプログラムは次の場所にあります。<br>
$VIMRUNTIME/tools/demoserver.py<br>
それをあるターミナルで実行しましょう。そのターミナルを T1 と呼びます。<br>
<br>
次に別のターミナルでVimを実行します。そして以下のコマンドでサーバーに接続しま<br>
す:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open('localhost:8765')</div>
<br>
T1 の中に次のように表示されます:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">=== socket opened ===</span><br>
<br>
ついにサーバーにメッセージを送信できます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo ch_evalexpr(channel, 'hello!')</div>
<br>
このメッセージは T1 で受信され、Vim には応答が送り返されます。<br>
T1 では Vim が送った生のメッセージを確認できます:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[1,&quot;hello!&quot;]</span><br>
そしてレスポンスはこうなります:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[1,&quot;got it&quot;]</span><br>
この数値はメッセージを送るたびに増加していきます。<br>
<br>
サーバーは Vim にコマンドを送信できます。T1 において、次のように正確に (引用符<br>
を含めて文字通りに) タイプしてください:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;ex&quot;,&quot;echo 'hi there'&quot;]</span><br>
するとそのメッセージが Vim に表示されます。カーソルを1単語先に移動することがで<br>
きます:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;normal&quot;,&quot;w&quot;]</span><br>
<br>
非同期通信を取り扱うためにはコールバック (以下ハンドラー) が必要です:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func MyHandler(channel, msg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo &quot;from the handler: &quot; . a:msg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendexpr(channel, 'hello!', {'callback': &quot;MyHandler&quot;})</div>
Vim は応答を待つことはありません。これで、サーバーは応答を後で送信し、<br>
MyHandler が呼び出されます。<br>
<br>
send を呼ぶたびに毎回コールバックを指定する代わりに、チャネルを開く際に指定す<br>
ることもできます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ch_close(channel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open('localhost:8765', {'callback': &quot;MyHandler&quot;})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendexpr(channel, 'hello!')</div>
<br>
チャネルを試してみると、何が起こっているのかを知ることができます。あなたは Vim<br>
にログファイルに行を書くよう指示することができます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ch_logfile('channellog', 'w')</div>
<a class="Identifier" href="eval.html#ch_logfile()">ch_logfile()</a>&nbsp;参照.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
3. チャネルを開く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-open" name="channel-open">channel-open</a><br>
<br>
チャネルを開くには次のようにします:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open({address} [, {options}])<br>
&nbsp;&nbsp;&nbsp;&nbsp;if ch_status(channel) == &quot;open&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; use the channel</div>
<br>
<a class="Identifier" href="eval.html#ch_status()">ch_status()</a>&nbsp;を使用して、チャネルを開くことができたかどうかを確認します。<br>
<br>
<span class="Special">{address}</span>&nbsp;は &quot;ホスト名:ポート番号&quot; の形式です。例:&quot;localhost:8765&quot;<br>
<br>
<span class="Special">{options}</span>&nbsp;はオプションのエントリを持つ辞書です:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-open-options" name="channel-open-options">channel-open-options</a><br>
<br>
&quot;mode&quot; でモード (通信フォーマット) を指定します:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-mode" name="channel-mode">channel-mode</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;json&quot; - JSONを使う (詳しくは下記を参照。もっとも使いやすい方法。既定)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;js&quot;&nbsp;&nbsp; - JS (JavaScript) エンコーディングを使用し、JSON よりも効率的。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;nl&quot;&nbsp;&nbsp; - NL 文字で終わるメッセージを使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;raw&quot;&nbsp;&nbsp;- raw メッセージを使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-callback" name="channel-callback">channel-callback</a>&nbsp;<a class="Constant" href="channel.html#E921" name="E921">E921</a><br>
&quot;callback&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メッセージ受信時に他のハンドラーで扱われない時に呼ばれます。こ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;れはチャネルのハンドルと、受信したメッセージの 2 つの引数を取<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ります。例:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func Handle(channel, msg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo '受信した: ' . a:msg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open(&quot;localhost:8765&quot;, {&quot;callback&quot;: &quot;Handle&quot;})</div>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mode&quot; が &quot;json&quot;, &quot;js&quot; の時には、&quot;msg&quot; 引数は受信したメッセー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ジの本文で、Vim の型に変換されています。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mode&quot; が &quot;nl&quot; の時には、&quot;msg&quot; 引数は NL を除く 1 つのメッセー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ジです。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mode&quot; が &quot;raw&quot; の時には、&quot;msg&quot; 引数はメッセージ全体を格納し<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;た文字列です。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;すべてのコールバック:&nbsp;<a class="Identifier" href="eval.html#function()">function()</a>&nbsp;を使用して、引数および/また<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;は辞書にバインドします。または、&quot;dict.function&quot; という形式を使<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用して辞書をバインドします。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;コールバックは、通常、Vim がユーザーが文字を入力するのを待って<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;いるとき、「安全な」瞬間にのみ呼び出されます。Vim はマルチス<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;レッドを使用しません。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#close_cb" name="close_cb">close_cb</a><br>
&quot;close_cb&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="eval.html#ch_close()">ch_close()</a>&nbsp;を呼び出す以外に、チャネルが閉じられたときに呼び<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;出される関数。このように定義する必要があります:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func MyCloseHandler(channel)</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vim は close_cb を呼び出す前にデータを処理するコールバックを呼<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;び出します。したがって、この関数が呼び出されると、それ以上の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;データはコールバックに渡されません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-drop" name="channel-drop">channel-drop</a><br>
&quot;drop&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メッセージをいつドロップするかを指定します:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;auto&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メッセージを処理するコールバックがない場合。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;close_cb&quot; もこのために考慮されます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;never&quot;&nbsp;&nbsp;&nbsp;&nbsp; すべてのメッセージが保存されます。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-noblock" name="channel-noblock">channel-noblock</a><br>
&quot;noblock&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="channel.html#job-noblock">job-noblock</a>&nbsp;と同じ効果です。書込みの為だけの事項です。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#waittime" name="waittime">waittime</a><br>
&quot;waittime&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接続がミリ秒単位で待機する時間。負の数は永遠に待ちます。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;デフォルトはゼロで、待機しません。これは、ローカルサーバーがす<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;でに実行されている場合に便利です。Unix Vim では実際には 1ms の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;タイムアウトが使われます。多くのシステムではそれが必要なためで<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。リモートサーバーには大きな値を使用してください。例: 少なく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;とも 10msec。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-timeout" name="channel-timeout">channel-timeout</a><br>
&quot;timeout&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ブロッキング時にリクエストを待つ時間 (例:&nbsp;<a class="Identifier" href="eval.html#ch_evalexpr()">ch_evalexpr()</a>&nbsp;を使<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用するとき。ミリ秒単位。デフォルトは 2000 (2 秒) です。<br>
<br>
&quot;mode&quot; が &quot;json&quot; か &quot;js&quot; の時には &quot;callback&quot; はオプションです。これを省略した<br>
場合、メッセージを 1 つ受信するにはメッセージを 1 つ送信する必要があります。<br>
<br>
チャネルオプションを開いた後に変更するには、<a class="Identifier" href="eval.html#ch_setoptions()">ch_setoptions()</a>&nbsp;を使用します。<br>
引数は&nbsp;<a class="Identifier" href="eval.html#ch_open()">ch_open()</a>&nbsp;に渡されるものと似ていますが、&quot;waittime&quot; は与えられません。<br>
これはチャネルを開く場合にのみ適用されるためです。<br>
<br>
例えば、ハンドラーは後から追加したり、変更したりできます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_setoptions(channel, {'callback': callback})</div>
&quot;callback&quot; が空の場合 (一度も指定しないか、空文字列を指定した場合) ハンドラー<br>
は削除されます。<br>
<br>
コールバックが呼び出された後、Vim は画面を更新し、カーソルをそれが属する場所に<br>
戻します。コールバックは&nbsp;<a class="Comment" href="various.html#:redraw">:redraw</a>&nbsp;を行う必要はありません。<br>
<br>
タイムアウトは次のように変更できます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_setoptions(channel, {'timeout': msec})</div>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-close" name="channel-close">channel-close</a>&nbsp;<a class="Constant" href="channel.html#E906" name="E906">E906</a><br>
チャネルを使い終わったら、以下のように切断してください:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_close(channel)</div>
ソケットが使用されていると、両方向のソケットが閉じられます。パイプが使用されて<br>
いると (stdin/stdout/stderr)、それらはすべて閉じられます。これはあなたが望むも<br>
のではないかもしれません！<a class="Identifier" href="eval.html#job_stop()">job_stop()</a>&nbsp;でジョブを停止する方が良いかもしれませ<br>
ん。すべての先読みは破棄され、コールバックは呼び出されなくなります。<br>
<br>
チャネルは 3 つの段階で閉じられることに注意してください:<br>
&nbsp;&nbsp;- I/O が終了し、ログメッセージ: &quot;Closing channel&quot; が表示されます。呼び出すた<br>
&nbsp;&nbsp;&nbsp;&nbsp;めの読み込みまたはコールバックのキューに入れられたメッセージがまだ残ってい<br>
&nbsp;&nbsp;&nbsp;&nbsp;る可能性があります。<br>
&nbsp;&nbsp;- 先読みがクリアされ、ログメッセージ: &quot;Clearing channel&quot; が表示されます。変<br>
&nbsp;&nbsp;&nbsp;&nbsp;数によっては引き続きチャネルを参照することがあります。<br>
&nbsp;&nbsp;- チャネルが解放され、ログメッセージ： &quot;Freeing channel&quot; が表示されます。<br>
<br>
チャネルを開くことができない場合、エラーメッセージが表示されます。MS-Windows<br>
と Unix には違いがあります: Unix では、ポートが存在しないとき、<a class="Identifier" href="eval.html#ch_open()">ch_open()</a>&nbsp;は<br>
すぐに失敗します。MS-Windows では &quot;waittime&quot; が適用されます。<br>
<a class="Constant" href="channel.html#E898" name="E898">E898</a>&nbsp;<a class="Constant" href="channel.html#E901" name="E901">E901</a>&nbsp;<a class="Constant" href="channel.html#E902" name="E902">E902</a><br>
<br>
チャネルを読み書きする際にエラーが発生した場合、チャネルは閉じられます。<br>
<a class="Constant" href="channel.html#E630" name="E630">E630</a>&nbsp;<a class="Constant" href="channel.html#E631" name="E631">E631</a><br>
<br>
<span class="PreProc">==============================================================================</span><br>
4. JSON、JS チャネルを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-use" name="channel-use">channel-use</a><br>
<br>
&quot;mode&quot; が JSON の場合は、以下のようにメッセージを同期的に送信できます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let response = ch_evalexpr(channel, {expr})</div>
これは通信相手から応答があるまで待ち合わせます。<br>
<br>
mode が JS の場合は、メッセージが JavaScript エンコーディングを使用する点を除<br>
いて、これは同じです。その違いについては、<a class="Identifier" href="eval.html#js_encode()">js_encode()</a>&nbsp;参照。<br>
<br>
応答を処理せずにメッセージを送信する、またはチャネルコールバックに応答を処理さ<br>
せるには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendexpr(channel, {expr})</div>
<br>
メッセージを送信し、応答を特別な関数で非同期的に処理する場合には、このようにし<br>
ます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendexpr(channel, {expr}, {'callback': Handler})</div>
<br>
Vim は、メッセージIDを使用して要求との応答を照合します。応答が受信されると、<br>
コールバックが呼び出されます。同じ ID を持つさらなる応答は無視されます。あなた<br>
のサーバーが複数の応答を返信する場合、ID ゼロで送信する必要があります。それら<br>
はチャネルコールバックに渡されます。<br>
<br>
<span class="Special">{expr}</span>&nbsp;は JSON に変換され、配列で包まれます。<span class="Special">{expr}</span>&nbsp;として文字列 &quot;hello&quot; を送<br>
信した場合に、通信相手が受け取るメッセージの例は次のようになります:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[12,&quot;hello&quot;]</span><br>
<br>
送信される JSON のフォーマットはこのようになっています:<br>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{number}</span>,<span class="Special">{expr}</span>]<br>
<br>
<span class="Special">{number}</span>&nbsp;には毎回異なる値が入ります。これは応答があるならば、必ず使われます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{number}</span>,<span class="Special">{response}</span>]<br>
<br>
このようにして、受信したメッセージがどの送信メッセージに対応するかを知ることが<br>
でき、正しいハンドラーを呼び出すことができます。これによって応答メッセージの到<br>
着順序を気にしなくても良くなります。<br>
<br>
改行文字が JSON テキストを終了しています。これは、読み込まれたテキストを区切る<br>
ために使用できます。例えば Python では:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitidx = read_text.find('\n')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = read_text[:splitidx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rest = read_text[splitidx + 1:]<br>
<br>
送信側はかならず有効な JSON を Vim へ送らなければなりません。Vim は JSON とし<br>
て解釈することで、受信メッセージの終端をチェックします。終端を受信することが、<br>
メッセージを受理する唯一の方法です。メッセージの後の改行はオプションです。<br>
<br>
サーバープロセスが Vim からのメッセージを受信すること無く、メッセージを送信す<br>
るには、数値に 0 を使う必要があります。<br>
&nbsp;&nbsp;&nbsp;&nbsp;[0,<span class="Special">{response}</span>]<br>
<br>
するとチャネルのハンドラーが&nbsp;<span class="Special">{response}</span>&nbsp;を Vim の方に変換したものを受け取るで<br>
しょう。チャネルにハンドラーが関連付けられていない場合には、メッセージは破棄さ<br>
れます。<br>
<br>
JSON または JS チャネルで&nbsp;<a class="Identifier" href="eval.html#ch_sendraw()">ch_sendraw()</a>&nbsp;および&nbsp;<a class="Identifier" href="eval.html#ch_evalraw()">ch_evalraw()</a>&nbsp;を使用すること<br>
もできます。その場合呼び出し元は、正しくエンコードとデコードを行う完全な責任が<br>
あります。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
5. チャネルコマンド&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-commands" name="channel-commands">channel-commands</a><br>
<br>
JSON チャネルを使用すると、サーバープロセス側は Vim へコマンドを送信できます。<br>
そのコマンドはチャネルのハンドラーを介さずに、Vim の内部で実行されます。<br>
<br>
実行可能なコマンドは以下のとおりです:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#E903" name="E903">E903</a>&nbsp;<a class="Constant" href="channel.html#E904" name="E904">E904</a>&nbsp;<a class="Constant" href="channel.html#E905" name="E905">E905</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;redraw&quot;,&nbsp;<span class="Special">{forced}</span>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;ex&quot;,&nbsp;&nbsp;&nbsp;&nbsp; {Ex コマンド}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;normal&quot;, {ノーマルモードコマンド}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;eval&quot;,&nbsp;&nbsp; {式}, {数値}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;expr&quot;,&nbsp;&nbsp; {式}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;call&quot;,&nbsp;&nbsp; {関数名}, {引数リスト}, {数値}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;call&quot;,&nbsp;&nbsp; {関数名}, {引数リスト}]<br>
<br>
これらを使うときは、これらのコマンドが何をするかに十分気をつけてください！<br>
ユーザーが何をしているかによっては容易に干渉してしまいます。トラブルを避けるに<br>
は&nbsp;<a class="Identifier" href="eval.html#mode()">mode()</a>&nbsp;を使い、エディタが期待した状態にあるかチェックしてください。例え<br>
ば、コマンド実行ではなくテキストとして入力させたい文字列を送るには、以下のよう<br>
にします:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;ex&quot;,&quot;if mode() == 'i' | call feedkeys('ClassName') | endif&quot;]</span><br>
<br>
これらのコマンドのエラーは、表示が乱れないようにするため、通常は報告されませ<br>
ん。表示したい場合は、<a class="Type" href="options.html#'verbose'">'verbose'</a>&nbsp;オプションを 3 以上に設定してください。<br>
<br>
<br>
<span class="PreProc">コマンド &quot;redraw&quot;</span><br>
<br>
他のコマンドは明示的に画面を更新しないので、カーソルを動かさずに一連のコマンド<br>
を送ることができます。再描画は他のコマンドの副作用として発生することがありま<br>
す。変更されたテキストを表示し、それが属する場所にカーソルを表示するには、<br>
&quot;redraw&quot; コマンドで終了する必要があります。<br>
<br>
引数は通常は空の文字列です:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;redraw&quot;, &quot;&quot;]</span><br>
最初に画面をクリアするには &quot;force&quot; を渡してください:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;redraw&quot;, &quot;force&quot;]</span><br>
<br>
<br>
<span class="PreProc">コマンド &quot;ex&quot;</span><br>
<br>
&quot;ex&quot; コマンドは Ex コマンドを実行します。完了やエラーの応答はありません。<br>
<a class="Identifier" href="eval.html#autoload">autoload</a>&nbsp;スクリプトの中の関数を使えます:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;ex&quot;,&quot;call myscript#MyFunc(arg)&quot;]<br>
<br>
<br>
&quot;call&nbsp;<a class="Identifier" href="eval.html#feedkeys()">feedkeys()</a>&quot; を使用してキーシーケンスを挿入することもできます。<br>
<br>
エラーが発生すると、チャネルログにメッセージが書き込まれ、存在する場合は<br>
v:errmsg にエラーが設定されます。<br>
<br>
<br>
<span class="PreProc">コマンド &quot;normal&quot;</span><br>
<br>
&quot;normal&quot; コマンドは &quot;:normal!&quot; のように実行され、コマンドはマップされません。<br>
カーソルの下の折畳を開く例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;normal&quot; &quot;zO&quot;]<br>
<br>
<br>
<span class="PreProc">コマンド &quot;expr&quot; (応答あり)</span><br>
<br>
&quot;expr&quot; コマンドは、式の結果を得るために使うことができます。たとえば、現在のバッ<br>
ファ内の行数を取得するには、次のようにします:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;expr&quot;,&quot;line('$')&quot;, -2]</span><br>
<br>
式の結果を返します:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[-2, &quot;last line&quot;]</span><br>
形式は次のとおりです:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{number}</span>,&nbsp;<span class="Special">{result}</span>]<br>
<br>
<span class="Special">{number}</span>&nbsp;は、リクエストに指定したのと同じものです。Vim が送信するメッセージと<br>
の混乱を避けるには、負の数を使用します。リクエストとレスポンスを一致させるに<br>
は、リクエストごとに異なる番号を使用します。<br>
<br>
<span class="Special">{result}</span>&nbsp;は評価の結果であり、JSON エンコードされています。評価が失敗したり、結<br>
果を JSON でエンコードできない場合は、文字列 &quot;ERROR&quot; となります。<br>
<br>
<br>
<span class="PreProc">コマンド &quot;expr&quot; (応答なし)</span><br>
<br>
このコマンドは上記の &quot;expr&quot; に近いのですが、応答を返信しません。<br>
例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;expr&quot;,&quot;setline('$', ['one', 'two', 'three'])&quot;]</span><br>
リクエストに第 3 引数はありません。<br>
<br>
<br>
<span class="PreProc">コマンド &quot;call&quot;</span><br>
<br>
これは &quot;expr&quot; に似ていますが、式全体を文字列として渡す代わりに、関数の名前と引<br>
数のリストを渡します。これは、引数の文字列への変換を避け、エスケープして連結し<br>
ます。例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;call&quot;, &quot;line&quot;, [&quot;$&quot;], -2]</span><br>
<br>
応答が送信されない場合は、第 4 引数を省いてください:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;call&quot;, &quot;setline&quot;, [&quot;$&quot;, [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]]]</span><br>
<br>
<span class="PreProc">==============================================================================</span><br>
6. RAW、NL チャネルを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-raw" name="channel-raw">channel-raw</a><br>
<br>
モードが RAW か NL の場合には、以下のようにしてメッセージを送信します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let response = ch_evalraw(channel, {string})</div>
<br>
<span class="Special">{string}</span>&nbsp;はそのまま送信されます。受信した応答メッセージは直ちにチャネルから読<br>
み込み可能になります。この時、Vim にはメッセージの終了をどう判断するかがわかり<br>
ませんから、あなた自身が面倒を見る必要があります。タイムアウトは、最初のバイト<br>
を読み取るために適用され、その後は何も待つことはありません。<br>
<br>
mode が &quot;nl&quot; の場合、同様の方法でメッセージを送信できます。あなたは各メッセー<br>
ジの後に NL に入れなければなりません。したがって、一度に NL で終わる複数のメッ<br>
セージを送信することもできます。応答は最初の NL までのテキストとなります。これ<br>
は空のレスポンスの NL だけでもかまいません。チャネルタイムアウトの前に NL が読<br>
み取られなかった場合、空の文字列が返されます。<br>
<br>
<br>
応答を必要としないメッセージを送信するには以下のようにします:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendraw(channel, {string})</div>
プロセス&nbsp;<span class="Special">{訳注:サーバーのこと}</span>&nbsp;はレスポンスを返し、チャネルのハンドラーに渡さ<br>
れます。<br>
<br>
メッセージを送信し、レスポンスを特定の関数で非同期的に取り扱うには以下のように<br>
します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendraw(channel, {string}, {'callback': 'MyHandler'})</div>
<br>
この&nbsp;<span class="Special">{string}</span>&nbsp;は JSON にもできます。その場合、<a class="Identifier" href="eval.html#json_encode()">json_encode()</a>&nbsp;でそれを作成し<br>
<a class="Identifier" href="eval.html#json_decode()">json_decode()</a>&nbsp;で受信した JSON メッセージを取り扱います。<br>
<br>
生のチャネルで&nbsp;<a class="Identifier" href="eval.html#ch_evalexpr()">ch_evalexpr()</a>&nbsp;または&nbsp;<a class="Identifier" href="eval.html#ch_sendexpr()">ch_sendexpr()</a>&nbsp;を使用することはできませ<br>
ん。<br>
<br>
Vim の文字列に NUL バイトを含めることはできません。NUL バイトを送受信するには、<br>
バッファから読み書きしてください。<a class="Identifier" href="channel.html#in_io-buffer">in_io-buffer</a>&nbsp;と&nbsp;<a class="Identifier" href="channel.html#out_io-buffer">out_io-buffer</a>&nbsp;参照。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
7. その他のチャネル機能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-more" name="channel-more">channel-more</a><br>
<br>
チャネルのステータスを取得するには、ch_status(channel) を使用します。ありうる<br>
結果は次のとおりです:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;fail&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャネルを開くことができませんでした。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;open&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャネルを使用することができます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;buffered&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャネルは閉じられましたが読み込むデータがあります。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;closed&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャネルが閉じられました。<br>
<br>
チャネルに関連付けられたジョブを取得するには: ch_getjob(channel)<br>
<br>
チャネルから 1 つのメッセージを読むには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = ch_read(channel)</div>
これは、チャネルのタイムアウトを使用します。タイムアウトなしで読むには、利用可<br>
能なメッセージを取得するだけです:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = ch_read(channel, {'timeout': 0})</div>
メッセージが利用できなかった場合、結果は JSON または JS モードのチャネルでは<br>
v:none、RAW または NL チャネルでは空の文字列です。<a class="Identifier" href="eval.html#ch_canread()">ch_canread()</a>&nbsp;を使用して、<br>
何かがあるかどうかを調べることができます。<br>
<br>
コールバックメッセージがない場合、メッセージは破棄されます。これを回避するに<br>
は、チャネルにコールバックを追加します。<br>
<br>
使用可能な RAW チャネルからすべての出力を読み込むには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = ch_readraw(channel)</div>
エラー出力を読むには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = ch_readraw(channel, {&quot;part&quot;: &quot;err&quot;})</div>
<br>
ch_read() と ch_readraw() はチャネルタイムアウトを使用します。その時間内に何も<br>
読み込めない場合、空の文字列が返されます。別のタイムアウトをミリ秒で指定するに<br>
は、&quot;timeout&quot; オプションを使用します:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">{&quot;timeout&quot;: 123}</span><br>
エラー出力から読み込むには、&quot;part&quot; オプションを使用します:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">{&quot;part&quot;: &quot;err&quot;}</span><br>
特定の ID を持つメッセージを JS または JSON チャネルで読み取るには:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">{&quot;id&quot;: 99}</span><br>
ID が指定されていないか、または ID が -1 の場合、最初のメッセージが返されます。<br>
これは、このメッセージを待っているコールバックをすべて無効にします。<br>
<br>
RAW チャネルの場合、Vim はメッセージの終わりを知らないので、利用可能なものを返<br>
します。<br>
NL チャネルの場合、これは 1 つのメッセージを返します。<br>
JS または JSON チャネルの場合、これは1つのデコードされたメッセージを返します。<br>
これには、任意のシーケンス番号が含まれます。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
8. チャネルでジョブを開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-start" name="job-start">job-start</a>&nbsp;<a class="Constant" href="channel.html#job" name="job">job</a><br>
<br>
<br>
ジョブを開始し、stdin/stdout/stderr のチャネルを開くには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {options})</div>
<br>
チャネルを得るには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let channel = job_getchannel(job)</div>
<br>
チャネルは NL モードを使用します。別のモードが必要な場合は、<span class="Special">{options}</span>&nbsp;でこれを<br>
指定することをお勧めします。後でモードを変更すると、一部のテキストがすでに受信<br>
され、正しく解析されていない可能性があります。<br>
<br>
コマンドが処理したい出力行を生成する場合は、stdout のハンドラを指定します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {&quot;out_cb&quot;: &quot;MyHandler&quot;})</div>
この関数は、チャネルとメッセージで呼び出されます。あなたはこれをこのように定義<br>
します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;func MyHandler(channel, msg)</div>
<br>
ハンドラがなければ、<a class="Identifier" href="eval.html#ch_read()">ch_read()</a>&nbsp;または&nbsp;<a class="Identifier" href="eval.html#ch_readraw()">ch_readraw()</a>&nbsp;で出力を読み取る必要があ<br>
ります。クローズコールバックでこれを行うことができます。<a class="Identifier" href="channel.html#read-in-close-cb">read-in-close-cb</a>&nbsp;参<br>
照。<br>
<br>
出力を読み取る前にジョブが終了すると、出力が失われる可能性があることに注意して<br>
ください。これはシステムによって異なります (Unix 上では、パイプの書き込み終了<br>
を閉じると EOF が得られます)。これを避けるには、ジョブが終了する前にそれをしば<br>
らくスリープさせること。<br>
<br>
&quot;out_cb&quot; に定義されたハンドラは stderr を受け取りません。もし個別に扱いたい場<br>
合は、&quot;err_cb&quot; ハンドラを追加します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {&quot;out_cb&quot;: &quot;MyHandler&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;err_cb&quot;: &quot;ErrHandler&quot;})</div>
<br>
1 つのハンドラで stderr と stdout の両方を処理する場合は、&quot;callback&quot; オプショ<br>
ンを使用します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {&quot;callback&quot;: &quot;MyHandler&quot;})&nbsp;</div>
<br>
システムによっては、ジョブを開始するとVimをバックグラウンドに移動することがあ<br>
り、開始されたジョブはフォーカスを取得します。これを避けるには&nbsp;<a class="Comment" href="eval.html#foreground()">foreground()</a><br>
関数を使用してください。これは、早く呼び出されたとき、コールバックハンドラ内に<br>
置いたとき、またはジョブが開始した後にタイマーを使用して呼び出すときは、必ずし<br>
も機能しない場合があります。<br>
<br>
ch_evalraw() でコマンドにメッセージを送ることができます。チャネルが JSON また<br>
は JS モードの場合、ch_evalexpr() を使用できます。<br>
<br>
使用できるオプションがいくつかあります。<a class="Identifier" href="channel.html#job-options">job-options</a>&nbsp;参照。<br>
例えば、ジョブを開始し、その出力をバッファ &quot;dummy&quot; に書き込むには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let logjob = job_start(&quot;tail -f /tmp/log&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ {'out_io': 'buffer', 'out_name': 'dummy'})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sbuf dummy</div>
<br>
<br>
<span class="PreProc">バッファからのジョブ入力</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#in_io-buffer" name="in_io-buffer">in_io-buffer</a><br>
バッファから読み取るジョブを実行するには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start({command},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ {'in_io': 'buffer', 'in_name': 'mybuffer'})</div>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#E915" name="E915">E915</a>&nbsp;<a class="Constant" href="channel.html#E918" name="E918">E918</a><br>
バッファは、<a class="Identifier" href="eval.html#bufnr()">bufnr()</a>&nbsp;と同様の名前で見つけられます。バッファは、job_start()<br>
が呼び出されたときに存在し、ロードされていなければなりません。<br>
<br>
デフォルトでは、これはバッファ全体を読み込みます。これは &quot;in_top&quot; と &quot;in_bot&quot;<br>
オプションで変更できます。<br>
<br>
特殊モードは、&quot;in_top&quot; が 0 に設定され、&quot;in_bot&quot; が設定されていない場合です。<br>
バッファに行が追加されるたびに、最後の 1 行がジョブ stdin に送信されます。これ<br>
により、最後の行を編集し、Enter を押したときに送信することができます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#channel-close-in" name="channel-close-in">channel-close-in</a><br>
特殊モードを使用しないときは、最後の行が書き込まれた後にパイプまたはソケットが<br>
閉じられます。これは、入力が終了した読み取り終了を知らせます。<a class="Identifier" href="eval.html#ch_close_in()">ch_close_in()</a><br>
を使用すると、より早く終了することもできます。<br>
<br>
テキストの NUL バイトはジョブに渡されます (内部では Vim はこれらを NL バイトと<br>
して格納します)。<br>
<br>
<br>
<span class="PreProc">クローズコールバックでジョブ出力を読み込む</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#read-in-close-cb" name="read-in-close-cb">read-in-close-cb</a><br>
ジョブに時間がかかり、中間結果が必要ない場合は、クローズコールバックを追加して<br>
そこの出力を読み取ることができます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func! CloseHandler(channel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ch_status(a:channel, {'part': 'out'}) == 'buffered'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echomsg ch_read(a:channel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endwhile<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {'close_cb': 'CloseHandler'})</div>
<br>
あなたは &quot;echomsg&quot; よりも役に立つ何かをしたいでしょう。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
9. チャネルなしでジョブを開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-start-nochannel" name="job-start-nochannel">job-start-nochannel</a><br>
<br>
チャネルを作成せずに別のプロセスを開始するには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ {&quot;in_io&quot;: &quot;null&quot;, &quot;out_io&quot;: &quot;null&quot;, &quot;err_io&quot;: &quot;null&quot;})</div>
<br>
これはバックグラウンドで&nbsp;<span class="Special">{command}</span>&nbsp;を開始し、Vim はそれが完了するのを待ちませ<br>
ん。<br>
<br>
Vim が stdin、stdout、stderr のいずれも接続されていないと判断すると、チャネル<br>
は作成されません。コマンドが停止するのを避けるために、リダイレクションをコマン<br>
ドに含めることがよくあります。<br>
<br>
使用できるオプションがいくつかあります。<a class="Identifier" href="channel.html#job-options">job-options</a>&nbsp;参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-start-if-needed" name="job-start-if-needed">job-start-if-needed</a><br>
アドレスへの接続が動作しない時にのみジョブを開始するには、次のような操作を行い<br>
ます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open(address, {&quot;waittime&quot;: 0})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ch_status(channel) == &quot;fail&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open(address, {&quot;waittime&quot;: 1000})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
ch_open() の待ち時間は、ポートを利用可能にするためにジョブに 1 秒を与えること<br>
に注意してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
10. ジョブオプション&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-options" name="job-options">job-options</a><br>
<br>
job_start() の&nbsp;<span class="Special">{options}</span>&nbsp;引数は辞書です。すべての入力はオプションです。<br>
job_setoptions(job,&nbsp;<span class="Special">{options}</span>) を使用して、ジョブの開始後にいくつかのオプショ<br>
ンを使用できます。ch_setoptions(channel,&nbsp;<span class="Special">{options}</span>) を使用して、ジョブに関連す<br>
るチャネルで多くのオプションを使用できます。<a class="Identifier" href="eval.html#job_setoptions()">job_setoptions()</a>&nbsp;および<br>
<a class="Identifier" href="eval.html#ch_setoptions()">ch_setoptions()</a>&nbsp;参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#in_mode" name="in_mode">in_mode</a>&nbsp;<a class="Constant" href="channel.html#out_mode" name="out_mode">out_mode</a>&nbsp;<a class="Constant" href="channel.html#err_mode" name="err_mode">err_mode</a><br>
&quot;in_mode&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdin 用のモード、パイプを使用している場合にのみ。<br>
&quot;out_mode&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout 用のモード、パイプを使用している場合にのみ。<br>
&quot;err_mode&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr 用のモード、パイプを使用している場合にのみ。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;値については、<a class="Identifier" href="channel.html#channel-mode">channel-mode</a>&nbsp;参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>: &quot;mode&quot; を設定すると、パーツ固有のモードが上書き<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;されます。したがって、最初に &quot;mode&quot; を、後でパーツ固有<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のモードを設定します。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>: ファイルやバッファに書き込むときやバッファから読<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;み込むときは、NL モードがデフォルトで使用されます。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-noblock" name="job-noblock">job-noblock</a><br>
&quot;noblock&quot;: 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;書き込み時に、非ブロッキング書き込み呼び出しを使用しま<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。これは Vim が間に他のメッセージを処理する必要があ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る場合に止まるのを回避します。例えば、ジョブが Vim に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;データを返すとき。これは、<a class="Comment" href="eval.html#ch_sendraw()">ch_sendraw()</a>&nbsp;が返されたと<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;きに、すべてのデータがまだ書き込まれていない可能性があ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ることを意味します。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;このオプションはパッチ 8.1.0350 で追加され、以下を使っ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;て検査します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if has(&quot;patch-8.1.350&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let options['noblock'] = 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-callback" name="job-callback">job-callback</a><br>
&quot;callback&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp; チャネルの任意の部分で何かを読むためのコールバック。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-out_cb" name="job-out_cb">job-out_cb</a>&nbsp;<a class="Constant" href="channel.html#out_cb" name="out_cb">out_cb</a><br>
&quot;out_cb&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdout で読み込むべきものがあるときのコールバック。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャネルがパイプを使用している場合のみ。&quot;out_cb&quot; が設<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定されていない場合は、チャネルコールバックが使用されま<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。2 つの引数はチャネルとメッセージです。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-err_cb" name="job-err_cb">job-err_cb</a>&nbsp;<a class="Constant" href="channel.html#err_cb" name="err_cb">err_cb</a><br>
&quot;err_cb&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stderr で読み込むべきものがあるときのコールバック。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャネルがパイプを使用している場合のみ。&quot;err_cb&quot; が設<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定されていない場合は、チャネルコールバックが使用されま<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。2 つの引数はチャネルとメッセージです。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-close_cb" name="job-close_cb">job-close_cb</a><br>
&quot;close_cb&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp; チャネルが閉じられるときのコールバック。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="eval.html#ch_open()">ch_open()</a>&nbsp;の &quot;close_cb&quot; と同じです。<a class="Identifier" href="channel.html#close_cb">close_cb</a>&nbsp;参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-drop" name="job-drop">job-drop</a><br>
&quot;drop&quot;: when&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メッセージをいつドロップするかを指定します。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="eval.html#ch_open()">ch_open()</a>&nbsp;の &quot;drop&quot; と同様(<a class="Identifier" href="channel.html#channel-drop">channel-drop</a>&nbsp;参照)。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;auto&quot; の場合、exit_cb は考慮されません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-exit_cb" name="job-exit_cb">job-exit_cb</a><br>
&quot;exit_cb&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ジョブが終了したときのコールバック。引数はジョブと終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ステータスです。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim は、終了したジョブに対して最大 10 回/秒をチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;します。チェックは、<a class="Identifier" href="eval.html#job_status()">job_status()</a>&nbsp;を呼び出すことによっ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;てトリガーすることもでき、exit_cb ハンドラを呼び出すこ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;とができます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;データがバッファリングされ、プロセスが終了した後もコー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ルバックが呼び出されることに注意してください。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-timeout" name="job-timeout">job-timeout</a><br>
&quot;timeout&quot;: time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ブロッキング時にリクエストを待つ時間 (例: ch_evalexpr()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を使用するとき。ミリ秒単位。デフォルトは 2000 (2 秒)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;です。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#out_timeout" name="out_timeout">out_timeout</a>&nbsp;<a class="Constant" href="channel.html#err_timeout" name="err_timeout">err_timeout</a><br>
&quot;out_timeout&quot;: time&nbsp;&nbsp;&nbsp;&nbsp; stdout のタイムアウト。パイプ使用時のみ。<br>
&quot;err_timeout&quot;: time&nbsp;&nbsp;&nbsp;&nbsp; stderr のタイムアウト。パイプ使用時のみ。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>: &quot;timeout&quot; を設定すると、パーツ固有のモードが上書<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;きされます。したがって、最初に &quot;timeout&quot; を設定し、後<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;でパーツ固有のモードを設定します。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-stoponexit" name="job-stoponexit">job-stoponexit</a><br>
&quot;stoponexit&quot;:&nbsp;<span class="Special">{signal}</span>&nbsp;&nbsp;Vim が終了すると&nbsp;<span class="Special">{signal}</span>&nbsp;をジョブに送ります。可能な値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;については、<a class="Identifier" href="eval.html#job_stop()">job_stop()</a>&nbsp;参照。<br>
&quot;stoponexit&quot;: &quot;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim が終了してもジョブを停止しません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;デフォルトは &quot;term&quot; です。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-term" name="job-term">job-term</a><br>
&quot;term&quot;: &quot;open&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新しいウィンドウでターミナルを起動し、ジョブ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdin/stdout/stderr を接続します。<a class="Comment" href="terminal.html#:terminal">:terminal</a>&nbsp;を使用す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ることと同じです。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">NOTE</span>: まだ実装されていません!<br>
<br>
&quot;channel&quot;:&nbsp;<span class="Special">{channel}</span>&nbsp;&nbsp;&nbsp;&nbsp;新しいチャネルを作成する代わりに、既存のチャネルを使用<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;します。新しいジョブに使用されるチャネルの部分は、以前<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用された部分から切り離されます。チャネルが別のジョブ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;で引き続き使用されていた場合、I/O エラーが発生する可能<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;性があります。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既存のコールバックやその他の設定が残っています。<br>
<br>
&quot;pty&quot;: 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能であれば、パイプのかわりに pty (疑似 tty) を使いま<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。これは端末ウィンドウとの組み合わせで最も便利です。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="terminal.html#terminal">terminal</a>&nbsp;を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Unix系システムのみ}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-in_io" name="job-in_io">job-in_io</a>&nbsp;<a class="Constant" href="channel.html#in_top" name="in_top">in_top</a>&nbsp;<a class="Constant" href="channel.html#in_bot" name="in_bot">in_bot</a>&nbsp;<a class="Constant" href="channel.html#in_name" name="in_name">in_name</a>&nbsp;<a class="Constant" href="channel.html#in_buf" name="in_buf">in_buf</a><br>
&quot;in_io&quot;: &quot;null&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdin を切断する (/dev/null から読み込む)<br>
&quot;in_io&quot;: &quot;pipe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 標準入力がチャネルに接続されている (デフォルト)<br>
&quot;in_io&quot;: &quot;file&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdin はファイルから読み込む<br>
&quot;in_io&quot;: &quot;buffer&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdin はバッファから読み込む<br>
&quot;in_top&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;buffer&quot; を使用する場合: 送信する最初の行<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(デフォルト: 1)<br>
&quot;in_bot&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;buffer&quot; を使用する場合: 送信する最後の行<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(デフォルト: 最後)<br>
&quot;in_name&quot;: &quot;/path/file&quot; 読み込むファイルまたはバッファの名前<br>
&quot;in_buf&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;読み込むバッファの番号<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-out_io" name="job-out_io">job-out_io</a>&nbsp;<a class="Constant" href="channel.html#out_name" name="out_name">out_name</a>&nbsp;<a class="Constant" href="channel.html#out_buf" name="out_buf">out_buf</a><br>
&quot;out_io&quot;: &quot;null&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout を切断する (/dev/null に行く)<br>
&quot;out_io&quot;: &quot;pipe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout がチャネルに接続されている (デフォルト)<br>
&quot;out_io&quot;: &quot;file&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout がファイルに書き込む<br>
&quot;out_io&quot;: &quot;buffer&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout はバッファに追加する (下記参照)<br>
&quot;out_name&quot;: &quot;/path/file&quot; 書き込むファイルまたはバッファの名前<br>
&quot;out_buf&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 書き込むバッファの番号<br>
&quot;out_modifiable&quot;: 0&nbsp;&nbsp;&nbsp;&nbsp; バッファに書き込むときに、<a class="Type" href="options.html#'modifiable'">'modifiable'</a>&nbsp;はオフになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(下記参照)<br>
&quot;out_msg&quot;: 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新しいバッファに書き込むとき、最初の行は &quot;Reading from<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel output...&quot; に設定される<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-err_io" name="job-err_io">job-err_io</a>&nbsp;<a class="Constant" href="channel.html#err_name" name="err_name">err_name</a>&nbsp;<a class="Constant" href="channel.html#err_buf" name="err_buf">err_buf</a><br>
&quot;err_io&quot;: &quot;out&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stderr のメッセージは stdout に行く<br>
&quot;err_io&quot;: &quot;null&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr を切断する (/dev/null に行く)<br>
&quot;err_io&quot;: &quot;pipe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr がチャネルに接続されている (デフォルト)<br>
&quot;err_io&quot;: &quot;file&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr はファイルに書き込む<br>
&quot;err_io&quot;: &quot;buffer&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr はバッファに追加する (下記参照)<br>
&quot;err_name&quot;: &quot;/path/file&quot; 書き込むファイルまたはバッファの名前<br>
&quot;err_buf&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 書き込むバッファの番号<br>
&quot;err_modifiable&quot;: 0&nbsp;&nbsp;&nbsp;&nbsp; バッファに書き込むときに、<a class="Type" href="options.html#'modifiable'">'modifiable'</a>&nbsp;はオフになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(下記参照)<br>
&quot;err_msg&quot;: 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新しいバッファに書き込むとき、最初の行は &quot;Reading from<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel error...&quot; に設定される<br>
<br>
&quot;block_write&quot;: number&nbsp;&nbsp; テストのためにのみ: stdin への他のすべての書き込みをブ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ロックするふりをする<br>
<br>
&quot;env&quot;: dict&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 新しいプロセスのための環境変数<br>
&quot;cwd&quot;: &quot;/path/to/dir&quot;&nbsp;&nbsp; 新しいプロセスのためのカレント作業ディレクトリ。ディレ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;クトリが存在しない場合は、エラーが発生します<br>
<br>
<br>
<span class="PreProc">バッファへの書き込み</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#out_io-buffer" name="out_io-buffer">out_io-buffer</a><br>
out_io または err_io モードが &quot;buffer&quot; で、コールバックがある場合、コールバッ<br>
クを呼び出す前にテキストがバッファに追加されます。<br>
<br>
入力と出力の両方にバッファが使用されている場合、最後の行はチャネル入力に書き込<br>
まれたものなので、出力行は最後の行の上に置かれます。それ以外の場合は最後の行の<br>
下に行が追加されます。<br>
<br>
&quot;buffer&quot; を指定して JS または JSON モードを使用すると、デコード+エンコーディン<br>
グ後に、ゼロまたは負の ID を持つメッセージのみがバッファに追加されます。正の数<br>
を持つメッセージはコールバックによって処理され、コマンドは通常通り処理されま<br>
す。<br>
<br>
&quot;out_name&quot; または &quot;err_name&quot; のバッファ名は、現在のディレクトリの名前を拡張し<br>
た後も、既存のバッファの完全名と比較されます。たとえば、&quot;:edit somename&quot; でバッ<br>
ファが作成され、バッファ名が &quot;somename&quot; の場合、そのバッファが使用されます。<br>
<br>
一致するバッファがない場合、新しいバッファが作成されます。新しいバッファを常に<br>
作成するには、空の名前を使用します。<a class="Identifier" href="eval.html#ch_getbufnr()">ch_getbufnr()</a>&nbsp;を使用してバッファ番号を取<br>
得できます。<br>
<br>
新しいバッファの場合、<a class="Type" href="options.html#'buftype'">'buftype'</a>&nbsp;は &quot;nofile&quot; に設定され、<a class="Type" href="options.html#'bufhidden'">'bufhidden'</a>&nbsp;は &quot;hide&quot;<br>
に設定されます。他の設定が必要な場合は、まずバッファを作成し、バッファ番号を渡<br>
します。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#out_modifiable" name="out_modifiable">out_modifiable</a>&nbsp;<a class="Constant" href="channel.html#err_modifiable" name="err_modifiable">err_modifiable</a><br>
&quot;out_modifiable&quot; と &quot;err_modifiable&quot; オプションは、<a class="Type" href="options.html#'modifiable'">'modifiable'</a>&nbsp;オプションをオ<br>
フにするか、<a class="Type" href="options.html#'modifiable'">'modifiable'</a>&nbsp;になっているバッファに書き込むために使用できます。つ<br>
まり、行がバッファに追加されますが、ユーザーはバッファを簡単に変更できません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#out_msg" name="out_msg">out_msg</a>&nbsp;<a class="Constant" href="channel.html#err_msg" name="err_msg">err_msg</a><br>
&quot;out_msg&quot; オプションは、新しいバッファが最初の行を &quot;Reading from channel<br>
output...&quot; に設定するかどうかを指定するために使用できます。デフォルトではメッ<br>
セージを追加します。&quot;err_msg&quot; はチャネルエラーでも同じです。<br>
<br>
既存のバッファに&nbsp;<a class="Type" href="options.html#'modifiable'">'modifiable'</a>&nbsp;が指定されておらず、&quot;out_modifiable&quot; または<br>
&quot;err_modifiable&quot; オプションがゼロでない場合、エラーが発生し、バッファに書き込<br>
まれません。<br>
<br>
書き込まれたバッファがウィンドウに表示され、カーソルが最後の行の最初の列にある<br>
場合、カーソルは新しく追加された行に移動され、ウィンドウは必要に応じてカーソル<br>
を表示するために上にスクロールされます。<br>
<br>
追加されたすべての行に対して、取り消しが同期されます。NUL バイトは受け入れられ<br>
ます (内部では Vim はこれらを NL バイトとして格納します)。<br>
<br>
<br>
<span class="PreProc">ファイルへの書き込み</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#E920" name="E920">E920</a><br>
ファイルはアクセス許可 600 (ユーザーに対しては読み書き可能、他のユーザーはアク<br>
セス不可) で作成されます。これを変更するには、<a class="Identifier" href="eval.html#setfperm()">setfperm()</a>&nbsp;を使用してください。<br>
<br>
ファイルがすでに存在する場合は切り捨てられます。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
11. ジョブを制御する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#job-control" name="job-control">job-control</a><br>
<br>
ジョブの状態を取得するには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo job_status(job)</div>
<br>
ジョブの実行を停止するには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job_stop(job)</div>
<br>
これはジョブを終了させる通常の方法です。Unix では、ジョブに SIGTERM を送信しま<br>
す。他の方法でジョブを停止したり、任意の信号を送信したりすることもできます。<br>
例えば、ジョブを強制的に停止させるには、&quot;kill it&quot;:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job_stop(job, &quot;kill&quot;)</div>
<br>
他のオプションについては、<a class="Identifier" href="eval.html#job_stop()">job_stop()</a>&nbsp;参照。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
12. プロンプトバッファを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="channel.html#prompt-buffer" name="prompt-buffer">prompt-buffer</a><br>
<br>
Vimのウィンドウでジョブのための入力をタイプしたい場合、いくつかのオプションが<br>
あります:<br>
- 通常のバッファを使用して、すべての起こりうるコマンドを自分で処理します。<br>
&nbsp;&nbsp;たくさんの起こりうるコマンドが存在するので、これは複雑になります。<br>
- 端末ウィンドウを使用します。入力した内容がジョブに直接送られ、ジョブの出力が<br>
&nbsp;&nbsp;ウィンドウに直接表示される場合は、これはうまく機能します。<br>
&nbsp;&nbsp;<a class="Identifier" href="terminal.html#terminal-window">terminal-window</a>&nbsp;参照。<br>
- プロンプトウィンドウを使用します。これは、Vimでジョブからの出力 (フィルタリ<br>
&nbsp;&nbsp;ングされている可能性もある) を表示している間に、ジョブのための行を入力してい<br>
&nbsp;&nbsp;るときにうまく動作します。<br>
<br>
プロンプトバッファは、<a class="Type" href="options.html#'buftype'">'buftype'</a>&nbsp;を &quot;prompt&quot; に設定することによって作成されま<br>
す。通常は、新規作成バッファでのみおこないます。<br>
<br>
ユーザーは、バッファの最後の行に1行のテキストを編集して入力することができます。<br>
プロンプト行でEnterキーを押すと、<a class="Identifier" href="eval.html#prompt_setcallback()">prompt_setcallback()</a>&nbsp;で設定されたコールバッ<br>
クが呼び出されます。通常は、その行をジョブに送信します。別のコールバックは、<br>
ジョブからの出力を受け取り、バッファ内のプロンプトの下 (次のプロンプトの上) に<br>
表示します。<br>
<br>
プロンプトの後の最後の行のテキストのみが編集可能です。残りのバッファはノーマル<br>
モードのコマンドでは変更できません。<a class="Identifier" href="eval.html#append()">append()</a>&nbsp;などの関数を呼び出すことで変更<br>
できます。他のコマンドを使用すると、バッファを壊す可能性があります。<br>
<br>
<a class="Type" href="options.html#'buftype'">'buftype'</a>&nbsp;を &quot;prompt&quot; に設定した後、Vimは自動的に挿入モードを開始しません。挿<br>
入モードに入るには&nbsp;<a class="Comment" href="insert.html#:startinsert">:startinsert</a>&nbsp;を使います。これにより、ユーザーは行の入力を<br>
開始できます。<br>
<br>
プロンプトのテキストは、<a class="Identifier" href="eval.html#prompt_setprompt()">prompt_setprompt()</a>&nbsp;関数で設定できます。<br>
<br>
ユーザーはノーマルモードに移行し、バッファ内を移動できます。これは、古い出力の<br>
参照やテキストのコピーに便利です。<br>
<br>
<span class="Special">CTRL-W</span>&nbsp;キーを使用して次のウィンドウに切り替えるための&nbsp;<span class="Special">CTRL-W</span>&nbsp;w などのウィンド<br>
ウコマンドを開始できます。これは挿入モードでも機能します (単語を削除するには<br>
Shift-<span class="Special">CTRL-W</span>&nbsp;を使用します)。ウィンドウを離れるとき挿入モードは停止します。プロ<br>
ンプトウィンドウに戻ると、挿入モードが復元されます。<br>
<br>
&quot;a&quot;, &quot;i&quot;, &quot;A&quot; や &quot;I&quot; などの挿入モードを開始するコマンドは、最終行にカーソルを<br>
移動します。&quot;A&quot; は行末に移動し、&quot;I&quot; は行頭に移動します。<br>
<br>
<br>
&nbsp;vim:tw=78:ts=8:noet:ft=help:norl:<br>
</div>
